<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="进阶,Android开发艺术探索," />










<meta name="description" content="本章主题是Bitmap的加载和Cache，主要包括三个方面的内容。首先讲述如何有效地加载一个Bitmap，这是一个很有意义的话题，由于Bitmap的特殊性以及Android对单个应用所施加的内存限制，比如16MB，这导致加载Bitmap的时候很容易出现OOM的情况。因此如何高效加载Bitmap是一个很重要但是很容易被忽视的问题。虽然现在有各种成熟的框架，但是还是要知道这方面的知识。接着介绍Andr">
<meta name="keywords" content="进阶,Android开发艺术探索">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索 第十二章 Bitmap的加载和Cache">
<meta property="og:url" content="http://yoursite.com/android/Android开发艺术探索_第十二章 Bitmap的加载和Cache/index.html">
<meta property="og:site_name" content="个人网站">
<meta property="og:description" content="本章主题是Bitmap的加载和Cache，主要包括三个方面的内容。首先讲述如何有效地加载一个Bitmap，这是一个很有意义的话题，由于Bitmap的特殊性以及Android对单个应用所施加的内存限制，比如16MB，这导致加载Bitmap的时候很容易出现OOM的情况。因此如何高效加载Bitmap是一个很重要但是很容易被忽视的问题。虽然现在有各种成熟的框架，但是还是要知道这方面的知识。接着介绍Andr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第十二章%20Bitmap的加载和Cache/meizi.jpg">
<meta property="og:updated_time" content="2018-08-05T09:45:03.802Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索 第十二章 Bitmap的加载和Cache">
<meta name="twitter:description" content="本章主题是Bitmap的加载和Cache，主要包括三个方面的内容。首先讲述如何有效地加载一个Bitmap，这是一个很有意义的话题，由于Bitmap的特殊性以及Android对单个应用所施加的内存限制，比如16MB，这导致加载Bitmap的时候很容易出现OOM的情况。因此如何高效加载Bitmap是一个很重要但是很容易被忽视的问题。虽然现在有各种成熟的框架，但是还是要知道这方面的知识。接着介绍Andr">
<meta name="twitter:image" content="http://yoursite.com/android/Android开发艺术探索_第十二章%20Bitmap的加载和Cache/meizi.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/android/Android开发艺术探索_第十二章 Bitmap的加载和Cache/"/>





  <title>Android开发艺术探索 第十二章 Bitmap的加载和Cache | 个人网站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人网站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/android/Android开发艺术探索_第十二章 Bitmap的加载和Cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Groot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人网站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索 第十二章 Bitmap的加载和Cache</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T17:08:20+08:00">
                2018-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本章主题是Bitmap的加载和Cache，主要包括三个方面的内容。<br>首先讲述如何有效地加载一个Bitmap，这是一个很有意义的话题，由于Bitmap的特殊性以及Android对单个应用所施加的内存限制，比如16MB，这导致加载Bitmap的时候很容易出现OOM的情况。因此如何高效加载Bitmap是一个很重要但是很容易被忽视的问题。虽然现在有各种成熟的框架，但是还是要知道这方面的知识。<br>接着介绍Android中常用的缓存策略，缓存策略是一个通用的思想，可以用在很多场景中，但是实际开发中经常要用到Bitmap做缓存。通过缓存策略，我们不需要每次都从网络上请求图片或者从存储设备中加载图片，这样极大提高了图片的加载效率和用户的使用体验。目前比较常用的图片缓存策略是LruCache和DiskLruCache，其中LruCache常被用作内存缓存，而DiskLruCache常被用作存储缓存。Lru是Least Recently Used 的缩写，即最近最少使用算法。这个算法的核心思想是：当缓存快满时，会淘汰近期使用最少的缓存目标，很显然Lru算法的思想很容易被接受。<br>最后本章会介绍如何优化列表的卡顿现象，ListView和GradView由于要加载大量的子视图，当用户快速滑动时很容易出现卡顿的现象，因此本章最后针对这个问题给出一些优化建议。<br>为了更好的讲述上面三个主题，本章提供了一个实例程序，改程序会尝试从网络加载大量的图片并显示在GridView中，可以发现这个程序有很强的实用性，并完善本节的三个主题：图片加载，缓存策略，列表华东的流畅性，通过这个示例程序读者可以很好的理解本章的全部内容并能在实际中灵活应用。</p>
<h1 id="Bitmap的高效加载"><a href="#Bitmap的高效加载" class="headerlink" title="Bitmap的高效加载"></a>Bitmap的高效加载</h1><p>在介绍Bitmap的高效加载之前，先说一下如何加载一个Bitmap，Bitmap在Android中指的是一张图片，可以是png，也可以是jpg等其他常见的图片格式。那么如何加载一个图片呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.decodeFile()</span><br><span class="line">BitmapFactory.decodeResource()</span><br><span class="line">BitmapFactory.decodeStream()</span><br><span class="line">BitmapFactory.decodeByteArray()</span><br></pre></td></tr></table></figure>
<p>比较常用的是上面这几个方法，都是通过BitmapFactory来构建，分别对应于从文件、资源、流、字节数组加载图片。其中<code>decodeFile</code>和<code>decodeResource</code>又间接调用了<code>decodeStream</code>的方法，这四类方法最终是在Android底层实现的，对应着BitmapFactory的几个native方法。<br>如何高效加载Bitmap呢？其实核心思想很简单，就是采用BitmapFactory.options来加载所需要尺寸的图片。这里假设通过ImageView来显示图片，很多时候ImageView并没有图片原始尺寸那么大，这个时候把整个图片加载进来后再设定给ImageView，这显然没有必要的，因为ImageView并没有办法显示原始的图片。通过BitmapFactory.options就可以按一定的采样率来加载缩小后的图片，将缩小后的图片在ImageView中显示，这样就会降低内存占用从而在一定程度上避免出现OOM问题，提高了Bitmap加载时的性能。BitmapFactory提供的加载图片的四类方法都支持BitmapFactory.options参数，通过他们就可以很方便的对一个图片进行采样缩放。<br>通过BitmapFactory.options来缩放图片，主要是用到了他的inSampleSize参数，即采样率。当inSampleSize为1时，采用后的图片大小为图片原始大小，当inSampleSize大于1时，比如为2，那么采样后的图片的宽和高都是原来图片的1/2，而像素数为原图的1/4，其战友的内存大小也为原图的1/4。那一张1024<em>1024的图片来说，假定采用ARGB8888格式存储，那么他战友的内存为1024</em>1024<em>4 即4MB，如果inSampleSize为2，那么采样后的图片其占用的内存为 512</em>512<em>4 即1M。可以发现采用率inSampleSize必须是大于1的证书图片才会有缩小的效果，而且采样率同时作用于宽和高，这将导致缩放后的图片大小以采用率的2次方形式递减，即缩放比例为1/(inSampleSize的2次方)，比如inSampleSize为4，那么缩放比例就是1/16。有一种特殊的情况就是inSampleSize小于1时，其作用相当于1，即五缩放效果。另外最新的官方文档中之处，inSampleSize的取值应总为2的指数，比如 1、2、4、8、16…如果外界传递给系统的inSampleSize不是2的指数，那么系统会向下取整并选择一个最接近2的指数来代替，比如3，系统会选择2来替代。但是经过验证发现这个结论并不是在所有的Android版本上面都成立，因此把他当成一个建议就可以。<br>考虑到实际情况，比如ImageView的大小是100</em>100像素，而图片的原始大小为200<em>200，那么采样率inSampleSize设置为2就可以。但是如果图片大小是100</em>150呢？如果这个时候采样率还应该选择2，这样缩放后的图片为100*150，任然适合ImageView的，如果采样率为3，那么缩放后的图片会小于ImageView的大小，所以这样图片会被拉伸从而导致图片模糊。<br>通过采样率可以高效的加载图片，那么到底如何获取采样率呢？获取采样率也很简单，遵循如下流程：</p>
<ol>
<li>将BitmapFactory.Options的inJustDecodeBounds参数设置为true并加载图片</li>
<li>从BitmapFactory.Options获取图片原始宽高信息，他们对应于outWidth和outHeight参数。</li>
<li>根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize</li>
<li>将BitmapFactory.Options的inJustDecodeBounds参数设置为false并重新加载图片</li>
</ol>
<p>经过上面四个步骤，加载出的图片就是最终缩放后的图片，当然也有可能不需要缩放。这里说明一下inJustDecodeBounds参数，当此参数设置true时，BitmapFactory只会解析图片的原始宽高信息，并不会真正加载图片，所以这个操作是轻量级的。另外需要注意的是，这个时候BitmapFactory加载的图片宽高和图片的围着以及程序运行的设备有关，比如同一张图片放在不同的drawable目录下或者不同的屏幕密度的设备上，BitmapFactory会得到不同的结果，之所以会出现这个现象，这和Android的资源加载机制有关，这里不会深入的探讨这个问题，但是大家开发的时候已经用到了这个东西，就是不同的drawable。<br>将上面的四个流程用程序来实现，就产生了下面的代码：<br>这里使用的是mipmap下面的图片：</p>
<p>这里的图片是1920*1080的<br>首先我们不做任何处理，在不同的mipmap文件夹都放置这张图片</p>
<p><img src="meizi.jpg" alt="Alt text" title="原始图片"></p>
<p>布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;ImageView</span><br><span class="line">    android:id=&quot;@+id/iv&quot;</span><br><span class="line">    android:layout_width=&quot;100dp&quot;</span><br><span class="line">    android:layout_height=&quot;100dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ImageView iv = findViewById(R.id.iv);</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.meizi);</span><br><span class="line">        iv.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.meizi);</span><br><span class="line">iv.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure></p>
<p>这里讲上面的四个流程使用程序来实现，就产生了如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BitmapUtils &#123;</span><br><span class="line">    public  static Bitmap decodeSampleBitmapFromResorce(Resources res,int resId,int reqWidth,int reqHeight)&#123;</span><br><span class="line">        BitmapFactory.Options options=new BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds=true;</span><br><span class="line">        BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">        options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">        options.inJustDecodeBounds=false;</span><br><span class="line">        return  BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</span><br><span class="line">        final  int height=options.outHeight;</span><br><span class="line">        final  int width=options.outWidth;</span><br><span class="line">        int inSampleSize=1;</span><br><span class="line">        if(height&gt;reqHeight||width&gt;reqWidth)&#123;</span><br><span class="line">            final int halfHeight=height/2;</span><br><span class="line">            final  int halfWidth=width/2;</span><br><span class="line">            while((halfHeight/inSampleSize)&gt;=reqHeight&amp;&amp;(halfWidth/inSampleSize)&gt;=reqWidth)&#123;</span><br><span class="line">                inSampleSize*=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  inSampleSize;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了上面的两个方法，实际使用的时候就非常简单了，比如ImageView所期望的图片大小为100*100像素，这个时候就可以通过如下方式高效加载并显示图片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ImageView iv = findViewById(R.id.iv);</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = BitmapUtils.decodeSampleBitmapFromResorce(getResources(), R.mipmap.meizi, iv.getMeasuredWidth(), iv.getMeasuredHeight());</span><br><span class="line">        iv.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Android中缓存策略"><a href="#Android中缓存策略" class="headerlink" title="Android中缓存策略"></a>Android中缓存策略</h1><p>缓存策略在Android中有着广泛的使用场景，尤其在图片加载这个场景下，缓存策略就变得更加重要了。考虑一种使用场景：有一批网络图片，需要下载后再用户界面上予以显示，这个场景再PC环境下是很简单的，直接把所有的图片下载到本地再显示即可，但是放到移动设备上面就不一样。不管是Android还是Ios设备，流量对于用户来说都是一种宝贵的资源，由于流量是收费的，所以在应用开发中不能消耗用户的流量，否则这个应用肯定不能被用户所接受。因此必须提供一种解决方案来解决流量问题。<br>如何避免过多的使用流量呢？那就是本节索要讨论的主题：缓存啦。当程序第一次从网络上加载图片后，就将其缓存到设备上，这样下次使用这张图片就不用再从网络上获取，这样就节约了用户的流量，并且提高了图片的加载速度。这里说一下主流的缓存策略。<br>当加载一张图片时，先判断时候内存中时候存在这张图片，如果存在，就直接使用这张图片。如果内存不存在这张图片，就通过硬盘缓存来判断是否存在这张图片，如果存在就加载到内存中显示，如果不存在再从网络加载。这样就可以高效节约用户的流量了。<br>说道缓存策略，其实没有统一的标准，一般来说，缓存策略主要包含缓存的添加、获取和删除这三类操作。如何添加和获取缓存这个比较好理解，那么为什么还要删除缓存呢？这是因为不管是内存缓存还是存储缓存都是有容量大小限制的，因为内存和诸如SD卡之类的存储容量限制，因此在使用的时候就要制定缓存的最大容量。如果缓存满了，但是程序要继续添加缓存，这个时候就要按照一定的策略删除本地或者内存中的缓存。如何定义这种策略就对应不同的算法。例如根据时间来定义缓存的新旧，或者根据缓存访问的次数来定义新旧…每一种算法都有它的优点和缺点，要正确的使用。<br>目前常用的算法是LRU算法，就是近期最少使用算法，它的核心思想是当缓存满时，会优先淘汰那些最近最少使用的缓存对象。采用LRU算法的缓存有两种：LruCache和DiskLruCache，LruCache用于实现内存缓存，而DiskLruCache充当硬盘缓存，通过这两者完美的结合，就可以很方便的实现一个具有很高实用价值的ImageLoader。这里先介绍一下这两个的使用。</p>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>LruCache是Android3.1所提供的一个缓存类，通过support-v4兼容包可以兼容到早起的Android版本。<br>LruCache是一个泛型类，他内部采用一个LinkedHashMap以强引用的防治存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再讲新的缓存对象添加。这里要明白一个东西：强引用、弱引用和软引用的区别</p>
<ul>
<li>强引用：直接的对象引用</li>
<li>软引用：当一个对象只有软引用时，系统内存不足时此对象会被GC回收</li>
<li>弱引用：当一个对象只有弱引用时，此对象随时会被GC回收</li>
</ul>
<p>另外LruCache是线程安全的，下面是LruCache的定义。</p>
<p>LruCache的实现比较简单，我们可以看一下他的源码。<br>先来看一下LruCache的使用方法，之后在分析一下他的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int maxMemory= (int) (Runtime.getRuntime().maxMemory()/1024);</span><br><span class="line">int cacheSize=maxMemory/8;</span><br><span class="line">LruCache&lt;String,Bitmap&gt; mMemoryCache=new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">        return super.sizeOf(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，只需要提供缓存的总容量大小并重写sizeOf方法即可。sizeOf方法的作用是计算缓存对象的大小，这里大小的单位需要和总容量的单位一致。对于上面的示例代码来说，总容量的大小为当前进程的1/8，单位为kb，而sizeOf方法则完成了Bitmap对象的大小计算。很明显，之所以除以1024也是为了将其单位转换为kb。一些特殊情况下，还需要重写LruCache的entryRemoved方法，Lruchche移除旧缓存时会调用entryRemoved方法，因此可以在entryRemoved中完成一些资源回收的工作(如果需要的话)<br>除了LruCache的创建以外，还有缓存的获取和添加，这也很简单，从LruCache中获取一个缓存对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mMemoryCache.get(key)</span><br></pre></td></tr></table></figure>
<p>向LruCache中添加一个缓存对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mMemoryCache.put(key,bitmap)</span><br></pre></td></tr></table></figure></p>
<p>LruCache还支持删除操作，通过remove方法即可删除一个指定的缓存对象。可以看到LruCache的实现以及使用都非常简单，虽然很简单，但是任然不影响它具有强大的功能，从Android3.1开始，LruCache就是Android的一部分了。<br>既然LruCache这么强大，我来分析一下他的源码，吸收一下他的思想。</p>
<p>这里先从他的构造方法开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LruCache&lt;String,Bitmap&gt; mMemoryCache=new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">        return super.sizeOf(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">    public void resize(int maxSize) &#123;</span><br><span class="line">        super.resize(maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void trimToSize(int maxSize) &#123;</span><br><span class="line">        super.trimToSize(maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123;</span><br><span class="line">        super.entryRemoved(evicted, key, oldValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap create(String key) &#123;</span><br><span class="line">        return super.create(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们来看一下他做了什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">    if (maxSize &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxSize = maxSize;</span><br><span class="line">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现LruCache内部使用的是LinkedhashMap<br>然后要看一下他的put方法，看做了什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final V put(K key, V value) &#123;</span><br><span class="line">    if (key == null || value == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key == null || value == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous != null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现控制LruCache占用内存大小的方法是<code>safeSizeOf</code>和<code>trimToSize</code>方法<br>在添加的时候计算大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private int safeSizeOf(K key, V value) &#123;</span><br><span class="line">    int result = sizeOf(key, value);</span><br><span class="line">    if (result &lt; 0) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是LruCache默认的测量大小的方法，但是可以看到我们在创建LruCache对这个方法进行了重写，由于返回Bitmap的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int sizeOf(K key, V value) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就测量出来当前BitMap占用总内存大小<br>之后是调用<code>trimToSize</code>方法检测内存是否超出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize(int maxSize) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class="line">                throw new IllegalStateException(getClass().getName()</span><br><span class="line">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (size &lt;= maxSize) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            if (toEvict == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entryRemoved(true, key, value, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内存超出，就通过<code>eldest()</code>筛选要移除的key值。LinkedHashMap的eldest方法作用是移除最老的值。感兴趣的可以看一下他的源码。这里就不分析了。</p>
<p>这样就可以将超出内存的bitmap移除出内存。</p>
<p>下面看一下get方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public final V get(K key) &#123;</span><br><span class="line">      if (key == null) &#123;</span><br><span class="line">          throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      V mapValue;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          mapValue = map.get(key);</span><br><span class="line">          if (mapValue != null) &#123;</span><br><span class="line">              hitCount++;</span><br><span class="line">              return mapValue;</span><br><span class="line">          &#125;</span><br><span class="line">          missCount++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * Attempt to create a value. This may take a long time, and the map</span><br><span class="line">       * may be different when create() returns. If a conflicting value was</span><br><span class="line">       * added to the map while create() was working, we leave that value in</span><br><span class="line">       * the map and release the created value.</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      V createdValue = create(key);</span><br><span class="line">      if (createdValue == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          createCount++;</span><br><span class="line">          mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">          if (mapValue != null) &#123;</span><br><span class="line">              // There was a conflict so undo that last put</span><br><span class="line">              map.put(key, mapValue);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              size += safeSizeOf(key, createdValue);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (mapValue != null) &#123;</span><br><span class="line">          entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">          return mapValue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          trimToSize(maxSize);</span><br><span class="line">          return createdValue;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断key值对应的对象是否存在，如果不存在，就尝试创建一个对象，如果创建失败，就返回null。<br>这里注意一点，在创建LruCache时，可以重写一个create方法，这个方法就是当key对应的Value值为空时，会调用的创建方法，这个方法默认返回null。</p>
<p>看到这里就可以发现LruCache其实并没有那么复杂，只是对LinkedhashMap的一次包装。</p>
<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>DiskLruCache用于实现存储设备缓存，即磁盘缓存，他通过将缓存对象写入文件系统从而实现缓存的效果。DiskLruCache得到了Android官方文档的推荐，但是他不属于AndroidSDK的一部分<br>需要在Gradle中添加如下以来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.jakewharton:disklrucache:2.0.2&apos;</span><br></pre></td></tr></table></figure></p>
<p>这个是大神JakeWharton的开源项目。项目地址是：<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">https://github.com/JakeWharton/DiskLruCache</a> 膜拜一下JakeWharton大神。</p>
<h3 id="DiskLruCache的创建"><a href="#DiskLruCache的创建" class="headerlink" title="DiskLruCache的创建"></a>DiskLruCache的创建</h3><p>DiskLruCache并不能通过构造方法来创建，它提供了open方法用于创建自身，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>open方法有四个参数，其中第一个参数表示磁盘缓存的路径。缓存路径可以选择SD卡上的缓存目录，具体是指sdcard/Android/data/package_name/cache。当然也可以选择其他目录。如果希望卸载后就删除文件，可以选择缓存目录，如果希望卸载之后还存在，就选择其他目录。<br>第二个参数表示应用版本号，一般设定为1就可以。当版本号发生改变时，DiskLruCache会清空缓存，而这个特性在实际开发中作用并不大，很多情况下即使应用版本号发生改变缓存也不会失效。<br>第三个参数表示单个节点所对应的数据的个数，一般设定为1即可。<br>第四个参数表示缓存总大小，比如50m，当缓存超出这个设定值之后，DiskLruCache会清楚一些缓存从而保证总大小不大于这个设定值。下面是一个DiskLruCache经典的创建过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">     File bitmapFile= new File(getCacheDir(), &quot;bitmap&quot;);</span><br><span class="line">     if(!bitmapFile.exists())&#123;</span><br><span class="line">         bitmapFile.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line">     DiskLruCache diskLruCache = DiskLruCache.open(bitmapFile, 1, 1, 1024 * 1024 * 50);</span><br><span class="line"> &#125; catch (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="DiskLruCache的缓存添加"><a href="#DiskLruCache的缓存添加" class="headerlink" title="DiskLruCache的缓存添加"></a>DiskLruCache的缓存添加</h3><p>DiskLruCache的缓存添加操作是通过Editor完成的，Editor表示一个缓存对象的编辑对象。这里任然以图片缓存举例，首先需要获取图片url所对应的key，然后根据key就可以edit()来获取对象，如果这个缓存正在被编辑，那么edit会返回null，即DiskLruCache不允许同时编辑一个缓存对象。之所以要把url转换为key，是因为图片的url中可能有一些特殊字符，这将影响url在Android中直接使用，一般采取url的md5值作为key。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">private  String hashKeyFormUrl(String url)&#123;</span><br><span class="line">    String cacheKey;</span><br><span class="line">    try&#123;</span><br><span class="line">        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        md5.update(url.getBytes());</span><br><span class="line">        cacheKey=bytesToHexString(md5.digest());</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String bytesToHexString(byte[] digest) &#123;</span><br><span class="line">    StringBuilder sb=new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; digest.length; i++) &#123;</span><br><span class="line">        String hex=Integer.toHexString(0xFF&amp;digest[i]);</span><br><span class="line">        if(hex.length()==1)&#123;</span><br><span class="line">            sb.append(&apos;0&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return  sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图片的Url转换成key之后，就可以获取editor对象了。对于这个key来说，如果当前不存在其他Editor对象，那么<code>edit()</code>会返回一个新的Editor对象，通过他就可以得到一个文件输出流。需要注意的是，由于在前面的DiskLruCache方法<code>open</code>中设置了一个节点只能有一个数据，因此下面的DISK_CACHE_INDEX常量直接设置为0即可。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache.Editor edit = diskLruCache.edit(hashKeyFormUrl(url));</span><br><span class="line">       if(edit!=null)&#123;</span><br><span class="line">           OutputStream outputStream = edit.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>有了文件输出流，接下来怎么做呢》其实是这样的，当从网络下载图片时，图片就可以通过这个文件输出流写入到文件系统，可以看一下下面的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean downloadUrlToStream(String urlString, OutputStream outputStream) &#123;</span><br><span class="line"></span><br><span class="line">    HttpURLConnection urlConnection = null;</span><br><span class="line">    BufferedOutputStream out = null;</span><br><span class="line">    BufferedInputStream in = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final URL url = new URL(urlString);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        in = new BufferedInputStream(urlConnection.getInputStream(), IO_BUFFER_SIZE);</span><br><span class="line">        out = new BufferedOutputStream(outputStream, IO_BUFFER_SIZE);</span><br><span class="line">        int b;</span><br><span class="line">        while((b=in.read())!=-1)&#123;</span><br><span class="line">            out.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上边的步骤，其实并没有真正将图片写入文件系统，还必须通过Editor的<code>commit()</code>，感觉步骤和SP差不多。如果图片下载过程中发生异常，还可以通过Editor的<code>abort()</code>来回退整个操作，这个过程如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">           File bitmapFile = new File(getCacheDir(), &quot;bitmap&quot;);</span><br><span class="line">           if (!bitmapFile.exists()) &#123;</span><br><span class="line">               bitmapFile.mkdirs();</span><br><span class="line">           &#125;</span><br><span class="line">           DiskLruCache diskLruCache = DiskLruCache.open(bitmapFile, 1, 1, 1024 * 1024 * 50);</span><br><span class="line">           DiskLruCache.Editor edit = diskLruCache.edit(hashKeyFormUrl(url));</span><br><span class="line">           if (edit != null) &#123;</span><br><span class="line">               OutputStream outputStream = edit.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line">               if(downloadUrlToStream(url,outputStream))&#123;</span><br><span class="line">                   edit.commit();</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   edit.abort();</span><br><span class="line">               &#125;</span><br><span class="line">               diskLruCache.flush();</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>经过上面几个步骤，图片已经被正确的写入文件系统了，接下来图片获取的操作就不需要网络请求了。</p>
<h3 id="DiskLruCache的缓存查找"><a href="#DiskLruCache的缓存查找" class="headerlink" title="DiskLruCache的缓存查找"></a>DiskLruCache的缓存查找</h3><p>和缓存的添加过程类似，缓存查找过程也需要将url转换为key，然后通过DiskLruCache的get方法得到一个Snapshot对象，接着再通过Snapshot对象即可得到缓存的文件输入流，有了文件输入流，自然就可以得到Bitmap对象了。为了避免加载图片过程中导致OOM问题，一般不建议直接加载原始图片。在之前已经介绍了如何加载一张缩放后的图片，但是那种方式对FileInputStream的缩放存在问题。原因是FileInputStream是一种有序的文件流，而两次decodeStream调用影响了文件流的位置属性，导致了第二次decodeStream是得到的是null。为了解决这个问题，可以通过文件流来得到他所对应的文件描述符，，然后再通过BitmapFactory.decodeDileDescriptor方法来加载一张缩放后的图片，这个过程实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Bitmap bitmap1 = null;</span><br><span class="line">String key = hashKeyFormUrl(url);</span><br><span class="line">DiskLruCache.Snapshot snapshot = diskLruCache.get(key);</span><br><span class="line">if (snapshot != null) &#123;</span><br><span class="line">    FileInputStream fileInputStream = (FileInputStream) snapshot.getInputStream(DISK_CACHE_INDEX);</span><br><span class="line">    FileDescriptor fileDescriptor = fileInputStream.getFD();</span><br><span class="line">    bitmap1 = mImageResizer.decodeSampleBitmapFromRDescriptor(fileDescriptor, 100, 100);</span><br><span class="line">    if ( bitmap1 != null) &#123;</span><br><span class="line"></span><br><span class="line">     addBitmapToMemoryCache(key,bitmap1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面介绍了DiskLruCache的创建、缓存的添加和查找过程。<br>下面来看一下他的具体实现：</p>
<h3 id="DiskLruCache的具体实现"><a href="#DiskLruCache的具体实现" class="headerlink" title="DiskLruCache的具体实现"></a>DiskLruCache的具体实现</h3><p>这里重点看一下他的缓存策略<br>这里是一次写操作的调用，我们来分析一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache diskLruCache = DiskLruCache.open(bitmapFile, 1, 1, 1024 * 1024 * 50);</span><br><span class="line">      DiskLruCache.Editor edit = diskLruCache.edit(hashKeyFormUrl(url));</span><br><span class="line">      if (edit != null) &#123;</span><br><span class="line">          OutputStream outputStream = edit.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line">          if (downloadUrlToStream(url, outputStream)) &#123;</span><br><span class="line">              edit.commit();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              edit.abort();</span><br><span class="line">          &#125;</span><br><span class="line">          diskLruCache.flush();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个是<code>open</code>方法，这个是一定会调用的方法，看一下他做了哪些操作？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  if (maxSize &lt;= 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (valueCount &lt;= 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;valueCount &lt;= 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If a bkp file exists, use it instead.</span><br><span class="line">  File backupFile = new File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  if (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile = new File(directory, JOURNAL_FILE);</span><br><span class="line">    // If journal file also exists just delete backup file.</span><br><span class="line">    if (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prefer to pick up where we left off.</span><br><span class="line">  DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  if (cache.journalFile.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      cache.readJournal();</span><br><span class="line">      cache.processJournal();</span><br><span class="line">      cache.journalWriter = new BufferedWriter(</span><br><span class="line">          new OutputStreamWriter(new FileOutputStream(cache.journalFile, true), Util.US_ASCII));</span><br><span class="line">      return cache;</span><br><span class="line">    &#125; catch (IOException journalIsCorrupt) &#123;</span><br><span class="line">      System.out</span><br><span class="line">          .println(&quot;DiskLruCache &quot;</span><br><span class="line">              + directory</span><br><span class="line">              + &quot; is corrupt: &quot;</span><br><span class="line">              + journalIsCorrupt.getMessage()</span><br><span class="line">              + &quot;, removing&quot;);</span><br><span class="line">      cache.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Create a new empty cache.</span><br><span class="line">  directory.mkdirs();</span><br><span class="line">  cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  cache.rebuildJournal();</span><br><span class="line">  return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现<code>open()</code>方法的作用是创建DiskLruCache并且创建文件夹</p>
<p>然后是<code>edit</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Editor edit(String key) throws IOException &#123;</span><br><span class="line">  return edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再戳进去看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  validateKey(key);</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null</span><br><span class="line">      || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">    return null; // Snapshot is stale.</span><br><span class="line">  &#125;</span><br><span class="line">  if (entry == null) &#123;</span><br><span class="line">    entry = new Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125; else if (entry.currentEditor != null) &#123;</span><br><span class="line">    return null; // Another edit is in progress.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Editor editor = new Editor(entry);</span><br><span class="line">  entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">  // Flush the journal before creating files to prevent file leaks.</span><br><span class="line">  journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">  return editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>checkNotClosed();</code>检查是否调用了open方法<br><code>validateKey</code>检验key是否合法<br>然后是一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = lruEntries.get(key);</span><br></pre></td></tr></table></figure></p>
<p>看一下lruEntries是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final LinkedHashMap&lt;String, Entry&gt; lruEntries =</span><br><span class="line">    new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true);</span><br></pre></td></tr></table></figure></p>
<p>可以发现DiskLruCache底层也是调用了LinkedHashMap这个东西，应该是参照了LruCache的代码。DiskLruCache应该是对linkedHashMap的包装。<br>这里的Entry是DiskLruCache的内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final class Entry &#123;</span><br><span class="line">  private final String key;</span><br><span class="line"></span><br><span class="line">  /** Lengths of this entry&apos;s files. */</span><br><span class="line">  private final long[] lengths;</span><br><span class="line"></span><br><span class="line">  /** True if this entry has ever been published. */</span><br><span class="line">  private boolean readable;</span><br><span class="line"></span><br><span class="line">  /** The ongoing edit or null if this entry is not being edited. */</span><br><span class="line">  private Editor currentEditor;</span><br><span class="line"></span><br><span class="line">  /** The sequence number of the most recently committed edit to this entry. */</span><br><span class="line">  private long sequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现在entry中保存了文件的大小等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final String DIRTY = &quot;DIRTY&quot;;</span><br><span class="line">private Writer journalWriter;</span><br><span class="line"></span><br><span class="line">journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">journalWriter.flush();</span><br></pre></td></tr></table></figure>
<p>最后通过Writer写入了一段信息</p>
<p>第三个是<code>newOutputStream</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public OutputStream newOutputStream(int index) throws IOException &#123;</span><br><span class="line">     synchronized (DiskLruCache.this) &#123;</span><br><span class="line">       if (entry.currentEditor != this) &#123;</span><br><span class="line">         throw new IllegalStateException();</span><br><span class="line">       &#125;</span><br><span class="line">       if (!entry.readable) &#123;</span><br><span class="line">         written[index] = true;</span><br><span class="line">       &#125;</span><br><span class="line">       File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">       FileOutputStream outputStream;</span><br><span class="line">       try &#123;</span><br><span class="line">         outputStream = new FileOutputStream(dirtyFile);</span><br><span class="line">       &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">         // Attempt to recreate the cache directory.</span><br><span class="line">         directory.mkdirs();</span><br><span class="line">         try &#123;</span><br><span class="line">           outputStream = new FileOutputStream(dirtyFile);</span><br><span class="line">         &#125; catch (FileNotFoundException e2) &#123;</span><br><span class="line">           // We are unable to recover. Silently eat the writes.</span><br><span class="line">           return NULL_OUTPUT_STREAM;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return new FaultHidingOutputStream(outputStream);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现他创建了写入的文件流，文件路径是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public File getDirtyFile(int i) &#123;</span><br><span class="line">      return new File(directory, key + &quot;.&quot; + i + &quot;.tmp&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现写入的文件是一个tmp临时文件。</p>
<p>接着就是通过文件流写入文件到临时文件。<br>写入成功之后会调用commit</p>
<p>看一下commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void commit() throws IOException &#123;</span><br><span class="line">    if (hasErrors) &#123;</span><br><span class="line">      completeEdit(this, false);</span><br><span class="line">      remove(entry.key); // The previous entry is stale.</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      completeEdit(this, true);</span><br><span class="line">    &#125;</span><br><span class="line">    committed = true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里分析正常情况，会调用<code>completeEdit</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;</span><br><span class="line">  Entry entry = editor.entry;</span><br><span class="line">  if (entry.currentEditor != editor) &#123;</span><br><span class="line">    throw new IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If this edit is creating the entry for the first time, every index must have a value.</span><br><span class="line">  if (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">      if (!editor.written[i]) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File dirty = entry.getDirtyFile(i);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      if (dirty.exists()) &#123;</span><br><span class="line">        File clean = entry.getCleanFile(i);</span><br><span class="line">        dirty.renameTo(clean);</span><br><span class="line">        long oldLength = entry.lengths[i];</span><br><span class="line">        long newLength = clean.length();</span><br><span class="line">        entry.lengths[i] = newLength;</span><br><span class="line">        size = size - oldLength + newLength;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      deleteIfExists(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  entry.currentEditor = null;</span><br><span class="line">  if (entry.readable | success) &#123;</span><br><span class="line">    entry.readable = true;</span><br><span class="line">    journalWriter.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    lruEntries.remove(entry.key);</span><br><span class="line">    journalWriter.write(REMOVE + &apos; &apos; + entry.key + &apos;\n&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  journalWriter.flush();</span><br><span class="line"></span><br><span class="line">  if (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里valueCount是在<code>open</code>时传递进去的参数,值是1，这样for循环只会调用一次<br>由于已经知道<code>abort</code>方法是撤销一次写入，所以在正确的情况下，是不会走<code>abort</code>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public File getCleanFile(int i) &#123;</span><br><span class="line">  return new File(directory, key + &quot;.&quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里与之前获取的文件名称差了一个tmp，应该是正式文件的名称。这里发现对于同一个key如果有不同的文件，可以通过index来区分…<br>从上面的名字可以看出这个文件夹是干净的文件夹… 那么之前用的带有tmp文件夹名的应该是<code>getDirtyFile</code>脏文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">  File dirty = entry.getDirtyFile(i);</span><br><span class="line">  if (success) &#123;</span><br><span class="line">    if (dirty.exists()) &#123;</span><br><span class="line">      File clean = entry.getCleanFile(i);</span><br><span class="line">      dirty.renameTo(clean);</span><br><span class="line">      long oldLength = entry.lengths[i];</span><br><span class="line">      long newLength = clean.length();</span><br><span class="line">      entry.lengths[i] = newLength;</span><br><span class="line">      size = size - oldLength + newLength;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    deleteIfExists(dirty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个<code>renameTo</code>重命名的操作，把脏文件(带有tmp)转化为不带(tmp)</p>
<p>之后通过file的<code>length</code>方法得到文件大小，拓展size大小<br>最后会判断文件大小是否大于最大值，如果超过，会调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executorService.submit(cleanupCallable);</span><br></pre></td></tr></table></figure></p>
<p>executorService很明显是一个线程池，</p>
<p>看一下他的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ThreadPoolExecutor executorService =</span><br><span class="line">      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure></p>
<p>这是一个单线程线程池，核心线程为0，最大线程为1<br>接着看一下cleanupCallable中做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;Void&gt;() &#123;</span><br><span class="line">  public Void call() throws Exception &#123;</span><br><span class="line">    synchronized (DiskLruCache.this) &#123;</span><br><span class="line">      if (journalWriter == null) &#123;</span><br><span class="line">        return null; // Closed.</span><br><span class="line">      &#125;</span><br><span class="line">      trimToSize();</span><br><span class="line">      if (journalRebuildRequired()) &#123;</span><br><span class="line">        rebuildJournal();</span><br><span class="line">        redundantOpCount = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>trimToSize</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void trimToSize() throws IOException &#123;</span><br><span class="line">  while (size &gt; maxSize) &#123;</span><br><span class="line">    Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();</span><br><span class="line">    remove(toEvict.getKey());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里得到key并移除文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean remove(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   validateKey(key);</span><br><span class="line">   Entry entry = lruEntries.get(key);</span><br><span class="line">   if (entry == null || entry.currentEditor != null) &#123;</span><br><span class="line">     return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">     File file = entry.getCleanFile(i);</span><br><span class="line">     if (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">       throw new IOException(&quot;failed to delete &quot; + file);</span><br><span class="line">     &#125;</span><br><span class="line">     size -= entry.lengths[i];</span><br><span class="line">     entry.lengths[i] = 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(REMOVE + &apos; &apos; + key + &apos;\n&apos;);</span><br><span class="line">   lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是<code>flush</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void flush() throws IOException &#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  trimToSize();</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里进行二次确认并flush<br>到这里添加操作就完成了。</p>
<p>下面看一下读取的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> DiskLruCache.Snapshot snapshot = diskLruCache.get(key);</span><br><span class="line">FileInputStream fileInputStream = (FileInputStream) snapshot.getInputStream(DISK_CACHE_INDEX);</span><br></pre></td></tr></table></figure>
<p>这个比较简单，通过key获取Snapshot，而Snapshot是inputstream的一层包装，接着读取文件。</p>
<h1 id="ImageLoader的实现"><a href="#ImageLoader的实现" class="headerlink" title="ImageLoader的实现"></a>ImageLoader的实现</h1><p>前面介绍了BitMap高效加载方式，LruCache和DiskLruCache，现在我们来实现一个优秀的ImageLoader。<br>一般来说，一个优秀的ImageLoader应该是具备如下功能：</p>
<ul>
<li>图片的同步加载：</li>
<li>图片的异步加载：</li>
<li>图片压缩：</li>
<li>内存缓存</li>
<li>磁盘缓存：</li>
<li>网络拉取：</li>
</ul>
<p>图片的同步加载时指能够以同步的方式向调用者提供加载的图片，这个图片可能是从内存缓存中读取，也可能从硬盘缓存中读取，还可能从网络拉取的。图片的异步加载时一个很有用的功能，很多时候调用者不想在单独的线程中以同步的方式来获取图片，这个时候ImageLoader内部需要自己在线程中加载图片并将图片设置给所需要的ImageView。图片压缩是降低OOM的有效手段。<br>除此之外，ImageLoader还需要处理一些特殊的情况，比如在ListView或者GridView中，View复用既是他们的优点，也是缺点。比较明显的就是图片的错位问题，ImageLoader需要正确的处理这种情况。<br>上面对ImageLoad的功能做了一个全面的分析，下面就可以一步步的实现一个ImageLoad了，主要步骤如下。</p>
<h2 id="图片压缩功能的实现"><a href="#图片压缩功能的实现" class="headerlink" title="图片压缩功能的实现"></a>图片压缩功能的实现</h2><p>这个之前已经做了介绍，这里就不多说了，上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ImageResizer &#123;</span><br><span class="line">    private  static  final  String TAG=&quot;ImageResizer&quot;;</span><br><span class="line">    public  ImageResizer()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Bitmap decodeSampledBitmapFromFileDescriptor(FileDescriptor fd , int reqWidth, int reqHeight)&#123;</span><br><span class="line"></span><br><span class="line">        BitmapFactory.Options options=new BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds=true;</span><br><span class="line">        BitmapFactory.decodeFileDescriptor(fd,null,options);</span><br><span class="line">        options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">        options.inJustDecodeBounds=false;</span><br><span class="line">        return  BitmapFactory.decodeFileDescriptor(fd,null,options);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public Bitmap decodeSampledBitmapFromResource(Resources res,int resId,int reqWidth,int reqHeight)&#123;</span><br><span class="line"></span><br><span class="line">        BitmapFactory.Options options=new BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds=true;</span><br><span class="line">        BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">        options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">        options.inJustDecodeBounds=false;</span><br><span class="line">        return  BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</span><br><span class="line">        final  int height=options.outHeight;</span><br><span class="line">        final  int width=options.outWidth;</span><br><span class="line">        int inSampleSize=1;</span><br><span class="line">        if(height&gt;reqHeight||width&gt;reqWidth)&#123;</span><br><span class="line">            final int halfHeight=height/2;</span><br><span class="line">            final  int halfWidth=width/2;</span><br><span class="line">            while((halfHeight/inSampleSize)&gt;=reqHeight&amp;&amp;(halfWidth/inSampleSize)&gt;=reqWidth)&#123;</span><br><span class="line">                inSampleSize*=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  inSampleSize;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存缓存和磁盘缓存的实现"><a href="#内存缓存和磁盘缓存的实现" class="headerlink" title="内存缓存和磁盘缓存的实现"></a>内存缓存和磁盘缓存的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private ImageLoader(Context mContext) &#123;</span><br><span class="line">    this.mContext = mContext.getApplicationContext();</span><br><span class="line">    int maxMemory= (int) (Runtime.getRuntime().maxMemory()/1024);</span><br><span class="line">    int cacheSize=maxMemory/8;</span><br><span class="line">    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">            return value.getRowBytes()*value.getHeight()/1024;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    File diskCacheDir=getDiskCacheDir(mContext,&quot;bitmap&quot;);</span><br><span class="line">    if(!diskCacheDir.exists())&#123;</span><br><span class="line">        diskCacheDir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(getUsableSpace(diskCacheDir)&gt;DISK_CACHE_SIZE)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置硬盘缓存为250M<br>硬盘缓存和内存缓存创建完毕之后，需要提供<code>get</code>和<code>set</code>方法</p>
<p>先看一下内存缓存的<code>get</code>和<code>set</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private  void addBitmapToMemoryCache(String key,Bitmap bitmap)&#123;</span><br><span class="line">    if(getBitmapFromMemCache(key)==null)&#123;</span><br><span class="line">        mMemoryCache.put(key,bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private  Bitmap getBitmapFromMemCache(String key)&#123;</span><br><span class="line">    return mMemoryCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而硬盘缓存的添加和读取功能稍微复杂一些，具体内容在之前已经介绍了，这里给出代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap loadBitmapFromHttp(String url, int reqWidth, int reqHeight) throws IOException &#123;</span><br><span class="line">    if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;can not visit network from UI Thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(mDiskLruCache==null)&#123;</span><br><span class="line">        return  null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String key=hashKeyFormUrl(url);</span><br><span class="line">    DiskLruCache.Editor edit = mDiskLruCache.edit(key);</span><br><span class="line">    if(edit!=null)&#123;</span><br><span class="line">        OutputStream outputStream=edit.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line">        if(downloadUrlToStream(url,outputStream))&#123;</span><br><span class="line">            edit.commit();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            edit.abort();</span><br><span class="line">        &#125;</span><br><span class="line">        mDiskLruCache.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    return  loadBitmapFromDiskCache(url,reqWidth,reqHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Bitmap loadBitmapFromDiskCache(String url, int reqWidth, int reqHeight) throws IOException &#123;</span><br><span class="line">    if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;load bitmap from UI Thread, it&apos;s not recommended!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(mDiskLruCache==null)&#123;</span><br><span class="line">        return  null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bitmap bitmap=null;</span><br><span class="line">    String key=hashKeyFormUrl(url);</span><br><span class="line">    DiskLruCache.Snapshot snapshot=mDiskLruCache.get(key);</span><br><span class="line">    if(snapshot!=null)&#123;</span><br><span class="line">        FileInputStream fileInputStream= (FileInputStream) snapshot.getInputStream(DISK_CACHE_INDEX);</span><br><span class="line">        FileDescriptor fd = fileInputStream.getFD();</span><br><span class="line">        bitmap=   mImageResizer.decodeSampledBitmapFromFileDescriptor(fd,reqWidth,reqHeight);</span><br><span class="line">        if(bitmap!=null)&#123;</span><br><span class="line">            addBitmapToMemoryCache(key,bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return  bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步加载和异步加载接口设计"><a href="#同步加载和异步加载接口设计" class="headerlink" title="同步加载和异步加载接口设计"></a>同步加载和异步加载接口设计</h2><p>首先看同步加载，同步加载接口需要外部在线程中调用，这是因为同步加载可能比较耗时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public Bitmap loadBitmap(String url, int reqWidth, int reqHeight) &#123;</span><br><span class="line">    Bitmap bitmap = loadBitmapFromMemCache(url);</span><br><span class="line">    if (bitmap != null) &#123;</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        loadBitmapFromDiskCache(url, reqWidth, reqHeight);</span><br><span class="line">        if (bitmap != null) &#123;</span><br><span class="line">            return bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap = loadBitmapFromHttp(url, reqWidth, reqHeight);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    if(bitmap==null&amp;&amp;!mIsDiskLruCacheCreated)&#123;</span><br><span class="line">        bitmap=downloadUrlFromUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现优先级是 内存缓存&gt;硬盘缓存&gt;网络缓存<br>下面看一下异步接口设计，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void bindBitmap(String uri, final ImageView imageView, int reqWidth, int reqHeight) &#123;</span><br><span class="line"></span><br><span class="line">    imageView.setTag(TAG_KEY_URI,uri);</span><br><span class="line">    final Bitmap bitmap=loadBitmapFromMemCache(uri);</span><br><span class="line">    if(bitmap!=null)&#123;</span><br><span class="line">        imageView.setImageBitmap(bitmap);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Runnable loadBitmapTask=new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            LoaderResult result=new LoaderResult(imageView,uri,bitmap);</span><br><span class="line">            mMainhandler.obtainMessage(MESSAGE_POST_RESULT,result);</span><br><span class="line">            sendtoTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从bindBitmap的实现来看，bindBitmap方法会尝试从内存缓存中读取图片，如果读取成功就直接返回结果，否则会在线程池中去调用loadBitmap方法，当图片加载成功后，将图片，图片地址以及需要绑定的imageView封装成一个LoaderResult对象，然后再通过mMainHandler向主线程发送一个消息，这样就可以在主线程中给imageView设置图片了，之所以用handler来中转，是因为子线程无法访问UI。<br>bindBitmap中用到了线程池和Handler，这里可以看一下他们的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">private static final int CORE_POOL_SIZE = CPU_COUNT + 1;</span><br><span class="line"></span><br><span class="line">private static final int MAXIMUM_POOL_SIZE = 2 * CPU_COUNT + 1;</span><br><span class="line"></span><br><span class="line">private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;</span><br><span class="line">    private final AtomicInteger mCount = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(@NonNull Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;ImageLoader#&quot; + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(), sThreadFactory);</span><br></pre></td></tr></table></figure>
<p>这里采用线程池来进行异步加载。这个就不用说了。不了解的话可以看一下之前的章节。<br>现在来看一下mMainHandler做了哪些操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Handler mMainhandler = new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        LoaderResult result = (LoaderResult) msg.obj;</span><br><span class="line">        ImageView imageView = result.imageView;</span><br><span class="line">        imageView.setImageBitmap(result.bitmap);</span><br><span class="line">        String uri = (String) imageView.getTag(TAG_KEY_URI);</span><br><span class="line">        if (uri.equals(result.uri)) &#123;</span><br><span class="line">            imageView.setImageBitmap(result.bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里分析完毕，下面是全部的代码<br>首先是ImageLoader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">public class ImageLoader &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;ImageLoader&quot;;</span><br><span class="line"></span><br><span class="line">    public static final int MESSAGE_POST_RESULT = 1;</span><br><span class="line"></span><br><span class="line">    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    private static final int CORE_POOL_SIZE = CPU_COUNT + 1;</span><br><span class="line"></span><br><span class="line">    private static final int MAXIMUM_POOL_SIZE = 2 * CPU_COUNT + 1;</span><br><span class="line"></span><br><span class="line">    private static final long KEEP_ALIVE = 10L;</span><br><span class="line"></span><br><span class="line">    private static final int TAG_KEY_URI = 2;</span><br><span class="line"></span><br><span class="line">    private static final long DISK_CACHE_SIZE = 1024 * 1024 * 250;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final int IO_BUFFER_SIZE = 8 * 1024;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final int DISK_CACHE_INDEX = 0;</span><br><span class="line"></span><br><span class="line">    private boolean mIsDiskLruCacheCreated = false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;</span><br><span class="line">        private final AtomicInteger mCount = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Thread newThread(@NonNull Runnable r) &#123;</span><br><span class="line">            return new Thread(r, &quot;ImageLoader#&quot; + mCount.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(), sThreadFactory);</span><br><span class="line"></span><br><span class="line">    private Handler mMainhandler = new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            LoaderResult result = (LoaderResult) msg.obj;</span><br><span class="line">            ImageView imageView = result.imageView;</span><br><span class="line">            imageView.setImageBitmap(result.bitmap);</span><br><span class="line">            String uri = (String) imageView.getTag(TAG_KEY_URI);</span><br><span class="line">            if (uri.equals(result.uri)) &#123;</span><br><span class="line">                imageView.setImageBitmap(result.bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    private ImageResizer mImageResizer = new ImageResizer();</span><br><span class="line">    private final LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line">    private DiskLruCache mDiskLruCache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private ImageLoader(Context mContext) &#123;</span><br><span class="line">        this.mContext = mContext.getApplicationContext();</span><br><span class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</span><br><span class="line">        int cacheSize = maxMemory / 8;</span><br><span class="line">        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">                return value.getRowBytes() * value.getHeight() / 1024;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        File diskCacheDir = getDiskCacheDir(mContext, &quot;bitmap&quot;);</span><br><span class="line">        if (!diskCacheDir.exists()) &#123;</span><br><span class="line">            diskCacheDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (getUsableSpace(diskCacheDir) &gt; DISK_CACHE_SIZE) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mDiskLruCache = DiskLruCache.open(diskCacheDir, 1, 1, DISK_CACHE_SIZE);</span><br><span class="line">                mIsDiskLruCacheCreated = true;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static ImageLoader build(Context context) &#123;</span><br><span class="line">        return new ImageLoader(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">        if (getBitmapFromMemCache(key) == null) &#123;</span><br><span class="line">            mMemoryCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Bitmap getBitmapFromMemCache(String key) &#123;</span><br><span class="line">        return mMemoryCache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void bindBitmap(final String uri, final ImageView imageView, int reqWidth, int reqHeight) &#123;</span><br><span class="line"></span><br><span class="line">        imageView.setTag(TAG_KEY_URI, uri);</span><br><span class="line">        final Bitmap bitmap = loadBitmapFromMemCache(uri);</span><br><span class="line">        if (bitmap != null) &#123;</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Runnable loadBitmapTask = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LoaderResult result = new LoaderResult(imageView, uri, bitmap);</span><br><span class="line">                mMainhandler.obtainMessage(MESSAGE_POST_RESULT, result).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        THREAD_POOL_EXECUTOR.execute(loadBitmapTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Bitmap loadBitmap(String url, int reqWidth, int reqHeight) &#123;</span><br><span class="line">        Bitmap bitmap = loadBitmapFromMemCache(url);</span><br><span class="line">        if (bitmap != null) &#123;</span><br><span class="line">            return bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            loadBitmapFromDiskCache(url, reqWidth, reqHeight);</span><br><span class="line">            if (bitmap != null) &#123;</span><br><span class="line">                return bitmap;</span><br><span class="line">            &#125;</span><br><span class="line">            bitmap = loadBitmapFromHttp(url, reqWidth, reqHeight);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap == null &amp;&amp; !mIsDiskLruCacheCreated) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                bitmap = downloadUrlFromUrl(url);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Bitmap loadBitmapFromMemCache(String url) &#123;</span><br><span class="line">        final String key = hashKeyFormUrl(url);</span><br><span class="line">        Bitmap bitmap = getBitmapFromMemCache(key);</span><br><span class="line"></span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Bitmap loadBitmapFromHttp(String url, int reqWidth, int reqHeight) throws IOException &#123;</span><br><span class="line">        if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;can not visit network from UI Thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mDiskLruCache == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String key = hashKeyFormUrl(url);</span><br><span class="line">        DiskLruCache.Editor edit = mDiskLruCache.edit(key);</span><br><span class="line">        if (edit != null) &#123;</span><br><span class="line">            OutputStream outputStream = edit.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line">            if (downloadUrlToStream(url, outputStream)) &#123;</span><br><span class="line">                edit.commit();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                edit.abort();</span><br><span class="line">            &#125;</span><br><span class="line">            mDiskLruCache.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        return loadBitmapFromDiskCache(url, reqWidth, reqHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Bitmap loadBitmapFromDiskCache(String url, int reqWidth, int reqHeight) throws IOException &#123;</span><br><span class="line">        if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;load bitmap from UI Thread, it&apos;s not recommended!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mDiskLruCache == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line">        String key = hashKeyFormUrl(url);</span><br><span class="line">        DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);</span><br><span class="line">        if (snapshot != null) &#123;</span><br><span class="line">            FileInputStream fileInputStream = (FileInputStream) snapshot.getInputStream(DISK_CACHE_INDEX);</span><br><span class="line">            FileDescriptor fd = fileInputStream.getFD();</span><br><span class="line">            bitmap = mImageResizer.decodeSampledBitmapFromFileDescriptor(fd, reqWidth, reqHeight);</span><br><span class="line">            if (bitmap != null) &#123;</span><br><span class="line">                addBitmapToMemoryCache(key, bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean downloadUrlToStream(String urlString, OutputStream outputStream) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        HttpURLConnection urlConnection = null;</span><br><span class="line">        BufferedOutputStream out = null;</span><br><span class="line">        BufferedInputStream in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            final URL url = new URL(urlString);</span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            in = new BufferedInputStream(urlConnection.getInputStream(), IO_BUFFER_SIZE);</span><br><span class="line">            out = new BufferedOutputStream(outputStream, IO_BUFFER_SIZE);</span><br><span class="line">            int b;</span><br><span class="line">            while ((b = in.read()) != -1) &#123;</span><br><span class="line">                out.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (urlConnection != null) &#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Bitmap downloadUrlFromUrl(String urlString) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line">        HttpURLConnection urlConnection = null;</span><br><span class="line">        BufferedInputStream in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            final URL url = new URL(urlString);</span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            in = new BufferedInputStream(urlConnection.getInputStream(), IO_BUFFER_SIZE);</span><br><span class="line">            bitmap = BitmapFactory.decodeStream(in);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (urlConnection != null) &#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String hashKeyFormUrl(String url) &#123;</span><br><span class="line">        String cacheKey = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">            md5.update(url.getBytes());</span><br><span class="line">            cacheKey = bytesToHexString(md5.digest());</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            cacheKey = String.valueOf(url.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        return cacheKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String bytesToHexString(byte[] digest) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; digest.length; i++) &#123;</span><br><span class="line">            String hex = Integer.toHexString(0xFF &amp; digest[i]);</span><br><span class="line">            if (hex.length() == 1) &#123;</span><br><span class="line">                sb.append(&apos;0&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(&apos;0&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private File getDiskCacheDir(Context mContext, String bitmap) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        boolean externalStorageAvailable = Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);</span><br><span class="line">        final String cachePath;</span><br><span class="line">        if (externalStorageAvailable) &#123;</span><br><span class="line">            cachePath = mContext.getExternalCacheDir().getPath();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cachePath = mContext.getCacheDir().getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        return new File(cachePath + File.separator + bitmap);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getUsableSpace(File diskCacheDir) &#123;</span><br><span class="line">        return diskCacheDir.getUsableSpace();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private class LoaderResult &#123;</span><br><span class="line"></span><br><span class="line">        public LoaderResult(ImageView imageView, String uri, Bitmap bitmap) &#123;</span><br><span class="line">            this.imageView = imageView;</span><br><span class="line">            this.uri = uri;</span><br><span class="line">            this.bitmap = bitmap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageView imageView;</span><br><span class="line">        String uri;</span><br><span class="line">        Bitmap bitmap;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是ImageResizer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class ImageResizer &#123;</span><br><span class="line">    private  static  final  String TAG=&quot;ImageResizer&quot;;</span><br><span class="line">    public  ImageResizer()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Bitmap decodeSampledBitmapFromFileDescriptor(FileDescriptor fd , int reqWidth, int reqHeight)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BitmapFactory.Options options=new BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds=true;</span><br><span class="line">        BitmapFactory.decodeFileDescriptor(fd,null,options);</span><br><span class="line">        options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">        options.inJustDecodeBounds=false;</span><br><span class="line">        return  BitmapFactory.decodeFileDescriptor(fd,null,options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Bitmap decodeSampledBitmapFromResource(Resources res,int resId,int reqWidth,int reqHeight)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BitmapFactory.Options options=new BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds=true;</span><br><span class="line">        BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">        options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">        options.inJustDecodeBounds=false;</span><br><span class="line">        return  BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</span><br><span class="line">        final  int height=options.outHeight;</span><br><span class="line">        final  int width=options.outWidth;</span><br><span class="line">        int inSampleSize=1;</span><br><span class="line">        if(height&gt;reqHeight||width&gt;reqWidth)&#123;</span><br><span class="line">            final int halfHeight=height/2;</span><br><span class="line">            final  int halfWidth=width/2;</span><br><span class="line">            while((halfHeight/inSampleSize)&gt;=reqHeight&amp;&amp;(halfWidth/inSampleSize)&gt;=reqWidth)&#123;</span><br><span class="line">                inSampleSize*=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  inSampleSize;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="列表滑动卡顿的问题"><a href="#列表滑动卡顿的问题" class="headerlink" title="列表滑动卡顿的问题"></a>列表滑动卡顿的问题</h1><p>很简单，在滑动的时候不加载就可以了</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/进阶/" rel="tag"># 进阶</a>
          
            <a href="/tags/Android开发艺术探索/" rel="tag"># Android开发艺术探索</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/android/Android开发艺术探索导读/" rel="next" title="Android开发艺术探索导读">
                <i class="fa fa-chevron-left"></i> Android开发艺术探索导读
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android/Android开发艺术探索_第一章 Activity的生命周期和启动模式/" rel="prev" title="Android开发艺术探索 第一章 Activity的生命周期和启动模式">
                Android开发艺术探索 第一章 Activity的生命周期和启动模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Groot</p>
              <p class="site-description motion-element" itemprop="description">尽信书则不如无书</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Bitmap的高效加载"><span class="nav-number">1.</span> <span class="nav-text">Bitmap的高效加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android中缓存策略"><span class="nav-number">2.</span> <span class="nav-text">Android中缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LruCache"><span class="nav-number">2.1.</span> <span class="nav-text">LruCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DiskLruCache"><span class="nav-number">2.2.</span> <span class="nav-text">DiskLruCache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DiskLruCache的创建"><span class="nav-number">2.2.1.</span> <span class="nav-text">DiskLruCache的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DiskLruCache的缓存添加"><span class="nav-number">2.2.2.</span> <span class="nav-text">DiskLruCache的缓存添加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DiskLruCache的缓存查找"><span class="nav-number">2.2.3.</span> <span class="nav-text">DiskLruCache的缓存查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DiskLruCache的具体实现"><span class="nav-number">2.2.4.</span> <span class="nav-text">DiskLruCache的具体实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ImageLoader的实现"><span class="nav-number">3.</span> <span class="nav-text">ImageLoader的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图片压缩功能的实现"><span class="nav-number">3.1.</span> <span class="nav-text">图片压缩功能的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存缓存和磁盘缓存的实现"><span class="nav-number">3.2.</span> <span class="nav-text">内存缓存和磁盘缓存的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步加载和异步加载接口设计"><span class="nav-number">3.3.</span> <span class="nav-text">同步加载和异步加载接口设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#列表滑动卡顿的问题"><span class="nav-number">4.</span> <span class="nav-text">列表滑动卡顿的问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Groot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
