<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="进阶,Android开发艺术探索," />










<meta name="description" content="这一章讲述一下四大组件的工作过程,说到四大组件，开发者都再熟悉不过了，他们是Activity、Service、BroadcastReceiver、ContentProvide。如何使用四大组件这个不是本章的话题，这个都是基础的内容。这里按照如下逻辑来分析Android的四大组件：首先对四大组件的运行状态和工作方式做一个概括化的描述，接着对四大组件的工作过程进行分析，通过本章节对四大组件有一个更加">
<meta name="keywords" content="进阶,Android开发艺术探索">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索 第九章 四大组件的工作流程">
<meta property="og:url" content="http://yoursite.com/android/Android开发艺术探索_第九章 四大组件的工作流程/index.html">
<meta property="og:site_name" content="个人网站">
<meta property="og:description" content="这一章讲述一下四大组件的工作过程,说到四大组件，开发者都再熟悉不过了，他们是Activity、Service、BroadcastReceiver、ContentProvide。如何使用四大组件这个不是本章的话题，这个都是基础的内容。这里按照如下逻辑来分析Android的四大组件：首先对四大组件的运行状态和工作方式做一个概括化的描述，接着对四大组件的工作过程进行分析，通过本章节对四大组件有一个更加">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第九章%20四大组件的工作流程/activity工作流程.svg">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第九章%20四大组件的工作流程/service启动流程图.svg">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第九章%20四大组件的工作流程/Service绑定流程图.svg">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第九章%20四大组件的工作流程/startContentProvide.png">
<meta property="og:updated_time" content="2018-07-26T13:02:16.539Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索 第九章 四大组件的工作流程">
<meta name="twitter:description" content="这一章讲述一下四大组件的工作过程,说到四大组件，开发者都再熟悉不过了，他们是Activity、Service、BroadcastReceiver、ContentProvide。如何使用四大组件这个不是本章的话题，这个都是基础的内容。这里按照如下逻辑来分析Android的四大组件：首先对四大组件的运行状态和工作方式做一个概括化的描述，接着对四大组件的工作过程进行分析，通过本章节对四大组件有一个更加">
<meta name="twitter:image" content="http://yoursite.com/android/Android开发艺术探索_第九章%20四大组件的工作流程/activity工作流程.svg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/android/Android开发艺术探索_第九章 四大组件的工作流程/"/>





  <title>Android开发艺术探索 第九章 四大组件的工作流程 | 个人网站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人网站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/android/Android开发艺术探索_第九章 四大组件的工作流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Groot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人网站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索 第九章 四大组件的工作流程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T17:08:30+08:00">
                2018-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>这一章讲述一下四大组件的工作过程,说到四大组件，开发者都再熟悉不过了，他们是Activity、Service、BroadcastReceiver、ContentProvide。如何使用四大组件这个不是本章的话题，这个都是基础的内容。这里按照如下逻辑来分析Android的四大组件：首先对四大组件的运行状态和工作方式做一个概括化的描述，接着对四大组件的工作过程进行分析，通过本章节对四大组件有一个更加深刻的认识。<br>本章主要侧重于四大组件工作过程的分析，通过分析他们的工作过程我们可以更好的理解系统的运行机制。本章的意义在于加深读者对四大组件的工作方式的认识。本章的意义在于加深读者对四大组件工作方式的认识，由于四大组件的特殊性，我们有必要对他有一定的了解。</p>
</blockquote>
<h1 id="四大组件的运行状态"><a href="#四大组件的运行状态" class="headerlink" title="四大组件的运行状态"></a>四大组件的运行状态</h1><p>Android四大组件中处理BroadcaskReceiver意外，其他三种组件必须都在ANdroidManifest中注册，对于BroadcastReceiver来说，他既可以在AndroidManifest中注册，也可以使用代码来注册。在调用方式上，Activity、Service、BroadcastReceiver需要借助Intent，而ContentProvide不需要借助Intent</p>
<p>Activity是一种展示型的组件，用于向用户直接展示一个界面，并且可以接受用户的输入信息从而进行交互。Activity是最重要的一种组件，对用户来说Activity就是一个Android应用的全部，这是因为其他三大组件对用户来说都是不可感知的。Activity的启动由Intent触发，其中Intent可以分为显示Intent和隐式Intent，显示Intent可以明确指向一个Activity组件，隐式Intent则指向一个或者多个目标Activity组件，当然也可能没有任何一个Activity组件可以处理这个Intent。一个Activity组件可以具有特定的启动模式。关于启动模式在之前已经做了介绍了，同一个Activity组件在不同的启动模式下会有不同的效果。Activity组件也是可以停止的，在实际开发中可以通过Activity的finish方法来结束一个Activity组件的运行。由此看来，Activity组件的主要作用是展示一个界面并和用户交互，他扮演的是一种前台界面的角色。</p>
<p>Service是一种计算型组件，用于在后台执行一系列计算任务。由于Service组件工作在后台，因此用户无法直接感知到他的存在。Service组件和Activity组件略有不同，Activity组件只有一种运行模式，即Activity处于启动装填，但是Service组件却又两种状态：启动状态和绑定状态。当Service组件处于启动状态时，这个时候Service内部可以做一些后台计算，并不需要和外界有直接的交互。尽管Service组件是用于执行后台计算的，但是它本身是运行在主线程中的，因此耗时操作需要在独立的线程中执行，也可以使用IntentService，这个默认是在新建的线程中执行。当Service组件处于绑定状态时，这个时候Service内部同样可以进行后台计算，但是处于这种状态是，外界可以很方便的和Service组件进行通信。Service组件也可以停止的，停止一个Service组件比较复杂，需要灵活使用stopService和unBindService这两个方法才能完全停止一个Service组件。</p>
<p>BroadcastReceiver是一种消息性组件，用于在不同的组件乃至不同的应用之间传递消息。BroadcastReceiver同样无法被用户直接感知，因为他工作在系统内部。BroadcastReceiver也叫广播，广播的注册有两种方式：静态注册和动态注册。静态注册时指在AndroidManifest中注册管你胳膊，这种广播在应用安装的时候会被系统解析，因此这种形式的广播不需要启动就可以收到广播。动态注册广播需要通过Context.registerReceiver()来实现，并且不需要的时候可以通过Context.unregisterReceiver()来解除广播，此种形态的广播必须要应用启动之后才能注册并接受广播，应为应用不启动就无法注册广播，无法注册广播就无法收到相应的广播。在开发中通过Context的一系列send方法来发送广播，被发送的广播会被系统发送给该兴趣的接受者，发送和接受过程的匹配是通过<intent-filter>来描述的。可以发现，BroadcastReceiver组件可以通过实现低耦合的观察者模式，观察者和接受者没有任何耦合。由于BroadcastReceiver的特性，他不适合用来执行耗时操作。BroadcastReceiver一般来说不需要停止，动态注册的要及时解开注册</intent-filter></p>
<p>ContentProvider是一种共享性组件，用于向其他组件内置其他应用共享数据。和BroadcastReceiver一样，ContentProvider无法被用户感知。对于一个ContentProvider组件来说，他的内部需要实现增删改查这四种操作，在他的内部维持着一份数据集合，这个数据集合既可以通过数据库来实现，可以通过其他任意类型来实现，比如List和Map。ContentProvider对数据集合的具体实现方式没有任何要求。需要注意的是ContentProvider内部的insert、delete。update和query方法需要处理好线程同步，因此这几个方法在Binder线程池汇总被调用，另外ContentProvider组件也不需要手动停止。</p>
<h1 id="Activity的工作流程"><a href="#Activity的工作流程" class="headerlink" title="Activity的工作流程"></a>Activity的工作流程</h1><p>本节讲述的内容是Activity的工作过程。为了方便日常的开发工作，系统对四大组件的工作过程进行了很大程度上的封装，这使得开发者无需关注实现细节就可以快速的使用四大组件。Activity作为很重要的一个组件，其内部工作过程当然是做了很多的封装，这种封装是的启动一个Activity变得异常简单。在显示调用形式下，只需要调用如下代码就可以完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent =new Intent(this,Main2Activity.class);</span><br><span class="line"> startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>通过上面的代码即可启动一个具体的Activity，然后新Activity就会被系统启动并展示在用户的眼前。这个过程对于Android开发者来说在普通不过了，但是有没有想过系统内部是如何启动一个Activity的呢？比如新Activity是在什么时候创建？Activity的onCreate方法又是在什么时候被系统回调的呢？这里就是普通开发者到高级开发者再到架构师的必经之路了。从另外一个方面来说，Android作为一个优秀的基于Linux的移动操作系统，其内部一定有很多地方值得我们学习和借鉴的地方，因此了解的过程就是学习Android操作系统。通过对Android操作系统的学习可以提高我们对操作系统在技术实现上的理解，这对于加强开发人员的内功是有帮助的。但是有一点，由于Android的内部实现多数细节都比较复杂，在研究内部实现上来说更加侧重对整体流程的把握，而不能局限在代码细节而无法自拔。</p>
<p>本章节主要分析Activity的启动过程，通过本章节，可以对Activity的启动过程有一个感性的认识。</p>
<p>我们从startActivity开始，发现最终调用了startActivityForResult方法，使用startActivity的requestCode是-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">        @Nullable Bundle options) &#123;</span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        if (ar != null) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        if (requestCode &gt;= 0) &#123;</span><br><span class="line">            // If this start is requesting a result, we can avoid making</span><br><span class="line">            // the activity visible until the result is received.  Setting</span><br><span class="line">            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br><span class="line">            // activity hidden during this time, to avoid flickering.</span><br><span class="line">            // This can only be done when a result is requested because</span><br><span class="line">            // that guarantees we will get information back when the</span><br><span class="line">            // activity is finished, no matter what happens to it.</span><br><span class="line">            mStartedActivity = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">        // TODO Consider clearing/flushing other event sources and events for child windows.</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options != null) &#123;</span><br><span class="line">            mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Note we want to go through this method for compatibility with</span><br><span class="line">            // existing applications that may have overridden it.</span><br><span class="line">            mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意一下，在第一次启动的时候，mParent是空，然后会调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =</span><br><span class="line">              mInstrumentation.execStartActivity(</span><br><span class="line">                  this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                  intent, requestCode, options);</span><br></pre></td></tr></table></figure></p>
<p>要知道这个方法的作用，就要看一下Instrumentation的execStartActivity做了什么操作，首先看一下穿的的参数，mMainThread.getApplicationThread()这个方法获取的类型是ApplicationThread，这个是ActiviityThread的一个内部类，通过分析发现，ApplicationThread和ActiviityThread在启动Activity的过程中发生了很重要的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">           Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">           Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">       IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">       Uri referrer = target != null ? target.onProvideReferrer() : null;</span><br><span class="line">       if (referrer != null) &#123;</span><br><span class="line">           intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">       &#125;</span><br><span class="line">       if (mActivityMonitors != null) &#123;</span><br><span class="line">           synchronized (mSync) &#123;</span><br><span class="line">               final int N = mActivityMonitors.size();</span><br><span class="line">               for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                   final ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                   ActivityResult result = null;</span><br><span class="line">                   if (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                       result = am.onStartActivity(intent);</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (result != null) &#123;</span><br><span class="line">                       am.mHits++;</span><br><span class="line">                       return result;</span><br><span class="line">                   &#125; else if (am.match(who, null, intent)) &#123;</span><br><span class="line">                       am.mHits++;</span><br><span class="line">                       if (am.isBlocking()) &#123;</span><br><span class="line">                           return requestCode &gt;= 0 ? am.getResult() : null;</span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           intent.migrateExtraStreamToClipData();</span><br><span class="line">           intent.prepareToLeaveProcess(who);</span><br><span class="line">           int result = ActivityManager.getService()</span><br><span class="line">               .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                       intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                       token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                       requestCode, 0, null, options);</span><br><span class="line">           checkStartActivityResult(result, intent);</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里分析一下这个方法,debug跟踪activity的启动，发现最后调用了这些代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intent.migrateExtraStreamToClipData();</span><br><span class="line">    intent.prepareToLeaveProcess(who);</span><br><span class="line">    int result = ActivityManager.getService()</span><br><span class="line">        .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                requestCode, 0, null, options);</span><br><span class="line">    checkStartActivityResult(result, intent);</span><br></pre></td></tr></table></figure></p>
<p>发现这里使用了ActivityManagerService(下面简称为AMS)，在得到AMS之后，调用AMS的startActivity的方法。<br>这里的getService方法获取IActivityManager这个Binder接口,因此AMS也是一个Binder，他是IActivityManager的具体实现。可以发现AMS这个Binder对象采用单例模式对外提供，SIngleton是一个单例封装类，第一次调用他会通过create方法初始化AMS这个Binder对象，在后续的调用过程中则返回之前创建的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">       return IActivityManagerSingleton.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">          new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              protected IActivityManager create() &#123;</span><br><span class="line">                  final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                  final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                  return am;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract class Singleton&lt;T&gt; &#123;</span><br><span class="line">              private T mInstance;</span><br><span class="line"></span><br><span class="line">              protected abstract T create();</span><br><span class="line"></span><br><span class="line">              public final T get() &#123;</span><br><span class="line">                  synchronized (this) &#123;</span><br><span class="line">                      if (mInstance == null) &#123;</span><br><span class="line">                          mInstance = create();</span><br><span class="line">                      &#125;</span><br><span class="line">                      return mInstance;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>ServiceManager的getService方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          IBinder service = sCache.get(name);</span><br><span class="line">          if (service != null) &#123;</span><br><span class="line">              return service;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return Binder.allowBlocking(getIServiceManager().getService(name));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">          Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里先来看一下Instrumentation的checkStartActivityResult方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static void checkStartActivityResult(int res, Object intent) &#123;</span><br><span class="line">    if (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (res) &#123;</span><br><span class="line">        case ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        case ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null)</span><br><span class="line">                throw new ActivityNotFoundException(</span><br><span class="line">                        &quot;Unable to find explicit activity class &quot;</span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;);</span><br><span class="line">            throw new ActivityNotFoundException(</span><br><span class="line">                    &quot;No Activity found to handle &quot; + intent);</span><br><span class="line">        case ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">            throw new SecurityException(&quot;Not allowed to start activity &quot;</span><br><span class="line">                    + intent);</span><br><span class="line">        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">            throw new AndroidRuntimeException(</span><br><span class="line">                    &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;);</span><br><span class="line">        case ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;PendingIntent is not an activity&quot;);</span><br><span class="line">        case ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            throw new SecurityException(</span><br><span class="line">                    &quot;Starting under voice control not allowed for: &quot; + intent);</span><br><span class="line">        case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Session calling startVoiceActivity does not match active session&quot;);</span><br><span class="line">        case ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Cannot start voice activity on a hidden session&quot;);</span><br><span class="line">        case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Session calling startAssistantActivity does not match active session&quot;);</span><br><span class="line">        case ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Cannot start assistant activity on a hidden session&quot;);</span><br><span class="line">        case ActivityManager.START_CANCELED:</span><br><span class="line">            throw new AndroidRuntimeException(&quot;Activity could not be started for &quot;</span><br><span class="line">                    + intent);</span><br><span class="line">        default:</span><br><span class="line">            throw new AndroidRuntimeException(&quot;Unknown error code &quot;</span><br><span class="line">                    + res + &quot; when starting &quot; + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到他是检查activity是否启动成功的，当无法启动一个activity是，这个方法就会抛出异常，这里看一下我们经常看到的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">have you declared this activity in your AndroidManifest.xml</span><br></pre></td></tr></table></figure></p>
<p>activity没有在Manifest.xml注册</p>
<p>这里继续分析startActivity方法，是在AMS中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">          Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">          int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">      return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">              resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">              UserHandle.getCallingUserId());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到他其实是调用了startActivityAsUser这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, null, null, bOptions, false, userId, null, null,</span><br><span class="line">            &quot;startActivityAsUser&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里又进行了转移,转移到了ActivityStarter的<code>startActivityMayWait</code>方法,这个方法比较长，这里看一下他关键的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">               aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">               resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">               callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">               options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">               inTask, reason);</span><br></pre></td></tr></table></figure></p>
<p>在进行了对activity启动的一系列判断之后会调用<code>startActivityLocked</code>这个方法来启动activity,看一下这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span><br><span class="line">            TaskRecord inTask, String reason) &#123;</span><br><span class="line"></span><br><span class="line">        if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastStartReason = reason;</span><br><span class="line">        mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">        mLastStartActivityRecord[0] = null;</span><br><span class="line"></span><br><span class="line">        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">                container, inTask);</span><br><span class="line"></span><br><span class="line">        if (outActivity != null) &#123;</span><br><span class="line">            // mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">            outActivity[0] = mLastStartActivityRecord[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return mLastStartActivityResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了startActivity方法，这个方法比较长 ，找一下关键代码<br>看到有一次调用了startActivity的重载方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">          int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">          ActivityRecord[] outActivity) &#123;</span><br><span class="line">      int result = START_CANCELED;</span><br><span class="line">      try &#123;</span><br><span class="line">          mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">          result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                  startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          // If we are not able to proceed, disassociate the activity from the task. Leaving an</span><br><span class="line">          // activity in an incomplete state can lead to issues, such as performing operations</span><br><span class="line">          // without a window container.</span><br><span class="line">          if (!ActivityManager.isStartResultSuccessful(result)</span><br><span class="line">                  &amp;&amp; mStartActivity.getTask() != null) &#123;</span><br><span class="line">              mStartActivity.getTask().removeActivity(mStartActivity);</span><br><span class="line">          &#125;</span><br><span class="line">          mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,</span><br><span class="line">              mTargetStack);</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了startActivityUnchecked这个方法,我们继续跟踪，可以看到调用了mSupervisor的 <code>resumeFocusedStackTopActivityLocked</code>这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mDoResume) &#123;</span><br><span class="line">                 mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>
<p>mDoResume这个一定是true</p>
<p>mSupervisor的resumeFocusedStackTopActivityLocked方法会调用这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    if (r == null || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">    &#125; else if (r.state == RESUMED) &#123;</span><br><span class="line">        // Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候又会调用mFocusedStack的<code>resumeTopActivityUncheckedLocked</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">     if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">         // Don&apos;t even start recursing.</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     boolean result = false;</span><br><span class="line">     try &#123;</span><br><span class="line">         // Protect against recursion.</span><br><span class="line">         mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">         result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">     &#125;</span><br><span class="line">     // When resuming the top activity, it may be necessary to pause the top activity (for</span><br><span class="line">     // example, returning to the lock screen. We suppress the normal pause logic in</span><br><span class="line">     // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the end.</span><br><span class="line">     // We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here to ensure</span><br><span class="line">     // any necessary pause logic occurs.</span><br><span class="line">     mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候可以看到会调用resumeTopActivityInnerLocked方法,这里会调用mStackSupervisor的<code>startSpecificActivityLocked</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br></pre></td></tr></table></figure></p>
<p>看一下startSpecificActivityLocked方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">         boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">     // Is this activity&apos;s application already running?</span><br><span class="line">     ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">             r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">     r.getStack().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">     if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                     || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                 // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                 // to run in multiple processes, because this is actually</span><br><span class="line">                 // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                 // separate apk in the process.</span><br><span class="line">                 app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                         mService.mProcessStats);</span><br><span class="line">             &#125;</span><br><span class="line">             realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">             return;</span><br><span class="line">         &#125; catch (RemoteException e) &#123;</span><br><span class="line">             Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                     + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // If a dead object exception was thrown -- fall through to</span><br><span class="line">         // restart the application.</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">             &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用 <strong>真正启动Activity</strong> 的方法<code>realStartActivityLocked</code><br>这里会调用这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info,</span><br><span class="line">                // TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">                // override configs.</span><br><span class="line">                mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                mService.isNextTransitionForward(), profilerInfo);</span><br></pre></td></tr></table></figure></p>
<p>这段代码很重要，其中app.thread的类型是IAppLicationThread,他的声明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface IApplicationThread extends IInterface &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉AIDL的都知道这个是一个Binder类型的接口。从IApplicationThread声明的接口方法可以看出，其内部包含了大量启动、停止Activity的接口，此外还包含了启动和停止服务的接口。从接口方法的命名可以猜测，这个类接口实现者完成了大量和Activity以及Service相关的启动功能，事实却是如此<br>IApplicationThread他的具体实现是什么，是ApplicationThread，这个是ActivityThread中的匿名内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends IApplicationThread.Stub &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以发现IApplicationThread是Aidl自动生成的代码<br>绕了一大圈发现这里回到ApplicationThread并且使用了scheduleLaunchActivity这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">             ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">             CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">             int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">             List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">             boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">         updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">         ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">         r.token = token;</span><br><span class="line">         r.ident = ident;</span><br><span class="line">         r.intent = intent;</span><br><span class="line">         r.referrer = referrer;</span><br><span class="line">         r.voiceInteractor = voiceInteractor;</span><br><span class="line">         r.activityInfo = info;</span><br><span class="line">         r.compatInfo = compatInfo;</span><br><span class="line">         r.state = state;</span><br><span class="line">         r.persistentState = persistentState;</span><br><span class="line"></span><br><span class="line">         r.pendingResults = pendingResults;</span><br><span class="line">         r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">         r.startsNotResumed = notResumed;</span><br><span class="line">         r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">         r.profilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">         r.overrideConfig = overrideConfig;</span><br><span class="line">         updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">         sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>这里只是使用Hadler处理Activity的启动消息</p>
<p>看一下这个Handler的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line">  private class H extends Handler &#123;</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">            handleRelaunchActivity(r);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case PAUSE_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</span><br><span class="line">            SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">            handlePauseActivity((IBinder) args.arg1, false,</span><br><span class="line">                    (args.argi1 &amp; USER_LEAVING) != 0, args.argi2,</span><br><span class="line">                    (args.argi1 &amp; DONT_REPORT) != 0, args.argi3);</span><br><span class="line">            maybeSnapshot();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case PAUSE_ACTIVITY_FINISHING: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</span><br><span class="line">            SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">            handlePauseActivity((IBinder) args.arg1, true, (args.argi1 &amp; USER_LEAVING) != 0,</span><br><span class="line">                    args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case STOP_ACTIVITY_SHOW: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStop&quot;);</span><br><span class="line">            SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">            handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case STOP_ACTIVITY_HIDE: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStop&quot;);</span><br><span class="line">            SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">            handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case SHOW_WINDOW:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityShowWindow&quot;);</span><br><span class="line">            handleWindowVisibility((IBinder)msg.obj, true);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case HIDE_WINDOW:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityHideWindow&quot;);</span><br><span class="line">            handleWindowVisibility((IBinder)msg.obj, false);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case RESUME_ACTIVITY:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityResume&quot;);</span><br><span class="line">            SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true,</span><br><span class="line">                    args.argi3, &quot;RESUME_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case SEND_RESULT:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityDeliverResult&quot;);</span><br><span class="line">            handleSendResult((ResultData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case DESTROY_ACTIVITY:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityDestroy&quot;);</span><br><span class="line">            handleDestroyActivity((IBinder)msg.obj, msg.arg1 != 0,</span><br><span class="line">                    msg.arg2, false);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case BIND_APPLICATION:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">            AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">            handleBindApplication(data);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case EXIT_APPLICATION:</span><br><span class="line">            if (mInitialApplication != null) &#123;</span><br><span class="line">                mInitialApplication.onTerminate();</span><br><span class="line">            &#125;</span><br><span class="line">            Looper.myLooper().quit();</span><br><span class="line">            break;</span><br><span class="line">        case NEW_INTENT:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityNewIntent&quot;);</span><br><span class="line">            handleNewIntent((NewIntentData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case RECEIVER:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastReceiveComp&quot;);</span><br><span class="line">            handleReceiver((ReceiverData)msg.obj);</span><br><span class="line">            maybeSnapshot();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case CREATE_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case BIND_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;);</span><br><span class="line">            handleBindService((BindServiceData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case UNBIND_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceUnbind&quot;);</span><br><span class="line">            handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case SERVICE_ARGS:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">            handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case STOP_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceStop&quot;);</span><br><span class="line">            handleStopService((IBinder)msg.obj);</span><br><span class="line">            maybeSnapshot();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case CONFIGURATION_CHANGED:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;configChanged&quot;);</span><br><span class="line">            mCurDefaultDisplayDpi = ((Configuration)msg.obj).densityDpi;</span><br><span class="line">            mUpdatingSystemConfig = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                handleConfigurationChanged((Configuration) msg.obj, null);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mUpdatingSystemConfig = false;</span><br><span class="line">            &#125;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case CLEAN_UP_CONTEXT:</span><br><span class="line">            ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj;</span><br><span class="line">            cci.context.performFinalCleanup(cci.who, cci.what);</span><br><span class="line">            break;</span><br><span class="line">        case GC_WHEN_IDLE:</span><br><span class="line">            scheduleGcIdler();</span><br><span class="line">            break;</span><br><span class="line">        case DUMP_SERVICE:</span><br><span class="line">            handleDumpService((DumpComponentInfo)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case LOW_MEMORY:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;lowMemory&quot;);</span><br><span class="line">            handleLowMemory();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case ACTIVITY_CONFIGURATION_CHANGED:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityConfigChanged&quot;);</span><br><span class="line">            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj,</span><br><span class="line">                    INVALID_DISPLAY);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case ACTIVITY_MOVED_TO_DISPLAY:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityMovedToDisplay&quot;);</span><br><span class="line">            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj,</span><br><span class="line">                    msg.arg1 /* displayId */);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case PROFILER_CONTROL:</span><br><span class="line">            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo)msg.obj, msg.arg2);</span><br><span class="line">            break;</span><br><span class="line">        case CREATE_BACKUP_AGENT:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;backupCreateAgent&quot;);</span><br><span class="line">            handleCreateBackupAgent((CreateBackupAgentData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case DESTROY_BACKUP_AGENT:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;backupDestroyAgent&quot;);</span><br><span class="line">            handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case SUICIDE:</span><br><span class="line">            Process.killProcess(Process.myPid());</span><br><span class="line">            break;</span><br><span class="line">        case REMOVE_PROVIDER:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;providerRemove&quot;);</span><br><span class="line">            completeRemoveProvider((ProviderRefCount)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case ENABLE_JIT:</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">            break;</span><br><span class="line">        case DISPATCH_PACKAGE_BROADCAST:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastPackage&quot;);</span><br><span class="line">            handleDispatchPackageBroadcast(msg.arg1, (String[])msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case SCHEDULE_CRASH:</span><br><span class="line">            throw new RemoteServiceException((String)msg.obj);</span><br><span class="line">        case DUMP_HEAP:</span><br><span class="line">            handleDumpHeap(msg.arg1 != 0, (DumpHeapData)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case DUMP_ACTIVITY:</span><br><span class="line">            handleDumpActivity((DumpComponentInfo)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case DUMP_PROVIDER:</span><br><span class="line">            handleDumpProvider((DumpComponentInfo)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case SLEEPING:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;sleeping&quot;);</span><br><span class="line">            handleSleeping((IBinder)msg.obj, msg.arg1 != 0);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case SET_CORE_SETTINGS:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;setCoreSettings&quot;);</span><br><span class="line">            handleSetCoreSettings((Bundle) msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case UPDATE_PACKAGE_COMPATIBILITY_INFO:</span><br><span class="line">            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case TRIM_MEMORY:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;trimMemory&quot;);</span><br><span class="line">            handleTrimMemory(msg.arg1);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        case UNSTABLE_PROVIDER_DIED:</span><br><span class="line">            handleUnstableProviderDied((IBinder)msg.obj, false);</span><br><span class="line">            break;</span><br><span class="line">        case REQUEST_ASSIST_CONTEXT_EXTRAS:</span><br><span class="line">            handleRequestAssistContextExtras((RequestAssistContextExtras)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case TRANSLUCENT_CONVERSION_COMPLETE:</span><br><span class="line">            handleTranslucentConversionComplete((IBinder)msg.obj, msg.arg1 == 1);</span><br><span class="line">            break;</span><br><span class="line">        case INSTALL_PROVIDER:</span><br><span class="line">            handleInstallProvider((ProviderInfo) msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case ON_NEW_ACTIVITY_OPTIONS:</span><br><span class="line">            Pair&lt;IBinder, ActivityOptions&gt; pair = (Pair&lt;IBinder, ActivityOptions&gt;) msg.obj;</span><br><span class="line">            onNewActivityOptions(pair.first, pair.second);</span><br><span class="line">            break;</span><br><span class="line">        case CANCEL_VISIBLE_BEHIND:</span><br><span class="line">            handleCancelVisibleBehind((IBinder) msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case BACKGROUND_VISIBLE_BEHIND_CHANGED:</span><br><span class="line">            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 &gt; 0);</span><br><span class="line">            break;</span><br><span class="line">        case ENTER_ANIMATION_COMPLETE:</span><br><span class="line">            handleEnterAnimationComplete((IBinder) msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case START_BINDER_TRACKING:</span><br><span class="line">            handleStartBinderTracking();</span><br><span class="line">            break;</span><br><span class="line">        case STOP_BINDER_TRACKING_AND_DUMP:</span><br><span class="line">            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case MULTI_WINDOW_MODE_CHANGED:</span><br><span class="line">            handleMultiWindowModeChanged((IBinder) ((SomeArgs) msg.obj).arg1,</span><br><span class="line">                    ((SomeArgs) msg.obj).argi1 == 1,</span><br><span class="line">                    (Configuration) ((SomeArgs) msg.obj).arg2);</span><br><span class="line">            break;</span><br><span class="line">        case PICTURE_IN_PICTURE_MODE_CHANGED:</span><br><span class="line">            handlePictureInPictureModeChanged((IBinder) ((SomeArgs) msg.obj).arg1,</span><br><span class="line">                    ((SomeArgs) msg.obj).argi1 == 1,</span><br><span class="line">                    (Configuration) ((SomeArgs) msg.obj).arg2);</span><br><span class="line">            break;</span><br><span class="line">        case LOCAL_VOICE_INTERACTION_STARTED:</span><br><span class="line">            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1,</span><br><span class="line">                    (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);</span><br><span class="line">            break;</span><br><span class="line">        case ATTACH_AGENT:</span><br><span class="line">            handleAttachAgent((String) msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case APPLICATION_INFO_CHANGED:</span><br><span class="line">            mUpdatingSystemConfig = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                handleApplicationInfoChanged((ApplicationInfo) msg.obj);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mUpdatingSystemConfig = false;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    Object obj = msg.obj;</span><br><span class="line">    if (obj instanceof SomeArgs) &#123;</span><br><span class="line">        ((SomeArgs) obj).recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到使用了这个方法来处理     handleLaunchActivity(r, null, “LAUNCH_ACTIVITY”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">  // If we are getting ready to gc after going to the background, well</span><br><span class="line">  // we are back active so skip it.</span><br><span class="line">  unscheduleGcIdler();</span><br><span class="line">  mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">  if (r.profilerInfo != null) &#123;</span><br><span class="line">      mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">      mProfiler.startProfiling();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Make sure we are running with the most recent config.</span><br><span class="line">  handleConfigurationChanged(null, null);</span><br><span class="line"></span><br><span class="line">  if (localLOGV) Slog.v(</span><br><span class="line">      TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line"></span><br><span class="line">  // Initialize before creating the activity</span><br><span class="line">  WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">  Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">  if (a != null) &#123;</span><br><span class="line">      r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">      reportSizeConfigurations(r);</span><br><span class="line">      Bundle oldState = r.state;</span><br><span class="line">      handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">              !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">      if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">          performPauseActivityIfNeeded(r, reason);</span><br><span class="line">          if (r.isPreHoneycomb()) &#123;</span><br><span class="line">              r.state = oldState;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">      try &#123;</span><br><span class="line">          ActivityManager.getService()</span><br><span class="line">              .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                      Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">      &#125; catch (RemoteException ex) &#123;</span><br><span class="line">          throw ex.rethrowFromSystemServer();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到执行了这个方法来创建Activity<code>performLaunchActivity</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">        component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (r.overrideConfig != null) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            Window window = null;</span><br><span class="line">            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = null;</span><br><span class="line">                r.mPendingRemoveWindowManager = null;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            if (customIntent != null) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = null;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = false;</span><br><span class="line">            int theme = r.activityInfo.getThemeResource();</span><br><span class="line">            if (theme != 0) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = true;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    if (r.state != null || r.persistentState != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (r.state != null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = true;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to start activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 使用Instrumentation的newActivity来创建Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">             cl, component.getClassName(), r.intent);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Activity newActivity(ClassLoader cl, String className,</span><br><span class="line">          Intent intent)</span><br><span class="line">          throws InstantiationException, IllegalAccessException,</span><br><span class="line">          ClassNotFoundException &#123;</span><br><span class="line">      return (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>终于找到了，通过loadClass来创建对象.<br>回到这个方法performLaunchActivity，看一下他还做了什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>获取activity的信息</p>
<p>这里创建Application</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br></pre></td></tr></table></figure>
<p> r.packageInfo得到LoadedApk对象，然后调用他的makeApplication<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;);</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rewrite the R &apos;constants&apos; for all library apks.</span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers();</span><br><span class="line">    final int N = packageIdentifiers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是一个单例，如果Application已经创建了，就不会再创建,在创建Applicaiton的时候会调用makeApplication里面有这样一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用Applicaiton的onCreate方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">     app.onCreate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到ActivityThread的performLaunchActivity方法，看一下其中另外一部分代码的调用，看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                      r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                      r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                      r.referrer, r.voiceInteractor, window, r.configCallback);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">           Instrumentation instr, IBinder token, int ident,</span><br><span class="line">           Application application, Intent intent, ActivityInfo info,</span><br><span class="line">           CharSequence title, Activity parent, String id,</span><br><span class="line">           NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">           Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">           Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">       attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">       mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">       mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">       mWindow.setWindowControllerCallback(this);</span><br><span class="line">       mWindow.setCallback(this);</span><br><span class="line">       mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">       mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">       if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">           mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">       &#125;</span><br><span class="line">       if (info.uiOptions != 0) &#123;</span><br><span class="line">           mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">       &#125;</span><br><span class="line">       mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       mMainThread = aThread;</span><br><span class="line">       mInstrumentation = instr;</span><br><span class="line">       mToken = token;</span><br><span class="line">       mIdent = ident;</span><br><span class="line">       mApplication = application;</span><br><span class="line">       mIntent = intent;</span><br><span class="line">       mReferrer = referrer;</span><br><span class="line">       mComponent = intent.getComponent();</span><br><span class="line">       mActivityInfo = info;</span><br><span class="line">       mTitle = title;</span><br><span class="line">       mParent = parent;</span><br><span class="line">       mEmbeddedID = id;</span><br><span class="line">       mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">       if (voiceInteractor != null) &#123;</span><br><span class="line">           if (lastNonConfigurationInstances != null) &#123;</span><br><span class="line">               mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                       Looper.myLooper());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mWindow.setWindowManager(</span><br><span class="line">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">               mToken, mComponent.flattenToString(),</span><br><span class="line">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">       if (mParent != null) &#123;</span><br><span class="line">           mWindow.setContainer(mParent.getWindow());</span><br><span class="line">       &#125;</span><br><span class="line">       mWindowManager = mWindow.getWindowManager();</span><br><span class="line">       mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">       mWindow.setColorMode(info.colorMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里面创建Activity所需要的window</p>
<p>再回到ActivityThread的performLaunchActivity方法，看一下其中另外一部分代码的调用，看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (r.isPersistable()) &#123;</span><br><span class="line">               mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>Instrumentation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle,</span><br><span class="line">        PersistableBundle persistentState) &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle, persistentState);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Activity的Oncreate方法在这里调用</p>
<p>在回到ActivityThread的performLaunchActivity方法<br>看方法的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.performStart();</span><br></pre></td></tr></table></figure></p>
<p>调用Activity的onStart方法</p>
<p>再次回到ActivityThread的handleLaunchActivity方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                   !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br></pre></td></tr></table></figure></p>
<p>调用activity的onresume方法</p>
<p>这里Activity的生命周期就调用完毕了</p>
<p><img src="activity工作流程.svg" alt="Alt text" title="Android 启动,最好下载下来看"></p>
<h1 id="Service-工作过程"><a href="#Service-工作过程" class="headerlink" title="Service 工作过程"></a>Service 工作过程</h1><p>上面分析了Activity的工作过程，加深了对Activity的理解。这里来折腾一下Service的<br>这里从StartService开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intentService=new Intent(this,MyService.class);</span><br><span class="line">        startService(intentService);</span><br><span class="line">        bindService(intentService, new ServiceConnection() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void onServiceDisconnected(ComponentName componentName) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Service的启动过程：startService过程"><a href="#Service的启动过程：startService过程" class="headerlink" title="Service的启动过程：startService过程"></a>Service的启动过程：startService过程</h2><p>Service启动过程是从ContextWrapper的startService方法开始的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">    return mBase.startService(service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下mBase：他是contextImpl，这个是ContextWrapper的具体实现，是一个装饰者模式。关于context的内容，大家可以百度一下，这个在android里面是一个非常重要的概念，后面我也会整理一下</p>
<p>这里看一下contextImpl中的startService方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return startServiceCommon(service, false, mUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他调用了startServiceCommon，那我们看一下这个方法做了什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private ComponentName startServiceCommon(Intent service, boolean requireForeground,</span><br><span class="line">        UserHandle user) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), requireForeground,</span><br><span class="line">                        getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (cn != null) &#123;</span><br><span class="line">            if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Not allowed to start service &quot; + service</span><br><span class="line">                        + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">            &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Unable to start service &quot; + service</span><br><span class="line">                        + &quot;: &quot; + cn.getClassName());</span><br><span class="line">            &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123;</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                        &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cn;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里又看到了一个熟悉的身影ActivityManager，之后调用了他的getService，得到ActivityManagerService,就是之前的AMS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">    return IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected IActivityManager create() &#123;</span><br><span class="line">                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                return am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>得到AMS之后，调用他的startService方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">        String resolvedType, boolean requireForeground, String callingPackage, int userId)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callingPackage == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">            &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground);</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res;</span><br><span class="line">        try &#123;</span><br><span class="line">            res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                    resolvedType, callingPid, callingUid,</span><br><span class="line">                    requireForeground, callingPackage, userId);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里AMS在这个方法里面调用了mServices.startServiceLocked。mServices是一个ActiveServices对象。他调用startServiceLocked方法<br>ActiveServices是一个辅助AMS进行Service管理的类，他包括Service的启动、绑定。停止等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">        int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    return cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startServiceLocked方法比较长，就省略了一部分，重点是最后一段代码：<br>看一下这一段代码做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">        boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">    ServiceState stracker = r.getTracker();</span><br><span class="line">    if (stracker != null) &#123;</span><br><span class="line">        stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    r.callStart = false;</span><br><span class="line">    synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">    if (error != null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!!&quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        boolean first = smap.mStartingBackground.size() == 0;</span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">        if (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line">            RuntimeException here = new RuntimeException(&quot;here&quot;);</span><br><span class="line">            here.fillInStackTrace();</span><br><span class="line">            Slog.v(TAG_SERVICE, &quot;Starting background (first=&quot; + first + &quot;): &quot; + r, here);</span><br><span class="line">        &#125; else if (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, &quot;Starting background (first=&quot; + first + &quot;): &quot; + r);</span><br><span class="line">        &#125;</span><br><span class="line">        if (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStartsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (callerFg || r.fgRequired) &#123;</span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceRecoed是描述一个Service记录，还记得ActivityRecord吗?，这个和ActivityRecord功能是类似的，ServiceRecord一直贯穿着整个Service的启动过程。但是startServiceInnerLocked并没有完成Service的启动，而是把工作交给了bringUpServiceLocked这个方法，我们看一下他的具体逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">        boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">          ...</span><br><span class="line">              realStartServiceLocked(r, app, execInFg);</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又调用了realStartServiceLocked方法。是不是很熟悉，Activity也是一样的，这里才是真正启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">        ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">    if (app.thread == null) &#123;</span><br><span class="line">        throw new RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, &quot;realStartServiceLocked, ServiceRecord.uid = &quot; + r.appInfo.uid</span><br><span class="line">                + &quot;, ProcessRecord.uid = &quot; + app.uid);</span><br><span class="line">    r.app = app;</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    final boolean newService = app.services.add(r);</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">    mAm.updateLruProcessLocked(app, false, null);</span><br><span class="line">    updateServiceForegroundLocked(r.app, /* oomAdj= */ false);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    boolean created = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">            String nameTerm;</span><br><span class="line">            int lastPeriod = r.shortName.lastIndexOf(&apos;.&apos;);</span><br><span class="line">            nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = true;</span><br><span class="line">    &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Application dead when creating service &quot; + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!created) &#123;</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            // Cleanup.</span><br><span class="line">            if (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Retry.</span><br><span class="line">            if (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">    // If the service is in the started state, and there are no</span><br><span class="line">    // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">    // be called.</span><br><span class="line">    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                null, null, 0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面先调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">           mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">           app.repProcState);</span><br></pre></td></tr></table></figure></p>
<p>这个东西，是不是有点熟悉，activity启动里面也有一个类似的是app.thread.scheduleLaunchActivity，然后这里就是回到ActivityThread通过Handler H来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">          ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">          updateProcessState(processState, false);</span><br><span class="line">          CreateServiceData s = new CreateServiceData();</span><br><span class="line">          s.token = token;</span><br><span class="line">          s.info = info;</span><br><span class="line">          s.compatInfo = compatInfo;</span><br><span class="line">          sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看一下handler H里面的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br></pre></td></tr></table></figure></p>
<p>最终调用了handleCreateService方法，来看一下这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line"></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法分为几个步骤：</p>
<ol>
<li>首先通过类加载器来创建Service对象</li>
<li>接着创建Application对象并调用其onCreate方法，当然Application创建过程只会只会有一次</li>
<li>接着创建ConTextImpl对象病通过Service的attach方法建立两者之间的联系，这个和Activity是类似的。</li>
<li>最后调用Service的onCreate方法并将Service对象存储到ActivityThread中的一个列表中<br>由于Service的onCreate方法已经被执行了，这意味着Service已经启动了，除此之外，ActivityThread中还会通过handleServiceArgs方法调用Service的onStartCommand方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (data.args != null) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            int res;</span><br><span class="line">            if (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to start service &quot; + s</span><br><span class="line">                        + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个样子startService的几个重要生命周期方法都调用了，Service的启动过程就分析完毕了</p>
<p>和上面的Activity一样，用一张UML来总结一下</p>
<p><img src="service启动流程图.svg" alt="Alt text" title="Service 启动,最好下载下来看"></p>
<h2 id="Service的绑定过程"><a href="#Service的绑定过程" class="headerlink" title="Service的绑定过程"></a>Service的绑定过程</h2><p>和Service的启动过程是一样的，Service的绑定过程也是从ContextWrapper开始的，如下所示</p>
<p>bindService其实是调用ContextWrapper的bindService方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">        int flags) &#123;</span><br><span class="line">    return mBase.bindService(service, conn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下mBase：他是contextImpl，这个是ContextWrapper的具体实现，是一个装饰者模式。这个在介绍Service启动的时候介绍过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">        int flags) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">            Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和启动Service类似，这里调用了bindServiceCommon这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler</span><br><span class="line">        handler, UserHandle user) &#123;</span><br><span class="line">    // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    if (conn == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;connection is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mPackageInfo != null) &#123;</span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Not supported in system context&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null</span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        int res = ActivityManager.getService().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            throw new SecurityException(</span><br><span class="line">                    &quot;Not allowed to bind to service &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line">        return res != 0;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下这个方法的内容：这个方法主要完成两件事情<br>第一个是将ServiceConnection对象转换成InnerConnection这个对象</p>
<p>这里看一下这段代码<code>sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</code>mPackageInfo这个是一个LoadedApk类，我们跟进去看一下这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final IServiceConnection getServiceDispatcher(ServiceConnection c,</span><br><span class="line">        Context context, Handler handler, int flags) &#123;</span><br><span class="line">    synchronized (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = null;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;Returning existing dispatcher &quot; + sd + &quot; for conn &quot; + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sd == null) &#123;</span><br><span class="line">            sd = new ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;Creating new dispatcher &quot; + sd + &quot; for conn &quot; + c);</span><br><span class="line">            if (map == null) &#123;</span><br><span class="line">                map = new ArrayMap&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        return sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里创建了<code>new ServiceDispatcher(c, context, handler, flags);</code>这个对象，ServiceDispatcher是LoadedApk的一个内部类.看一下他的构造方法里面做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServiceDispatcher(ServiceConnection conn,</span><br><span class="line">            Context context, Handler activityThread, int flags) &#123;</span><br><span class="line">        mIServiceConnection = new InnerConnection(this);</span><br><span class="line">        mConnection = conn;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mActivityThread = activityThread;</span><br><span class="line">        mLocation = new ServiceConnectionLeaked(null);</span><br><span class="line">        mLocation.fillInStackTrace();</span><br><span class="line">        mFlags = flags;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里创建了InnerConnection,而InnerConnection是ServiceDispatcher的内部类，看一下InnerConnection的具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">    final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">    InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">        mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void connected(ComponentName name, IBinder service, boolean dead)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">        if (sd != null) &#123;</span><br><span class="line">            sd.connected(name, service, dead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里继承了IServiceConnection.Stub,说明他是一个AIDL。这里解释一下为什么不能直接使用ServiceConnection对象，这是因为服务的绑定有可能是跨进程的，因此ServiceConnection对象必须借助于Binder才能让远程服务回调自己的方法，而ServiceDispatcher的内部类InnerConnection刚好充当了Binder这个角色<br>看一下ServiceConnection只是一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ServiceConnection &#123;</span><br><span class="line">    void onServiceConnected(android.content.ComponentName componentName, android.os.IBinder iBinder);</span><br><span class="line"></span><br><span class="line">    void onServiceDisconnected(android.content.ComponentName componentName);</span><br><span class="line"></span><br><span class="line">    default void onBindingDied(android.content.ComponentName name) &#123; /* compiled code */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么ServiceDispatcher的作用是什么呢？其实ServiceDispatcher起连接ServiceConnection和InnerConnection的作用<br>回到LoadedApk的<code>getServiceDispatcher</code>方法，看一下是怎么将ServiceConnection和InnerConnection连接的<br>这里使用mService是一个ArrayMap集合，他存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系，他的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</span><br><span class="line">      = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>系统会首先查找是否存在相同的ServiceConnection,如果不存在就创建一个ServiceDispatcher对象并将其存储在mService中，其中映射关系的key是ServiceConnection,Value是LoadedApk.ServiceDispatcher。在LoadedApk.ServiceDispatcher内部又保存了ServiceConnection和InnerConnection对象。当Service和客户端建立连接之后，系统会通知InnerConnection来调用ServiceConnection中的OnServiceConnected方法，这个过程有可能是跨进程的。当ServiceDispatcher创建好了之后，getServiceDispatcher 会返回他保存的InnerConnection这个对象，接着bindServiceCOmmon方法</p>
<ul>
<li>第二个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int res = ActivityManager.getService().bindService(</span><br><span class="line">    mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">    service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">    sd, flags, getOpPackageName(), user.getIdentifier());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>是不是有点熟悉，调用了AMS的bindService方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int bindService(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">            String resolvedType, IServiceConnection connection, int flags, String callingPackage,</span><br><span class="line">            int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;bindService&quot;);</span><br><span class="line"></span><br><span class="line">        // Refuse possible leaked file descriptors</span><br><span class="line">        if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (callingPackage == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            return mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                    resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用ActiveServices的<code>bindServiceLocked</code>方法。<br>方法比较长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">            String resolvedType, final IServiceConnection connection, int flags,</span><br><span class="line">            String callingPackage, final int userId) throws TransactionTooLargeException &#123;...</span><br><span class="line">              bringUpServiceLocked</span><br><span class="line">              ...&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了bringUpServiceLocked这个方法，看一下这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">        boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">          ...</span><br><span class="line">                    realStartServiceLocked(r, app, execInFg);</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>bringUpServiceLocked这个方法调用了realStartServiceLocked，这里就回到了StartService要调用的那个方法了。和StartService一样。那区别在哪儿呢？<br>bindServiceLocked在这个方法里面也调用了requestServiceBindingLocked这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">        boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">    if (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">        // If service is not currently running, can&apos;t yet bind.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, &quot;requestBind &quot; + i + &quot;: requested=&quot; + i.requested</span><br><span class="line">            + &quot; rebind=&quot; + rebind);</span><br><span class="line">    if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, &quot;bind&quot;);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            if (!rebind) &#123;</span><br><span class="line">                i.requested = true;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = true;</span><br><span class="line">            i.doRebind = false;</span><br><span class="line">        &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r, e);</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r);</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>requestServiceBindingLocked里面有一个比较关键的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">        r.app.repProcState);</span><br></pre></td></tr></table></figure></p>
<p>这里又回到了ActivityThread<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleBindService(IBinder token, Intent intent,</span><br><span class="line">        boolean rebind, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    BindServiceData s = new BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, &quot;scheduleBindService token=&quot; + token + &quot; intent=&quot; + intent + &quot; uid=&quot;</span><br><span class="line">                + Binder.getCallingUid() + &quot; pid=&quot; + Binder.getCallingPid());</span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用handler H这个接受事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case BIND_SERVICE:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;);</span><br><span class="line">    handleBindService((BindServiceData)msg.obj);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br></pre></td></tr></table></figure>
<p>在H接收到的BIND_SERVICE这类消息时，会交给handleBindService来处理，在handleBindService过程中，首先根据Service的Token去除Service对象，然后调用Service的onBind方法，Service的onBInd方法返回一个Binder对象给客户端使用，这个过程就比较熟悉了，但是onBind是Service的方法，这个时候客户端并不知道已经成功连接Service了，所以还必须调用客户端的ServiceConnection中的onServiceConnected,这个过程是有AMS的publishService来完成的</p>
<p>看一下关键代码handleBindService<br>Service有一个特性，就是多次绑定时，onBind方法只调用一次，除非Service终止了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindService(BindServiceData data) &#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!data.rebind) &#123;</span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to bind to service &quot; + s</span><br><span class="line">                        + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AMS的publishService方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void publishService(IBinder token, Intent intent, IBinder service) &#123;</span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看出AMS的publishService方法将工作交给了ActiveServices来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;PUBLISHING &quot; + r</span><br><span class="line">                + &quot; &quot; + intent + &quot;: &quot; + service);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = new Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            if (b != null &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = true;</span><br><span class="line">                b.received = true;</span><br><span class="line">                for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    for (int i=0; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        if (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, &quot;Not publishing to: &quot; + c);</span><br><span class="line">                            if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, &quot;Bound intent: &quot; + c.binding.intent.intent);</span><br><span class="line">                            if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, &quot;Published intent: &quot; + intent);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Publishing to: &quot; + c);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.conn.connected(r.name, service, false);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Failure sending service &quot; + r.name +</span><br><span class="line">                                  &quot; to connection &quot; + c.conn.asBinder() +</span><br><span class="line">                                  &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActiveServices的publishService方法很长，但是核心代码只有一句话<code>c.conn.connected(r.name, service, false);</code><br>c是ConnectionRecord，c.conn是ServiceDispatcher.InnerConnection，service就是Service的onBind方法返回的binder对象。</p>
<p>这里在回来看一下InnerConnection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">    final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">    InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">        mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void connected(ComponentName name, IBinder service, boolean dead)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">        if (sd != null) &#123;</span><br><span class="line">            sd.connected(name, service, dead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到connected这个方法调用的是ServiceDispatcher的connected方法，看一下他的具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void connected(ComponentName name, IBinder service, boolean dead) &#123;</span><br><span class="line">      if (mActivityThread != null) &#123;</span><br><span class="line">          mActivityThread.post(new RunConnection(name, service, 0, dead));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          doConnected(name, service, dead);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下mActivityThread是不为空的，这样一来，就通过post方法回到主线程，而RunConnection的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private final class RunConnection implements Runnable &#123;</span><br><span class="line">          RunConnection(ComponentName name, IBinder service, int command, boolean dead) &#123;</span><br><span class="line">              mName = name;</span><br><span class="line">              mService = service;</span><br><span class="line">              mCommand = command;</span><br><span class="line">              mDead = dead;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          public void run() &#123;</span><br><span class="line">              if (mCommand == 0) &#123;</span><br><span class="line">                  doConnected(mName, mService, mDead);</span><br><span class="line">              &#125; else if (mCommand == 1) &#123;</span><br><span class="line">                  doDeath(mName, mService);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final ComponentName mName;</span><br><span class="line">          final IBinder mService;</span><br><span class="line">          final int mCommand;</span><br><span class="line">          final boolean mDead;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里判断了命令状态，调用ServiceDispatcher的doConnected方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public void doConnected(ComponentName name, IBinder service, boolean dead) &#123;</span><br><span class="line">        ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">        ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mForgotten) &#123;</span><br><span class="line">                // We unbound before receiving the connection; ignore</span><br><span class="line">                // any connection received.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            old = mActiveConnections.get(name);</span><br><span class="line">            if (old != null &amp;&amp; old.binder == service) &#123;</span><br><span class="line">                // Huh, already have this one.  Oh well!</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (service != null) &#123;</span><br><span class="line">                // A new service is being connected... set it all up.</span><br><span class="line">                info = new ConnectionInfo();</span><br><span class="line">                info.binder = service;</span><br><span class="line">                info.deathMonitor = new DeathMonitor(name, service);</span><br><span class="line">                try &#123;</span><br><span class="line">                    service.linkToDeath(info.deathMonitor, 0);</span><br><span class="line">                    mActiveConnections.put(name, info);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    // This service was dead before we got it...  just</span><br><span class="line">                    // don&apos;t do anything with it.</span><br><span class="line">                    mActiveConnections.remove(name);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // The named service is being disconnected... clean up.</span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (old != null) &#123;</span><br><span class="line">                old.binder.unlinkToDeath(old.deathMonitor, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If there was an old service, it is now disconnected.</span><br><span class="line">        if (old != null) &#123;</span><br><span class="line">            mConnection.onServiceDisconnected(name);</span><br><span class="line">        &#125;</span><br><span class="line">        if (dead) &#123;</span><br><span class="line">            mConnection.onBindingDied(name);</span><br><span class="line">        &#125;</span><br><span class="line">        // If there is a new service, it is now connected.</span><br><span class="line">        if (service != null) &#123;</span><br><span class="line">            mConnection.onServiceConnected(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为ServiceDispatcher内部保存了客户端ServiceConnection对象，因此可以很方便的调用ServiceConnection对象的onServiceConnected方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (service != null) &#123;</span><br><span class="line">    mConnection.onServiceConnected(name, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onServiceConnected就是连接成功的回调<br>这里Service的绑定过程就解决了<br>这里的UML图<br><img src="Service绑定流程图.svg" alt="Alt text" title="Service 启动,最好下载下来看"></p>
<h1 id="BroadcastReceiver的工作过程"><a href="#BroadcastReceiver的工作过程" class="headerlink" title="BroadcastReceiver的工作过程"></a>BroadcastReceiver的工作过程</h1><p>这一章节介绍BroadCastReceiver的工作过程，主要包含两个方面，一个是广播注册过程，一个是广播发送和接受过程。这里先简单回顾一下广播的使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestBR extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在清单文件中注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.TestBR&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>看一下动态注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter=new IntentFilter();</span><br><span class="line">   filter.addAction(&quot;ccc&quot;);</span><br><span class="line">   registerReceiver(new TestBR(),filter);</span><br></pre></td></tr></table></figure></p>
<p>发送广播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent =new Intent();</span><br><span class="line">intent.setAction(&quot;ccc&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>
<h2 id="广播的注册过程"><a href="#广播的注册过程" class="headerlink" title="广播的注册过程"></a>广播的注册过程</h2><p>广播的注册分为动态注册和静态注册，其中静态注册的广播在应用安装的时候由系统自动完成，具体的说是由PMS（PackageManagerService）来完成整个注册过程的，除了广播以外，其他三大组件也是在应用安装时由PMS解析并注册的。这里只研究动态注册。</p>
<p>看下面动态注册的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter=new IntentFilter();</span><br><span class="line">   filter.addAction(&quot;ccc&quot;);</span><br><span class="line">   registerReceiver(new TestBR(),filter);</span><br></pre></td></tr></table></figure></p>
<p>可以发现，<code>registerReceiver</code>方法方法调用了其实是调用了ContextWrapper的，我们直接跳转到ContextWrapper，看一下他的<code>registerReceiver</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(</span><br><span class="line">    BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">    return mBase.registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mBase是ContextImpl,看一下他的<code>registerReceiver</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    return registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了自己的<code>registerReceiverInternal</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context, int flags) &#123;</span><br><span class="line">    IIntentReceiver rd = null;</span><br><span class="line">    if (receiver != null) &#123;</span><br><span class="line">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        final Intent intent = ActivityManager.getService().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                broadcastPermission, userId, flags);</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        return intent;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下这个关键的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">    receiver, context, scheduler,</span><br><span class="line">    mMainThread.getInstrumentation(), true);</span><br></pre></td></tr></table></figure></p>
<p>这里是不是很熟悉，service的bind过程也使用了类似的方式<br>mPackageInfo是一个LoadedApk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,</span><br><span class="line">        Context context, Handler handler,</span><br><span class="line">        Instrumentation instrumentation, boolean registered) &#123;</span><br><span class="line">    synchronized (mReceivers) &#123;</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = null;</span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;</span><br><span class="line">        if (registered) &#123;</span><br><span class="line">            map = mReceivers.get(context);</span><br><span class="line">            if (map != null) &#123;</span><br><span class="line">                rd = map.get(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rd == null) &#123;</span><br><span class="line">            rd = new ReceiverDispatcher(r, context, handler,</span><br><span class="line">                    instrumentation, registered);</span><br><span class="line">            if (registered) &#123;</span><br><span class="line">                if (map == null) &#123;</span><br><span class="line">                    map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                    mReceivers.put(context, map);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(r, rd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        rd.mForgotten = false;</span><br><span class="line">        return rd.getIIntentReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下ReceiverDispatcher的构造方法,如果猜的没错，这里应该有一个ReceiverDispatcher的内部类InnerReceiver，并且继承IIntentReceiver.Stub，和service的绑定过程一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">calss ReceiverDispatcher&#123;</span><br><span class="line">  ...</span><br><span class="line">ReceiverDispatcher(BroadcastReceiver receiver, Context context,</span><br><span class="line">        Handler activityThread, Instrumentation instrumentation,</span><br><span class="line">        boolean registered) &#123;</span><br><span class="line">    if (activityThread == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Handler must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIIntentReceiver = new InnerReceiver(this, !registered);</span><br><span class="line">    mReceiver = receiver;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mActivityThread = activityThread;</span><br><span class="line">    mInstrumentation = instrumentation;</span><br><span class="line">    mRegistered = registered;</span><br><span class="line">    mLocation = new IntentReceiverLeaked(null);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final static class InnerReceiver extends IIntentReceiver.Stub &#123;</span><br><span class="line">    final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</span><br><span class="line">    final LoadedApk.ReceiverDispatcher mStrongRef;</span><br><span class="line"></span><br><span class="line">    InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;</span><br><span class="line">        mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</span><br><span class="line">        mStrongRef = strong ? rd : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里列出了一些关键的代码，其余部分省略。看到和Service的bind过程一样<br>然后第二步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Intent intent = ActivityManager.getService().registerReceiver(</span><br><span class="line">        mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">        broadcastPermission, userId, flags);</span><br></pre></td></tr></table></figure></p>
<p>得到AMS并调用他的registerReceiver方法<br>来看一下这个registerReceiver方法<br>方法比较长，看重点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">            IIntentReceiver receiver, IntentFilter filter, String permission, int userId,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">              if (rl == null) &#123;</span><br><span class="line">                  rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                          userId, receiver);</span><br><span class="line">                &#125;</span><br><span class="line">                mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">                BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                        permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">                rl.add(bf);</span><br><span class="line">                if (!bf.debugCheck()) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                mReceiverResolver.addFilter(bf);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会把远程的InnerReceiver对象以及IntentFilter对象存储起来</p>
<h2 id="广播的发送和接受过程"><a href="#广播的发送和接受过程" class="headerlink" title="广播的发送和接受过程"></a>广播的发送和接受过程</h2><p>通过上面分析发现，广播的注册过程还是比较简单的,下面来分析一下广播的发送和接受过程。当通过send方法来发送广播时，AMS会查找出匹配的广播接受者，并将广播发送给他们处理。广播发送分为几种类型：普通广播、有序广播、粘性广播。有序广播和粘性广播与普通广播相比具有不同的特性，但是他们发送过程和接受过程是类似的，因此这里只分析普通广播。<br>广播的发送和接收，其本质是一个过程的两个阶段。这里从广播的发送说起，广播的发送任然起始于ContextWrapper的sendBroadcast方法，之所以不是Context，那是因为Context的sendBroadcast是一个抽象方法。具体的做法都是在ContextImpl中处理的<br>看一下调用<br>首先是在activity中发送广播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent =new Intent();</span><br><span class="line">intent.setAction(&quot;ccc&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>
<p>这时会调用ContextWrapper的<code>sendBroadcast</code>方法，接着调用ContextImp的<code>sendBroadcast</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(this);</span><br><span class="line">        ActivityManager.getService().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>sendBroadcast</code>基本没有干什么事情，他是通过AMS来发送广播的，我们看一下AMS的<code>broadcastIntent</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final int broadcastIntent(IApplicationThread caller,</span><br><span class="line">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">        int resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">        String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">        boolean serialized, boolean sticky, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line"></span><br><span class="line">        final ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        int res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != null ? callerApp.info.packageName : null,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个方法内部又调用了<code>broadcastIntentLocked</code>方法,来看一下这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final int broadcastIntentLocked(ProcessRecord callerApp,</span><br><span class="line">        String callerPackage, Intent intent, String resolvedType,</span><br><span class="line">        IIntentReceiver resultTo, int resultCode, String resultData,</span><br><span class="line">        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">        boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;</span><br><span class="line">          ...</span><br><span class="line">          intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line">          ...</span><br><span class="line">          if (!ordered &amp;&amp; NR &gt; 0) &#123;</span><br><span class="line">              // If we are not serializing this broadcast, then send the</span><br><span class="line">              // registered receivers separately so they don&apos;t wait for the</span><br><span class="line">              // components to be launched.</span><br><span class="line">              if (isCallerSystem) &#123;</span><br><span class="line">                  checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                          isProtectedBroadcast, registeredReceivers);</span><br><span class="line">              &#125;</span><br><span class="line">              final BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">              BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                      callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                      requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">                      resultCode, resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line">              if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</span><br><span class="line">              final boolean replaced = replacePending</span><br><span class="line">                      &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null);</span><br><span class="line">              // Note: We assume resultTo is null for non-ordered broadcasts.</span><br><span class="line">              if (!replaced) &#123;</span><br><span class="line">                  queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">                  queue.scheduleBroadcastsLocked();</span><br><span class="line">              &#125;</span><br><span class="line">              registeredReceivers = null;</span><br><span class="line">              NR = 0;</span><br><span class="line">          &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>方法比较长，列出重要的步骤<br>这里拆解分析一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br></pre></td></tr></table></figure>
<p>这个表示在Android5.0中，默认情况下广播不会发送给已经停止的应用，其实不仅仅是Android5.0，从Android3.1开始广播已经具有这种特性了。这时因为系统在Android3.1中添加了两个Intent标记位：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES,用来控制广播是否要对处于停滞状态的应用其作用<br>FLAG_INCLUDE_STOPPED_PACKAGES：表示对已经停止的应用奏效，就是说广播会发给已经停止的应用<br>FLAG_EXCLUDE_STOPPED_PACKAGES：表示对已经停止的应用不奏效，就是说广播会不发给已经停止的应用<br>从Android3.1开始，系统为所有的广播默认添加了FLAG_EXCLUDE_STOPPED_PACKAGES标致，这样做是为了防止广播无意间或者在不必要的时候调起已经停止运行的应用。如果的确需要调起未启动的应用，只需要在Intent添加FLAG_INCLUDE_STOPPED_PACKAGES这个flag就可以了。当这两者同时存在时，FLAG_INCLUDE_STOPPED_PACKAGES的优先级高于FLAG_EXCLUDE_STOPPED_PACKAGES.<br>在<code>broadcastIntentLocked</code>的内部，会根据intent-filter查找出匹配的广播接受者并经过一系列条件的过滤，最终将满足条件的广播接受者添加到BroadcastQueue中，接着BroadcastQueue就会将广播发送给相应的广播接受者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (!ordered &amp;&amp; NR &gt; 0) &#123;</span><br><span class="line">    // If we are not serializing this broadcast, then send the</span><br><span class="line">    // registered receivers separately so they don&apos;t wait for the</span><br><span class="line">    // components to be launched.</span><br><span class="line">    if (isCallerSystem) &#123;</span><br><span class="line">        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                isProtectedBroadcast, registeredReceivers);</span><br><span class="line">    &#125;</span><br><span class="line">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">            resultCode, resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</span><br><span class="line">    final boolean replaced = replacePending</span><br><span class="line">            &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null);</span><br><span class="line">    // Note: We assume resultTo is null for non-ordered broadcasts.</span><br><span class="line">    if (!replaced) &#123;</span><br><span class="line">        queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    registeredReceivers = null;</span><br><span class="line">    NR = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在<code>broadcastIntentLocked</code>方法中调用了BroadcastQueue的<code>scheduleBroadcastsLocked</code>方法,看一下这个方法做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">            + mQueueName + &quot;]: current=&quot;</span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    if (mBroadcastsScheduled) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到他并没有立即发送广播，而是使用了Handler发送了一条消息BROADCAST_INTENT_MSG<br>看一下这个handler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">    public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">        super(looper, null, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                if (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);</span><br><span class="line">                processNextBroadcast(true);</span><br><span class="line">            &#125; break;</span><br><span class="line">            case BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实是调用了<code>processNextBroadcast</code>这个方法,看一下这个方法。这个方法有点长，选重要的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">    r = mParallelBroadcasts.remove(0);</span><br><span class="line">    r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">    r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">            createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">            System.identityHashCode(r));</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">            createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">            System.identityHashCode(r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int N = r.receivers.size();</span><br><span class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</span><br><span class="line">            + mQueueName + &quot;] &quot; + r);</span><br><span class="line">    for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">        Object target = r.receivers.get(i);</span><br><span class="line">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</span><br><span class="line">                + target + &quot;: &quot; + r);</span><br><span class="line">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">    &#125;</span><br><span class="line">    addBroadcastToHistoryLocked(r);</span><br><span class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</span><br><span class="line">            + mQueueName + &quot;] &quot; + r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会遍历mParallelBroadcasts并将其中的广播发送给他们所有的接受者，具体发送过程是通过<code>deliverToRegisteredReceiverLocked</code>方法来发送的，<br>这个方法比较长，看关键的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">        new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">        r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">        Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</span><br><span class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">    if (app != null) &#123;</span><br><span class="line">        if (app.thread != null) &#123;</span><br><span class="line">            // If we have an app thread, do the call through that so it is</span><br><span class="line">            // correctly ordered with other one-way calls.</span><br><span class="line">            try &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">            // TODO: Uncomment this when (b/28322359) is fixed and we aren&apos;t getting</span><br><span class="line">            // DeadObjectException when the process isn&apos;t actually dead.</span><br><span class="line">            //&#125; catch (DeadObjectException ex) &#123;</span><br><span class="line">            // Failed to call into the process.  It&apos;s dying so just let it die and move on.</span><br><span class="line">            //    throw ex;</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                // Failed to call into the process. It&apos;s either dying or wedged. Kill it gently.</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Can&apos;t deliver broadcast to &quot; + app.processName</span><br><span class="line">                            + &quot; (pid &quot; + app.pid + &quot;). Crashing it.&quot;);</span><br><span class="line">                    app.scheduleCrash(&quot;can&apos;t deliver broadcast&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Application has died. Receiver doesn&apos;t exist.</span><br><span class="line">            throw new RemoteException(&quot;app.thread must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br></pre></td></tr></table></figure></p>
<p>是不是有点印象，</p>
<p>看一下ActivityThread中的这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">        int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的receiver是一个InnerReceiver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    final LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">        rd = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rd = mDispatcher.get();</span><br><span class="line">    &#125;</span><br><span class="line">    if (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        int seq = intent.getIntExtra(&quot;seq&quot;, -1);</span><br><span class="line">        Slog.i(ActivityThread.TAG, &quot;Receiving broadcast &quot; + intent.getAction()</span><br><span class="line">                + &quot; seq=&quot; + seq + &quot; to &quot; + (rd != null ? rd.mReceiver : null));</span><br><span class="line">    &#125;</span><br><span class="line">    if (rd != null) &#123;</span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // The activity manager dispatched a broadcast to a registered</span><br><span class="line">        // receiver in this process, but before it could be delivered the</span><br><span class="line">        // receiver was unregistered.  Acknowledge the broadcast on its</span><br><span class="line">        // behalf so that the system&apos;s broadcast sequence can continue.</span><br><span class="line">        if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                &quot;Finishing broadcast to unregistered receiver&quot;);</span><br><span class="line">        IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (extras != null) &#123;</span><br><span class="line">                extras.setAllowFds(false);</span><br><span class="line">            &#125;</span><br><span class="line">            mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他有调用了ReceiverDispatcher的<code>performReceive</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    final Args args = new Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">            int seq = intent.getIntExtra(&quot;seq&quot;, -1);</span><br><span class="line">            Slog.i(ActivityThread.TAG, &quot;Enqueueing broadcast &quot; + intent.getAction()</span><br><span class="line">                    + &quot; seq=&quot; + seq + &quot; to &quot; + mReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (intent == null || !mActivityThread.post(args.getRunnable())) &#123;</span><br><span class="line">        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    &quot;Finishing sync broadcast to &quot; + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先调用<code>!mActivityThread.post(args.getRunnable())</code><br>看一下<code>getRunnable</code>的内容,里面有一段关键的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = mReceiver.getClass().getClassLoader();</span><br><span class="line">intent.setExtrasClassLoader(cl);</span><br><span class="line">intent.prepareToEnterProcess();</span><br><span class="line">setExtrasClassLoader(cl);</span><br><span class="line">receiver.setPendingResult(this);</span><br><span class="line">receiver.onReceive(mContext, intent);</span><br></pre></td></tr></table></figure></p>
<p>这里调用了<code>onReceive</code>这个方法,mActivityThread这个是一个Handler，就是ActivityThread内部的那个H</p>
<p>这里会创建一个args对象，然后<code>sendFinished</code>是在Args父类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final class Args extends BroadcastReceiver.PendingResult &#123;</span><br><span class="line">  public void sendFinished(IActivityManager am) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          if (mFinished) &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;Broadcast already finished&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          mFinished = true;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              if (mResultExtras != null) &#123;</span><br><span class="line">                  mResultExtras.setAllowFds(false);</span><br><span class="line">              &#125;</span><br><span class="line">              if (mOrderedHint) &#123;</span><br><span class="line">                  am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,</span><br><span class="line">                          mAbortBroadcast, mFlags);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // This broadcast was sent to a component; it is not ordered,</span><br><span class="line">                  // but we still need to tell the activity manager we are done.</span><br><span class="line">                  am.finishReceiver(mToken, 0, null, null, false, mFlags);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (RemoteException ex) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>am是AMS,最后调用了AMS的<code>finishReceiver</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void finishReceiver(IBinder who, int resultCode, String resultData,</span><br><span class="line">        Bundle resultExtras, boolean resultAbort, int flags) &#123;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Finish receiver: &quot; + who);</span><br><span class="line"></span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (resultExtras != null &amp;&amp; resultExtras.hasFileDescriptors()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Bundle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean doNext = false;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0</span><br><span class="line">                    ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">            r = queue.getMatchingOrderedReceiver(who);</span><br><span class="line">            if (r != null) &#123;</span><br><span class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</span><br><span class="line">                    resultData, resultExtras, resultAbort, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (doNext) &#123;</span><br><span class="line">            r.queue.processNextBroadcast(false);</span><br><span class="line">        &#125;</span><br><span class="line">        trimApplications();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面有是一个循环</p>
<h1 id="ContentProvider工作过程"><a href="#ContentProvider工作过程" class="headerlink" title="ContentProvider工作过程"></a>ContentProvider工作过程</h1><p>ContentProvide的使用方法在第二章的时候已经介绍过了，这里简单说明一下，ContentProvide是一种内容共享型组件，他通过Binder向其他组件乃至其他应用提供数据，当ContentProvide所在的进程启动时，ContentProvide会同时启动并被发布到AMS(ActivityManagerService)中，需要注意的是，这个时候ContentProvide的onCreate要先于Application的onCreate而执行，这在四大组件中是一个少有的现象。</p>
<p>当一个应用启动时，入口方法为ActivityThread的main方法，main方法是一个静态方法，在main方法中会创建ActivityThread的实例并创建主线程的消息队列，然后在ActivityThread的attach方法中会远程调用AMS的attachApplication方法并将ApplicationThread对象提供给AMS。ApplicationThread是一个Binder对象，他的Binder接口是IApplicationThread，他主要用于ActivityThread和AMS之间的通信，这一点在前面已经多次提及到。在AMS的AttachApplication方法中，会调用ApplicationThread的bindApplication方法，注意这个过程同样是在跨进程完成的，bindApplicationThread的逻辑会经过ActivityThread中的Handler m切换到ActivityThread中去执行，具体的方法是handleBindApplication。在handleBindApplication方法中，ActivityThread会创建Application对象并加载ContentProvide。需要注意的是ActivityThread会先加载Application对象并加载ContentProvide，然后在调用Application的onCreate方法。</p>
<p><img src="startContentProvide.png" alt="Alt text" title="ContentProvide启动过程"></p>
<p>这就是ContentProvide的启动过程，ContentProvide启动后，外界就可以通过他所提供的增删改查接口操作ContentProvide中的数据源，即insert、delete、update和query四个方法。这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvide，只能通过AMS根据URI来获取对应的ContentProvide的Binder接口IContentProvide，然后通过IContentProvide来访问ContentProvide中的数据源。</p>
<p>一般来说，ContentProvide都应该是单实例。ContentProvide到底是不是单实例，这是由他的android:multiprocess属性来决定，当android:multiprocess为false时，ContentProvide时单实例，这也是默认值；当android:multiprocess为true时，ContentProvide为多实例，这个时候在每个调用者的进程中都存在一个ContentProvide对象，由于在实际的开发中，并未发现多个实例的ContentProvide的具体使用场景，官方文档中的解释是这样可以避免进程间通信的开销，但是这实际上在开发中任然缺少使用价值。因此，我们可以简单认为ContentProvide都是单实例的。下面分析单实例的ContentProvide的启动过程。</p>
<p>访问ContentProvide需要通过ContentResolver，ContentResolver是一个抽象类，通过Context的getContentResolver方法获取的实际上是ApplicationContentResolver对象，ApplicationContentResolver类继承了ContentResolver并实现了ContentResolver中的抽象方法，当ContentProvide所在的进程未启动时，第一次访问它就会触发ContentProvide的创建，当然这也伴随着ContentProvide所在进程的启动。通过ContentProvide的四个方法的任何一个都可以触发ContentResolver的启动过程，这里选择query方法。</p>
<p>ContentProvide的query方法中，首先会获取IContentProvide对象，不管是通过acquireUnstableProvide方法还是直接通过acquireProvide方法，他的本质都是一样的，最终都是通过acquireProvide方法来获取ContentProvide。下面是ApplicationContentResolver的acquireProvide方法的具体实现：<br>ApplicationContentResolver这个是ContextImpl的内部类，找了半天…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected IContentProvider acquireProvider(Context context, String auth) &#123;</span><br><span class="line">    return mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了ActivityThread的<code>acquireProvide</code>方法,ActivityThread的<code>acquireProvide</code>方法源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final IContentProvider acquireProvider(</span><br><span class="line">        Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        return provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // There is a possible race here.  Another thread may try to acquire</span><br><span class="line">    // the same provider at the same time.  When this happens, we want to ensure</span><br><span class="line">    // that the first one wins.</span><br><span class="line">    // Note that we cannot hold the lock while acquiring and installing the</span><br><span class="line">    // provider since it might take a long time to run and it could also potentially</span><br><span class="line">    // be re-entrant in the case where the provider is in the same process.</span><br><span class="line">    ContentProviderHolder holder = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Install provider will increment the reference count for us, and break</span><br><span class="line">    // any ties in the race.</span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            true /*noisy*/, holder.noReleaseNeeded, stable);</span><br><span class="line">    return holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码首先会从ActivityThread中查找是否已经存在目标ContentProvide了，如果存在就直接返回。ActivityThread中通过mProviderMap来存储已经启动的ContentProvider对象，mProviderMap的申明如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</span><br><span class="line">    = new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure></p>
<p>如果目前ContentProvider没有启动，那么就发送一个进程间请求给AMS让其启动目标ContentProvider，最后在通过<code>installProvider</code>方法来修改引用计数。那么AMS是如何启动ContentProvider的呢？我们知道，ContentProvider被启动时会伴随着进程的启动，在AMS中，首先会启动ContentProvider所在的进程，然后在启动ContentProvider。启动进程是由AMS的startProcessLocked方法来完成的，其内部主要是通过Process的start方法来完成一个新进程的启动，新进程启动后其入口方法为ActivityThread的main方法，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    // disable it here, but selectively enable it later (via</span><br><span class="line">    // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">    CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    // Set the reporter for event logging in libcore</span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个java程序都是从main开始的，main就隐藏在这里。可以看到ActivityThread的main方法是一个静态方法，在他的内部首先会创建ActivityThread的实例并调用attach方法来进行一系列初始化，接着就开始进行消息循环了。ActivityThread的attach方法会将ApplicationThread对象通过AMS的attachApplication方法跨进程传递给AMS，最终AMS会完成ContentProvide的创建过程。<br>attach方法比较长，看一下关键点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">  ...</span><br><span class="line">  final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">  try &#123;</span><br><span class="line">      mgr.attachApplication(mAppThread);</span><br><span class="line">  &#125; catch (RemoteException ex) &#123;</span><br><span class="line">      throw ex.rethrowFromSystemServer();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AMS的AttachApplication方法做了什么操作呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        int callingPid = Binder.getCallingPid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了<code>attachApplicationLocked</code>,这里找重点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">        int pid) &#123;</span><br><span class="line">                      ...</span><br><span class="line">          thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                  app.instr.mClass,</span><br><span class="line">                  profilerInfo, app.instr.mArguments,</span><br><span class="line">                  app.instr.mWatcher,</span><br><span class="line">                  app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                  mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                  isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                  new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                  getCommonServicesLocked(app.isolated),</span><br><span class="line">                  mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                  buildSerial);</span><br><span class="line">                  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在内部调用了ActivityThread的<code>bindApplication</code>，我们跟着看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">        IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">        IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">        boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">        boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">        String buildSerial) &#123;</span><br><span class="line"></span><br><span class="line">    if (services != null) &#123;</span><br><span class="line">        // Setup the service cache in the ServiceManager</span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providers;</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    data.buildSerial = buildSerial;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里发送了一个Handler消息BIND_APPLICATION，看一下他做了什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case BIND_APPLICATION:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">    handleBindApplication(data);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure></p>
<p>其实是调用<code>handleBindApplication</code>这个方法。这个方法还是很长，分析一下重点</p>
<p>这个方法就涉及到了Application的创建以及ContentProvide的创建，可以分为如下四个步骤</p>
<ol>
<li>创建ContextImpl和Instrumentation<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">...</span><br><span class="line">try &#123;</span><br><span class="line">    final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">    mInstrumentation = (Instrumentation)</span><br><span class="line">        cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    throw new RuntimeException(</span><br><span class="line">        &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">        + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final ComponentName component = new ComponentName(ii.packageName, ii.name);</span><br><span class="line">mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">        data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ContextImpl这个就是activity内部包装的东西</p>
<ol start="2">
<li>创建Application对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">mInitialApplication = app;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动当前进程的ContentProvicer并调用其onCreate方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (!data.restrictedBackupMode) &#123;</span><br><span class="line">    if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">        installContentProviders(app, data.providers);</span><br><span class="line">        // For process that contains content providers, we want to</span><br><span class="line">        // ensure that the JIT is enabled &quot;at some point&quot;.</span><br><span class="line">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下<code>installContentProviders</code>这个方法干了什么？<br>installContentProviders完成了ContentProvider的启动工作，他的实现如下所示。首先会遍历当前进程的ProviderInfo的列表并一一调用installProvider方法来启动他们，接着讲已经启动的ContentProvider发布到AMS中，AMS会把他们存储在ProviderMap中，这样，外来调用者就可以直接从AMS中获取ContentProvider了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void installContentProviders(</span><br><span class="line">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</span><br><span class="line">    final ArrayList&lt;ContentProviderHolder&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        if (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = new StringBuilder(128);</span><br><span class="line">            buf.append(&quot;Pub &quot;);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(&quot;: &quot;);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">            Log.i(TAG, buf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ContentProviderHolder cph = installProvider(context, null, cpi,</span><br><span class="line">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</span><br><span class="line">        if (cph != null) &#123;</span><br><span class="line">            cph.noReleaseNeeded = true;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ActivityManager.getService().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>installProvider</code>方法中有下面一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    final java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">    localProvider = (ContentProvider)cl.</span><br><span class="line">        loadClass(info.name).newInstance();</span><br><span class="line">    provider = localProvider.getIContentProvider();</span><br><span class="line">    if (provider == null) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Failed to instantiate class &quot; +</span><br><span class="line">              info.name + &quot; from sourceDir &quot; +</span><br><span class="line">              info.applicationInfo.sourceDir);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">        TAG, &quot;Instantiating local provider &quot; + info.name);</span><br><span class="line">    // XXX Need to create the correct context for this provider.</span><br><span class="line">    localProvider.attachInfo(c, info);</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，除了完成ContentProvider对象的创建，还会通过COntentProvider的<code>attachInfo</code>方法来调用他的onCreate方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123;</span><br><span class="line">    mNoPerms = testing;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Only allow it to be set once, so after the content service gives</span><br><span class="line">     * this to us clients can&apos;t change it.</span><br><span class="line">     */</span><br><span class="line">    if (mContext == null) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        if (context != null) &#123;</span><br><span class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</span><br><span class="line">                    Context.APP_OPS_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mMyUid = Process.myUid();</span><br><span class="line">        if (info != null) &#123;</span><br><span class="line">            setReadPermission(info.readPermission);</span><br><span class="line">            setWritePermission(info.writePermission);</span><br><span class="line">            setPathPermissions(info.pathPermissions);</span><br><span class="line">            mExported = info.exported;</span><br><span class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0;</span><br><span class="line">            setAuthorities(info.authority);</span><br><span class="line">        &#125;</span><br><span class="line">        ContentProvider.this.onCreate();// 这里调用了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了<code>ContentProvider.this.onCreate();</code>这个调用了onCreate方法</p>
<ol start="4">
<li>调用Application的onCreate方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>经过上面的四个步骤，ContentProvider已经成功启动，并且其所在的进程Application也已经启动，这意味着ContentProvide所在的进程已经完成了整个启动的过程，然后应用就可以通过AMS来访问这个ContentProvider了。拿到了ContentProvider以后，就可以通过他所提供的接口方法来访问它了。需要注意的是，这里的ContentProvider并不是原始的ContentProvider，而是ContentProvider的Binder对象IContentProvider，其中ContentProvider的具体实现是ContentProviderNative和ContentProvider.Transport，其中ContentProvider.transport继承了ContentProviderNative。这里任然选择query方法，首先其他应用会通过AMS获取ContentProvider的binder对象IContentProvider，而IContentProvider的实现者实际上是ContentProvider.Transport。因此其他应用调用IContentProvider的query方法最终会调用ContentProvider.Transport的query方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Cursor query(String callingPkg, Uri uri, @Nullable String[] projection,</span><br><span class="line">        @Nullable Bundle queryArgs, @Nullable ICancellationSignal cancellationSignal) &#123;</span><br><span class="line">    validateIncomingUri(uri);</span><br><span class="line">    uri = maybeGetUriWithoutUserId(uri);</span><br><span class="line">    if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        if (projection != null) &#123;</span><br><span class="line">            return new MatrixCursor(projection, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cursor cursor = ContentProvider.this.query(</span><br><span class="line">                uri, projection, queryArgs,</span><br><span class="line">                CancellationSignal.fromTransport(cancellationSignal));</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Return an empty cursor for all columns.</span><br><span class="line">        return new MatrixCursor(cursor.getColumnNames(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    final String original = setCallingPackage(callingPkg);</span><br><span class="line">    try &#123;</span><br><span class="line">        return ContentProvider.this.query(</span><br><span class="line">                uri, projection, queryArgs,</span><br><span class="line">                CancellationSignal.fromTransport(cancellationSignal));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        setCallingPackage(original);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很显然ContentProvider.Transpor的query里面调用了ContentProvider的query方法，query方法的执行结果在通过Binder返回给调用者，这样一来整个调用过程就完成了。处理query方法，insert、delete、update方法也是同样的</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/进阶/" rel="tag"># 进阶</a>
          
            <a href="/tags/Android开发艺术探索/" rel="tag"># Android开发艺术探索</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/android/Android开发艺术探索_第八章 理解Windows和WindowsManager/" rel="next" title="Android开发艺术探索 第八章 理解Windows和WindowsManager">
                <i class="fa fa-chevron-left"></i> Android开发艺术探索 第八章 理解Windows和WindowsManager
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android/Android开发艺术探索_第十章 Android的消息机制/" rel="prev" title="Android开发艺术探索 第十章 Android的消息机制">
                Android开发艺术探索 第十章 Android的消息机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Groot</p>
              <p class="site-description motion-element" itemprop="description">尽信书则不如无书</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#四大组件的运行状态"><span class="nav-number">1.</span> <span class="nav-text">四大组件的运行状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Activity的工作流程"><span class="nav-number">2.</span> <span class="nav-text">Activity的工作流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Service-工作过程"><span class="nav-number">3.</span> <span class="nav-text">Service 工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Service的启动过程：startService过程"><span class="nav-number">3.1.</span> <span class="nav-text">Service的启动过程：startService过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service的绑定过程"><span class="nav-number">3.2.</span> <span class="nav-text">Service的绑定过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BroadcastReceiver的工作过程"><span class="nav-number">4.</span> <span class="nav-text">BroadcastReceiver的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#广播的注册过程"><span class="nav-number">4.1.</span> <span class="nav-text">广播的注册过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广播的发送和接受过程"><span class="nav-number">4.2.</span> <span class="nav-text">广播的发送和接受过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ContentProvider工作过程"><span class="nav-number">5.</span> <span class="nav-text">ContentProvider工作过程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Groot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
