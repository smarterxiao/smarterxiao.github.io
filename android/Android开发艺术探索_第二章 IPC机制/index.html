<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="进阶,Android开发艺术探索," />










<meta name="description" content="本章主要讲解Android中的IPC机制，首先介绍了Android中的多进程概念以及多进程开发模式中常见的注意事项，接着介绍Android中的许雷华机制和Binder。然后详细介绍进程间的通信方式。  Android IPC简介IPC是Inter-progress Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程，说起进程间通信，我们首先要理解">
<meta name="keywords" content="进阶,Android开发艺术探索">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索 第二章 IPC机制">
<meta property="og:url" content="http://yoursite.com/android/Android开发艺术探索_第二章 IPC机制/index.html">
<meta property="og:site_name" content="个人网站">
<meta property="og:description" content="本章主要讲解Android中的IPC机制，首先介绍了Android中的多进程概念以及多进程开发模式中常见的注意事项，接着介绍Android中的许雷华机制和Binder。然后详细介绍进程间的通信方式。  Android IPC简介IPC是Inter-progress Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程，说起进程间通信，我们首先要理解">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第二章%20IPC机制/图像1517752561.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第二章%20IPC机制/图像1517846753.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第二章%20IPC机制/device-2018-02-25-214156.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第二章%20IPC机制/图像1519566752.png">
<meta property="og:updated_time" content="2018-07-26T13:02:16.554Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索 第二章 IPC机制">
<meta name="twitter:description" content="本章主要讲解Android中的IPC机制，首先介绍了Android中的多进程概念以及多进程开发模式中常见的注意事项，接着介绍Android中的许雷华机制和Binder。然后详细介绍进程间的通信方式。  Android IPC简介IPC是Inter-progress Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程，说起进程间通信，我们首先要理解">
<meta name="twitter:image" content="http://yoursite.com/android/Android开发艺术探索_第二章%20IPC机制/图像1517752561.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/android/Android开发艺术探索_第二章 IPC机制/"/>





  <title>Android开发艺术探索 第二章 IPC机制 | 个人网站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人网站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/android/Android开发艺术探索_第二章 IPC机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Groot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人网站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索 第二章 IPC机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T17:08:21+08:00">
                2018-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本章主要讲解Android中的IPC机制，首先介绍了Android中的多进程概念以及多进程开发模式中常见的注意事项，接着介绍Android中的许雷华机制和Binder。然后详细介绍进程间的通信方式。</p>
</blockquote>
<h1 id="Android-IPC简介"><a href="#Android-IPC简介" class="headerlink" title="Android IPC简介"></a>Android IPC简介</h1><p>IPC是Inter-progress Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程，说起进程间通信，我们首先要理解，进程通信是什么，什么是线程。线程和进程是截然不同的概念。按照操作系统中的描述，线程是CPU最小的调度单元，同时线程是一种有限的系统资源。二进程一般是一个执行单元，或者可以理解为一个程序或者一个应用。一个进程可以包含多个线程，一个进程可以只包含一个主线程。在Android里面主线程也叫UI线程，在UI线程里才能操作界面元素，很多时候，一个进程中需要执行大量耗时操作的情况下，会造成ANR，这个时候就需要在子线程里面执行耗时操作。</p>
<p>IPC不是Android独有的，任何一个操作系统都需要有相应的IPC机制，Windows上面可以通过剪贴板，管道，邮槽等进行进程间通讯。Linux可以通过命名管道，共享内存，信号量来进行进程间通讯。对于Android来讲，他是基于Linux内核的移动操作系统，他的进程间通讯方式不是完全继承自Linux，而是有他自己的进程间通讯方式。在Android中有特色的进程通讯方式就是Binder，通过Binder可以轻松的实现进程间通讯。除了Binder，Android还支持Socket，通过Socket可以实现任意两个中断之间的通讯，当然同一个设备上的两个进程通过Socket通信自然也是可以的。</p>
<p>说到IPC的使用场景就必须提到多进程，只有面对多进程的情况下才需要考虑进程间通讯。有两种情况：第一种是一个应用如果由于某些原因自身需要采用多进程模式来实现。第二种是和另外一个APP实现通讯，比如通过咸鱼吊起支付宝…</p>
<h1 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h1><h2 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h2><p>通过清单文件配置来开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> package=&quot;com.smart.kaifa&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;application</span><br><span class="line">     android:allowBackup=&quot;true&quot;</span><br><span class="line">     android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">     android:label=&quot;@string/app_name&quot;</span><br><span class="line">     android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">     android:supportsRtl=&quot;true&quot;</span><br><span class="line">     android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">     &lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">         &lt;intent-filter&gt;</span><br><span class="line">             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">         &lt;/intent-filter&gt;</span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line">     &lt;activity</span><br><span class="line">         android:name=&quot;.SecondActivity&quot;</span><br><span class="line">         android:process=&quot;:remote&quot;//多进程模式</span><br><span class="line">         android:label=&quot;@string/title_activity_second&quot;</span><br><span class="line">         android:launchMode=&quot;singleTask&quot;</span><br><span class="line">         android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line">     &gt;</span><br><span class="line">     &lt;activity</span><br><span class="line">         android:process=&quot;xxx.xxx.xxx.remote&quot;</span><br><span class="line">         android:name=&quot;.ThirdActivity&quot;</span><br><span class="line">         android:label=&quot;@string/title_activity_third&quot;</span><br><span class="line">         android:launchMode=&quot;singleTask&quot;</span><br><span class="line">         android:taskAffinity=&quot;com.xiao.x&quot;//多进程模式</span><br><span class="line">         android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt;</span><br><span class="line"> &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<p>SecondActivity和ThirdActivity指定了process属性，并且他们的属性值不同，这意味着当前引用有增加了两个新的进程。假设当前应用的包名为com.xiao 那么在启动SecondActivity的时候会有一个进程com.xiao:remote 这个进程 。当ThridActivity启动时，系统也会为他单独创建一个进程xxx.xxx.xxx.remote。同时入口的MainActivity由于没有指定precess属性，那么他运行在默认进程中，默认进程名是包名。 可以通过DDMS视图查看，或者通过adb命令查看 adb shell ps</p>
<p>这里有一个注意点，SecondActivity和ThirdActivity的android：process属性分别为:remote和xxx.xxx.xxx.remote这两种方式有什么区别吗？其实有区别的，区别有两点，第一点是xxx.xxx.xxx.remote这种命名方式不会附加包名信息，但是:remote会附加包名信息。其次，以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和他跑在同一个进程中，进程命不以:开头的进程属于全局进程，可以和其他应用通过共享ShareUID方式和他跑在同一个进程中。</p>
<p>我们都知道Android系统回味每一应用分配位移的UID，只有UID相同的应用才能共享数据，这里要说明的是，两个应用可以通过ShareUID跑在同一个进程中是有要求的，需要两个应用的ShareUID相同别切具有相同的签名。这种情况下才能互相访问私有数据，比如data目录，组件信息等，可以把它理解为同一个应用的两个部分</p>
<h2 id="多进程模式的运行机制。"><a href="#多进程模式的运行机制。" class="headerlink" title="多进程模式的运行机制。"></a>多进程模式的运行机制。</h2><p>可以这么说开启多进程模式之后，各种奇怪的现象都出现了，首先static 不能共用了，因为Android中，每一个应用跑在一个虚拟机中，这个时候static是相对当前虚拟机的，所以在一个进程中的static修改是无效的。<br>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserManager&#123;</span><br><span class="line"></span><br><span class="line"> public static int sUerId=1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候在MainActivity中设置这个值为2，在SecondActivity中获取，发现值还是1 。</p>
<p>一般来讲，多进程会出现下面几个常见的问题</p>
<ul>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharedPreferences的可靠性下降</li>
<li>Application会多次创建</li>
</ul>
<p>关于第四个问题，这里说一下，每次启动一个进程，就相当于创建了一个App，所以会启动一次Application。可以试一下。<br>多进程模式实惠拥有不同的虚拟机、Application、内存空间，这个会给开发带来许多困扰的。</p>
<h1 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h1><h2 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h2><p>这个是Java提供的，这个比较简单，实现这个接口，然后设置一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class HHH implements Serializable &#123;</span><br><span class="line"></span><br><span class="line"> private static final long seriaVersionUID=12131232322332L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就可以了，seriaVersionUID一定要一样这样才能正确的反序列化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">序列化的过程是</span><br><span class="line">User user=new User();</span><br><span class="line">ObjectOutPutStream out=new ObjectOutPutStream(new FileOutputStream(&quot;xxx.xxx&quot;));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反序列化的过程是</span><br><span class="line">User user=new User();</span><br><span class="line">ObjectInPutStream in=new ObjectInPutStream(new FileInputStream(&quot;xxx.xxx&quot;));</span><br><span class="line">User user=(User)in.readObject(user);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p>这个值是完全一样的，但是不是一个对象，地址变了。<br>seriaVersionUID的作用是为了防止版本便更导致的User结构变化导致的序列化失败，如果没有指定，两边结构不一样就会出现转换失败，如果指定了，就可以很大程度上避免序列化失败的过程，另外系统的序列化和反序列化也是可以改变的，但是不建议改变</p>
<h2 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h2><p>这个是Android提供的，相对于Serializable，内存占用更小一些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Parcelable &#123;</span><br><span class="line"> public int userId;</span><br><span class="line"> public String userName;</span><br><span class="line"> public boolean isMale;</span><br><span class="line"></span><br><span class="line"> //返回当前对象的内容描述，如果含有中文描述符，返回1，否则返回0，几乎所有情况都为0</span><br><span class="line"> @Override</span><br><span class="line"> public int describeContents() &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> // 将当前对象写入许雷华结构中，其中flag标识有两种值 0或者1，为1时标识当前对象需要最为返回值返回，不能立即释放资源，几乎所有情况都为0</span><br><span class="line"> @Override</span><br><span class="line"> public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">     dest.writeInt(this.userId);</span><br><span class="line">     dest.writeString(this.userName);</span><br><span class="line">     dest.writeByte(this.isMale ? (byte) 1 : (byte) 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public User() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //从与写话后的对象中创建原始对象</span><br><span class="line"> protected User(Parcel in) &#123;</span><br><span class="line">     this.userId = in.readInt();</span><br><span class="line">     this.userName = in.readString();</span><br><span class="line">     this.isMale = in.readByte() != 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;() &#123;</span><br><span class="line">   //从序列化后的对象中创建原始对象</span><br><span class="line">     @Override</span><br><span class="line">     public User createFromParcel(Parcel source) &#123;</span><br><span class="line">         return new User(source);</span><br><span class="line">     &#125;</span><br><span class="line">     //创建指定长度的原始对象数组</span><br><span class="line">     @Override</span><br><span class="line">     public User[] newArray(int size) &#123;</span><br><span class="line">         return new User[size];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然AndroidStudio有实现这个接口的插件：Parcelable code Generator</p>
<p>如果是网络情况建议使用Serializable提高兼容性，app内部使用使用Parcelable 降低内存消耗</p>
<h2 id="binder"><a href="#binder" class="headerlink" title="binder"></a>binder</h2><p>这个是一个很深入的话题，特别复杂，这里就介绍一下Binder的使用和上层原理。</p>
<p>Binder是Android中的一个类，他实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通讯方式，Binder还可以理解为一种虚拟的物理设备，他的设备驱动是/dev/binder。该通信方式是Linux中没有的。从Android FrameWord角度来讲，Binder是ServiceManager连接各种Manager（Activity Manager 、Window Manager 等等）和相对应的ManagerService的桥梁，从Android应用层来讲，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回UI个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务器端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<p>Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，所以较为简单，无法涉及Binder的核心。而Messenger的底层其实就是AIDL，所以这里选用AIDL来分析Binder的工作机制。为了分析AIDL机制，这里要创建一个AIDL实例</p>
<p>Book.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Book implements Parcelable &#123;</span><br><span class="line"> public int bookId;</span><br><span class="line"> public String bookName;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public int describeContents() &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">     dest.writeInt(this.bookId);</span><br><span class="line">     dest.writeString(this.bookName);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public Book() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> protected Book(Parcel in) &#123;</span><br><span class="line">     this.bookId = in.readInt();</span><br><span class="line">     this.bookName = in.readString();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public Book createFromParcel(Parcel source) &#123;</span><br><span class="line">         return new Book(source);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public Book[] newArray(int size) &#123;</span><br><span class="line">         return new Book[size];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Book.aidl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Book.aidl</span><br><span class="line">package com.smart.kaifa;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>
<p>IBookManager.aidl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.smart.kaifa;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">import com.smart.kaifa.Book;</span><br><span class="line">interface IBookManager &#123;</span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  */</span><br><span class="line"> void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">         double aDouble, String aString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         List&lt;Book&gt; getBookList();</span><br><span class="line">         void addBook(in Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后系统为我们生成的IBookManager.java 文件 可以双击shift 然后搜索</p>
<p>这里先介绍一下这个类：<br>他继承IInterface接口，同时自己还是一个接口，首先声明了<code>getBookList</code>和<code>addBook</code>和<code>basicTypes</code>方法，同时声明了三个常量来标记这三个方法，方便在transact的时候确定客户端所请求的是那个方法，接着声明了一个Stub类，这是一个Binder类。当服务端和客户端属于同一个进程的时候，方法调用不会走跨进程的transact过程，而当两者位于不同的进程的时候，方法调用走transact过程，这个逻辑由Stub内部代理类Proxy来完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line">* Original file: F:\\kaifa\\app\\src\\main\\aidl\\com\\smart\\kaifa\\IBookManager.aidl</span><br><span class="line">*/</span><br><span class="line">package com.smart.kaifa;</span><br><span class="line">//继承IInterface接口</span><br><span class="line">public interface IBookManager extends android.os.IInterface</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*** Demonstrates some basic types that you can use as parameters</span><br><span class="line">    * and return values in AIDL.</span><br><span class="line">    */</span><br><span class="line">//定义这三个待实现的方法</span><br><span class="line">public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;</span><br><span class="line">public java.util.List&lt;com.smart.kaifa.Book&gt; getBookList() throws android.os.RemoteException;</span><br><span class="line">public void addBook(com.smart.kaifa.Book book) throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">/** Local-side IPC implementation stub class. */</span><br><span class="line">//这个是一个内部类Stub   继承Binder 接口并实现IBookManager这个接口，在内部类中实现</span><br><span class="line">public static abstract class Stub extends android.os.Binder implements com.smart.kaifa.IBookManager</span><br><span class="line"> &#123;</span><br><span class="line">    //这个是Binder的唯一标识，一般用当前Binder的类名标识，比如本例中的 com.smart.kaifa.IBookManager</span><br><span class="line">     private static final java.lang.String DESCRIPTOR = &quot;com.smart.kaifa.IBookManager&quot;;</span><br><span class="line">     //定义三个ID用于标记着三个方法</span><br><span class="line">     static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">     static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">     static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);</span><br><span class="line"></span><br><span class="line">       /** Construct the stub at attach it to the interface. */</span><br><span class="line"></span><br><span class="line">       //Stub的构造方法</span><br><span class="line">       public Stub()&#123;</span><br><span class="line">           this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Cast an IBinder object into an com.smart.kaifa.IBookManager interface,</span><br><span class="line">        * generating a proxy if needed.</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        //用于将服务端的Binder对象转换成客户端所需的AIDL，这种转换过程是区分进程的，如果客户端和服务端位于同一个进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy</span><br><span class="line">       public static com.smart.kaifa.IBookManager asInterface(android.os.IBinder obj)&#123;</span><br><span class="line">           if ((obj==null)) &#123;</span><br><span class="line">               return null;</span><br><span class="line">             &#125;</span><br><span class="line">         android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">         if (((iin!=null)&amp;&amp;(iin instanceof com.smart.kaifa.IBookManager))) &#123;</span><br><span class="line">             return ((com.smart.kaifa.IBookManager)iin);</span><br><span class="line">           &#125;</span><br><span class="line">           return new com.smart.kaifa.IBookManager.Stub.Proxy(obj);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //这个方法用户返回当前Binder对象</span><br><span class="line">       @Override</span><br><span class="line">       public android.os.IBinder asBinder()&#123;</span><br><span class="line">             return this;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       //这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求的时候，远程请求会通过系统底层分装后交给此方法来处理，该方法的原型是 public Boolean onTransact（int code, android.os.Parcel data, android.os.Parcel reply, int flags）</span><br><span class="line">       //服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需要的参数（如果目标方法有参数的话），然后执行目标方法，当目标方法执行完毕后，就像reply中写入返回值（如果目标方法有返回值的话）</span><br><span class="line">       //onTransacct方法执行的过程就是这样的，需要注意的是，如果此方法返回false。那么客户端的请求就会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程就可以远程调用我们的服务</span><br><span class="line">       @Override</span><br><span class="line">       public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;</span><br><span class="line">           switch (code)  &#123;</span><br><span class="line">               case INTERFACE_TRANSACTION:</span><br><span class="line">                   &#123;</span><br><span class="line">                       reply.writeString(DESCRIPTOR);</span><br><span class="line">                       return true;</span><br><span class="line">                   &#125;</span><br><span class="line">               case TRANSACTION_basicTypes:</span><br><span class="line">                   &#123;</span><br><span class="line">                       data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                       int _arg0;</span><br><span class="line">                       _arg0 = data.readInt();</span><br><span class="line">                       long _arg1;</span><br><span class="line">                       _arg1 = data.readLong();</span><br><span class="line">                       boolean _arg2;</span><br><span class="line">                       _arg2 = (0!=data.readInt());</span><br><span class="line">                       float _arg3;</span><br><span class="line">                       _arg3 = data.readFloat();</span><br><span class="line">                       double _arg4;</span><br><span class="line">                       _arg4 = data.readDouble();</span><br><span class="line">                       java.lang.String _arg5;</span><br><span class="line">                       _arg5 = data.readString();</span><br><span class="line">                       this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">                       reply.writeNoException();</span><br><span class="line">                       return true;</span><br><span class="line">                   &#125;</span><br><span class="line">              case TRANSACTION_getBookList:</span><br><span class="line">                   &#123;</span><br><span class="line">                     data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                     java.util.List&lt;com.smart.kaifa.Book&gt; _result = this.getBookList();</span><br><span class="line">                     reply.writeNoException();</span><br><span class="line">                     reply.writeTypedList(_result);</span><br><span class="line">                     return true;</span><br><span class="line">                   &#125;</span><br><span class="line">             case TRANSACTION_addBook:</span><br><span class="line">                   &#123;</span><br><span class="line">                   data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                   com.smart.kaifa.Book _arg0;</span><br><span class="line">                         if ((0!=data.readInt())) &#123;</span><br><span class="line">                               _arg0 = com.smart.kaifa.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                         &#125;else &#123;</span><br><span class="line">                               _arg0 = null;</span><br><span class="line">                         &#125;</span><br><span class="line">                   this.addBook(_arg0);</span><br><span class="line">                   reply.writeNoException();</span><br><span class="line">                   return true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           return super.onTransact(code, data, reply, flags);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //这个是一个代理类mRemote这个其实是一个Stub对象，这个是Stub的一个内部代理类</span><br><span class="line">       private static class Proxy implements com.smart.kaifa.IBookManager&#123;</span><br><span class="line">             private android.os.IBinder mRemote;</span><br><span class="line">             Proxy(android.os.IBinder remote)&#123;</span><br><span class="line">               mRemote = remote;</span><br><span class="line">             &#125;</span><br><span class="line">           @Override</span><br><span class="line">           public android.os.IBinder asBinder()&#123;</span><br><span class="line">               return mRemote;</span><br><span class="line">             &#125;</span><br><span class="line">           public java.lang.String getInterfaceDescriptor()&#123;</span><br><span class="line">                 return DESCRIPTOR;</span><br><span class="line">             &#125;</span><br><span class="line">           /**</span><br><span class="line">            * Demonstrates some basic types that you can use as parameters</span><br><span class="line">            * and return values in AIDL.</span><br><span class="line">            */</span><br><span class="line">       //这个是创建的aidl的时候自带的一个方法 ，注意这个是用android studio创建的时候 可以忽略，实现IBookManager方法</span><br><span class="line">       @Override</span><br><span class="line">       public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException&#123;</span><br><span class="line">           android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">           android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">           try &#123;</span><br><span class="line">             _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">             _data.writeInt(anInt);</span><br><span class="line">             _data.writeLong(aLong);</span><br><span class="line">             _data.writeInt(((aBoolean)?(1):(0)));</span><br><span class="line">             _data.writeFloat(aFloat);</span><br><span class="line">             _data.writeDouble(aDouble);</span><br><span class="line">             _data.writeString(aString);</span><br><span class="line">             mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);</span><br><span class="line">             _reply.readException();</span><br><span class="line">           &#125;</span><br><span class="line">           finally &#123;</span><br><span class="line">             _reply.recycle();</span><br><span class="line">             _data.recycle();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //这里是获取List集合的方法，实现IBookManager方法</span><br><span class="line">       //这个方法运行在客户端，当客户端远程调用此方法的时候，他的内部实现是这样子的：首先，创建该方法所需要输入型Parcel对象data，输出型对象parcel对象_reply和返回值对象 _result，然后把该方法的参数信息写入_data中（如果有参数的话），接着调用transact方法来发起RPC（远程过程调用）请求，同时当前线程挂起：然后服务端的onTransact方法会被调用，知道RPC过程返回后，当前线程继续执行，并从_reply中读取RPC过程返回的结果</span><br><span class="line">       @Override</span><br><span class="line">       public java.util.List&lt;com.smart.kaifa.Book&gt; getBookList() throws android.os.RemoteException&#123;</span><br><span class="line">           android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">           android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">           java.util.List&lt;com.smart.kaifa.Book&gt; _result;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">             _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">             接着调用transact方法来发起RPC（远程过程调用）请求</span><br><span class="line">             mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);</span><br><span class="line"></span><br><span class="line">             _reply.readException();</span><br><span class="line">             _result = _reply.createTypedArrayList(com.smart.kaifa.Book.CREATOR);</span><br><span class="line">           &#125;finally &#123;</span><br><span class="line">             _reply.recycle();</span><br><span class="line">             _data.recycle();</span><br><span class="line">           &#125;</span><br><span class="line">           return _result;</span><br><span class="line">         &#125;</span><br><span class="line">       //这里是addBook方法，实现IBookManager方法</span><br><span class="line">       //这个方法需要在客户端运行，它的执行过程和getBookList一样，但是没有返回值，所以不需要从_reply中读取返回值</span><br><span class="line">       @Override</span><br><span class="line">       public void addBook(com.smart.kaifa.Book book) throws android.os.RemoteException&#123;</span><br><span class="line">             android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">             android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                 _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                     if ((book!=null)) &#123;</span><br><span class="line">                     _data.writeInt(1);</span><br><span class="line">                     book.writeToParcel(_data, 0);</span><br><span class="line">                   &#125;else &#123;</span><br><span class="line">                     _data.writeInt(0);</span><br><span class="line">                   &#125;</span><br><span class="line">               mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br><span class="line">               _reply.readException();</span><br><span class="line">               &#125;finally &#123;</span><br><span class="line">               _reply.recycle();</span><br><span class="line">               _data.recycle();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的分析，可以了解了Binder的工作机制，但是还有两点需要额外说明一下：首先，当客户端发起远程请求时，由于当前线程会被挂起直到服务端进程返回数据，所以如果一个远程方法很耗时，这个时候就不能在UI线程中发起此远程请求；其次由于服务端Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采取同步的方式实现，应为他已经运行在一个线程中了。为了更好的说明Binder下面给出一个Binder的工作机制图</p>
<p><img src="图像1517752561.png" alt="Alt text" title="Binder的工作机制"></p>
<p>从上述分析过程来看，我们完全可以不提供AIDL文件即可实现Binder，之所以提供AIDL文件，是为了方便系统帮助我们生成代码，系统根据AIDL文件生成Java文件的格式是固定的，我们可以抛开AIDL文件直接写一个Binder出来。接下来就介绍如何写一个Binder出来,参考上面系统同生成的IBookManager.java这个类的代码。可以发现这个类是相当的有规律。我们可以根据这个规律实现，首先这个类分为两个部分，一个是这个类本身就继承自IInterface接口，其次它的内部由个Stub类，这个类就是个Binder，还记得我们怎么写一个Binder的服务端，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final IBookManager.Stub mBinder=new IBookManager.Stub()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">public List&lt;Book&gt; getBookList() throws RemoteException&#123;</span><br><span class="line">synchronized(mBookList)&#123;</span><br><span class="line"> return mBookList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">public void addBook(Book book) throws RemoteException&#123;</span><br><span class="line">synchronized(mBookList)&#123;</span><br><span class="line"> if(!mBookList.contains(book))</span><br><span class="line"> return mBookList.add(book);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们会实现一个创建了一个Stub对象并在内部实现IBookManager的接口方法。然后在Service的onBind中返回这个Stub对象，因此，从这一点来看，我们完全可以把Stub可以吧Stub这个类提取出来直接作为一个独立的Binder类来实现，这样IBookManager中就只剩下接口本身了，通过这种分离的方式可以让他的结构变得清晰点。<br>根据上面的思想 收订实现一个Binder可以通过如下步骤来完成</p>
<ul>
<li>声明一个AIDL性质的接口，只需要继承IInterface接口即可，IInterface接口中只有一个asBinder方法。这个接口的实现如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface IBookManager extends IInterface&#123;</span><br><span class="line"></span><br><span class="line">//这个是Binder的唯一标识，一般用当前Binder的类名标识，比如本例中的 com.smart.kaifa.IBookManager</span><br><span class="line">private static final java.lang.String DESCRIPTOR = &quot;com.smart.kaifa.IBookManager&quot;;</span><br><span class="line">//定义三个ID用于标记着三个方法</span><br><span class="line">static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);</span><br><span class="line">//定义三个抽象方法</span><br><span class="line">public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;</span><br><span class="line">public java.util.List&lt;com.smart.kaifa.Book&gt; getBookList() throws android.os.RemoteException;</span><br><span class="line">public void addBook(com.smart.kaifa.Book book) throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在接口中声明了一个Binder描述符和另外三个id，这三个id分别表示的是basicTypes、getBookList、addBook方法，这段代码原本也是系统生成的，我们仿照系统生成的规则去手写这部分代码，如果有更多的方法怎么做呢？很显然，我们要在声明一个id，然后按照固定模式声明这个新方法即可，这个比较好理解，不在多说。</p>
<ul>
<li>实现Stub类和Stub类中的Proxy代理类，这段代码我们可以自己写，但是写出来发现和系统生成的代码是一样的，因此这个Stub类我们只需要参考系统生成的代码即可，只是结构上需要做一下调整，调整后的代码如下所示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">public class BookMangerImpl extends Binder implements IBookManager&#123;</span><br><span class="line"></span><br><span class="line"> public BookManagerImpl()&#123;</span><br><span class="line">   this.attachInterface(this,DESCRIPTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //用于将服务端的Binder对象转换成客户端所需的AIDL，这种转换过程是区分进程的，如果客户端和服务端位于同一个进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy</span><br><span class="line">public static com.smart.kaifa.IBookManager asInterface(android.os.IBinder obj)&#123;</span><br><span class="line">    if ((obj==null)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">  android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">  if (((iin!=null)&amp;&amp;(iin instanceof com.smart.kaifa.IBookManager))) &#123;</span><br><span class="line">      return ((com.smart.kaifa.IBookManager)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    return new com.smart.kaifa.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个方法用户返回当前Binder对象</span><br><span class="line">@Override</span><br><span class="line">public android.os.IBinder asBinder()&#123;</span><br><span class="line">      return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求的时候，远程请求会通过系统底层分装后交给此方法来处理，该方法的原型是 public Boolean onTransact（int code, android.os.Parcel data, android.os.Parcel reply, int flags）</span><br><span class="line">//服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需要的参数（如果目标方法有参数的话），然后执行目标方法，当目标方法执行完毕后，就像reply中写入返回值（如果目标方法有返回值的话）</span><br><span class="line">//onTransacct方法执行的过程就是这样的，需要注意的是，如果此方法返回false。那么客户端的请求就会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程就可以远程调用我们的服务</span><br><span class="line">@Override</span><br><span class="line">public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;</span><br><span class="line">    switch (code)  &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION:</span><br><span class="line">            &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        case TRANSACTION_basicTypes:</span><br><span class="line">            &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                int _arg0;</span><br><span class="line">                _arg0 = data.readInt();</span><br><span class="line">                long _arg1;</span><br><span class="line">                _arg1 = data.readLong();</span><br><span class="line">                boolean _arg2;</span><br><span class="line">                _arg2 = (0!=data.readInt());</span><br><span class="line">                float _arg3;</span><br><span class="line">                _arg3 = data.readFloat();</span><br><span class="line">                double _arg4;</span><br><span class="line">                _arg4 = data.readDouble();</span><br><span class="line">                java.lang.String _arg5;</span><br><span class="line">                _arg5 = data.readString();</span><br><span class="line">                this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">       case TRANSACTION_getBookList:</span><br><span class="line">            &#123;</span><br><span class="line">              data.enforceInterface(DESCRIPTOR);</span><br><span class="line">              java.util.List&lt;com.smart.kaifa.Book&gt; _result = this.getBookList();</span><br><span class="line">              reply.writeNoException();</span><br><span class="line">              reply.writeTypedList(_result);</span><br><span class="line">              return true;</span><br><span class="line">            &#125;</span><br><span class="line">      case TRANSACTION_addBook:</span><br><span class="line">            &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            com.smart.kaifa.Book _arg0;</span><br><span class="line">                  if ((0!=data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.smart.kaifa.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                  &#125;else &#123;</span><br><span class="line">                        _arg0 = null;</span><br><span class="line">                  &#125;</span><br><span class="line">            this.addBook(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return super.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个是一个代理类mRemote这个其实是一个Stub对象，这个是Stub的一个内部代理类</span><br><span class="line">private static class Proxy implements com.smart.kaifa.IBookManager&#123;</span><br><span class="line">      private android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public android.os.IBinder asBinder()&#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">    public java.lang.String getInterfaceDescriptor()&#123;</span><br><span class="line">          return DESCRIPTOR;</span><br><span class="line">      &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">//这个是创建的aidl的时候自带的一个方法 ，注意这个是用android studio创建的时候 可以忽略，实现IBookManager方法</span><br><span class="line">@Override</span><br><span class="line">public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    try &#123;</span><br><span class="line">      _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">      _data.writeInt(anInt);</span><br><span class="line">      _data.writeLong(aLong);</span><br><span class="line">      _data.writeInt(((aBoolean)?(1):(0)));</span><br><span class="line">      _data.writeFloat(aFloat);</span><br><span class="line">      _data.writeDouble(aDouble);</span><br><span class="line">      _data.writeString(aString);</span><br><span class="line">      mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);</span><br><span class="line">      _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">      _reply.recycle();</span><br><span class="line">      _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里是获取List集合的方法，实现IBookManager方法</span><br><span class="line">//这个方法运行在客户端，当客户端远程调用此方法的时候，他的内部实现是这样子的：首先，创建该方法所需要输入型Parcel对象data，输出型对象parcel对象_reply和返回值对象 _result，然后把该方法的参数信息写入_data中（如果有参数的话），接着调用transact方法来发起RPC（远程过程调用）请求，同时当前线程挂起：然后服务端的onTransact方法会被调用，知道RPC过程返回后，当前线程继续执行，并从_reply中读取RPC过程返回的结果</span><br><span class="line">@Override</span><br><span class="line">public java.util.List&lt;com.smart.kaifa.Book&gt; getBookList() throws android.os.RemoteException&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    java.util.List&lt;com.smart.kaifa.Book&gt; _result;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">      接着调用transact方法来发起RPC（远程过程调用）请求</span><br><span class="line">      mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);</span><br><span class="line"></span><br><span class="line">      _reply.readException();</span><br><span class="line">      _result = _reply.createTypedArrayList(com.smart.kaifa.Book.CREATOR);</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      _reply.recycle();</span><br><span class="line">      _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    return _result;</span><br><span class="line">  &#125;</span><br><span class="line">//这里是addBook方法，实现IBookManager方法</span><br><span class="line">//这个方法需要在客户端运行，它的执行过程和getBookList一样，但是没有返回值，所以不需要从_reply中读取返回值</span><br><span class="line">@Override</span><br><span class="line">public void addBook(com.smart.kaifa.Book book) throws android.os.RemoteException&#123;</span><br><span class="line">      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">              if ((book!=null)) &#123;</span><br><span class="line">              _data.writeInt(1);</span><br><span class="line">              book.writeToParcel(_data, 0);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              _data.writeInt(0);</span><br><span class="line">            &#125;</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实理解了Binder的工作流程之后，很容易写出这样的东西.<br>现在来介绍Binder的两个非常重要的方法，linkToDeath和unlinkToDeath，我们知道，Binder运行在服务端进程，如果服务端进程由于某种原因异常终止了，这个时候客户端就会和服务端Binder连接断裂(称之为Binder死亡)，会导致我们的远程调用失败，更为关键的是，如果我们不知道Binder连接已经断裂，那么客户端的功能就会收到影响，所以Binder提供了两个方法配对，linkToDeath和unlinkToDeath，通过linkToDeath,我们可以给Binder设置一个死亡代理，当Binder死亡是，我们就会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接，那么到底如何给Binder设置死亡代理呢？<br>很简单，先声明一个DeathRecipient对象，DeathRecipient是一个接口,其内部只有一个抽象方法binderDied，我们需要实现这个方法，当Binder死亡的时候，系统就会回调binderDied方法,我们就可以移除之前绑定的binder代理并重新绑定远程服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private IBinder.DeathRecipient mDeathRecipient=new IBinder.DeathRecipient&#123;</span><br><span class="line">@override</span><br><span class="line">public void binderDied()&#123;</span><br><span class="line">if(mBookManager==null)&#123;</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line">mBookManager.asBinder().unlinkToDeath(mDeathRecipient,0);</span><br><span class="line">mBookManager=null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次，在客户端绑定远程服务成功后，给binder设置死亡代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mService=OMessageBoxManager.Stub。asInterface（binder）;</span><br><span class="line">binder.linkToDeath(mDeathRecipient,0);</span><br></pre></td></tr></table></figure></p>
<p>其中，linkToDeath的第二个阐述是标记位，我们直接设置为0就可以，经过上面两个步骤。就给我们的Bionder设置死亡代理，当Binder死亡的时候我们就可以收到通知了，另外通过Binder的方法IsBinderAlive也可以判断Binder是否死亡。<br>到这里Ipc的基础知识就介绍完毕了，下面开始进入正题。</p>
<h1 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h1><p>在上面，我们介绍了IPC的几个基础知识，序列化和BInder，现在开始分析各种跨进程通信方式，具体方式有很多，比如可以通过在Intent中附加extras来传递信息，或者通过共享文件的方式共享上布局，还可以采用BInder方式来跨进程通信，ContentProvide天生就支持跨进程访问的，因此我们也可以才采用他来进行IPC通信，当然也可以通过SOcket进行</p>
<h2 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h2><p>我们知道，四大组件中的三大组件（Activity，Service，Receiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以他可以方便的在不同的进程间传输，基于这一点，当我们在一个进程中启动另一个进程的Activity、Service、Receiver 我们可以在Bundle中附加我们需要传输给远程进程的信息，并通过Intent传递出去<br>出了直接传递数据这种典型的使用场景，还有一种特殊的使用场景，比如A进程正在进行一个计算，计算完成后他要启动B进程的一个组件并把计算结果传递给进程B，可是计算结果不支持放入Bundle中，因此无法通过Intent来传输，这个时候如果我们用其他IPC方式就会略显复杂，可以考虑如下方式，我们通过Intent启动进程B的一个service组件（比如IntentService），让Service在后台进行计算，然后计算完毕在启动B进程中真正需要启动的目标组件，由于Service也运行在B进程中，所以目标苏建就可以直接获取计算结果，这样一来就轻松解决了跨进程的问题，这种方式的和兴思想在于将原本需要在A进程的计算任务转移到B进程后台Service中去执行，这样就成功的避免了进程间通信的问题，而且只用了很小的代价</p>
<h2 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h2><p>共享文件也是一种不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据，比如A进程把文件写入文件，B进程通过读取这个文件来获取数据。我们知道，在windows上面，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读/写，而Android是基于Linux的，是的其并发读写文件可以没有限制的进行，甚至两个线程可以同时对同一个文件进行对鞋操作都是允许的，尽管这个可能出问题，通过文件交换数据很好使用，处理可以交换一些文本信息外，我们还可以序列化一个对象到文件系统中同时从另一个进程中恢复这个对象，下面就是这种方法</p>
<p>还是一开始的例子，在MainActivity的onresume中序列化一个User对象到SD卡上的一个文件里，然后在SecondActivity的onResume中反序列化，我们希望在SecondActivity中能够正确的恢复User对象的值，关键代码如下：<br>先加一下权限，这里是测试的，所以就不加了</p>
<p>MainActivity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     View viewById = findViewById(R.id.test);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     viewById.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line">             Intent intent = new Intent();</span><br><span class="line"></span><br><span class="line">             intent.setClass(MainActivity.this, SecondActivity.class);</span><br><span class="line">             startActivity(intent);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onResume() &#123;</span><br><span class="line">     super.onResume();</span><br><span class="line">     persistToFile();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onNewIntent(Intent intent) &#123;</span><br><span class="line">     super.onNewIntent(intent);</span><br><span class="line">     Log.i(&quot;哇哈哈&quot;, &quot;营养快线&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private void persistToFile() &#123;</span><br><span class="line">     Log.d(&quot;tag&quot;, &quot;哇哈哈111&quot;);</span><br><span class="line">     new Thread(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             User user = new User(1, &quot;Hello word&quot;, false);</span><br><span class="line">             File dir = new File(Environment.getExternalStorageDirectory(), &quot;smart&quot;);</span><br><span class="line">             if (!dir.exists()) &#123;</span><br><span class="line">                 dir.mkdirs();</span><br><span class="line">             &#125;</span><br><span class="line">             Log.d(&quot;tag&quot;, &quot;哇哈哈222&quot;);</span><br><span class="line">             File file = new File(dir, &quot;sss&quot;);</span><br><span class="line"></span><br><span class="line">             ObjectOutputStream objectOutputStream = null;</span><br><span class="line">             try &#123;</span><br><span class="line">                 objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">                 Log.d(&quot;tag&quot;, &quot;哇哈哈333&quot;);</span><br><span class="line">                 objectOutputStream.writeObject(user);</span><br><span class="line">                 Log.d(&quot;tag&quot;, &quot;哇哈哈444&quot;);</span><br><span class="line">             &#125; catch (Exception e) &#123;</span><br><span class="line">                 Log.d(&quot;tag&quot;, e.getMessage()+&quot;||||||&quot;);</span><br><span class="line">             &#125; finally &#123;</span><br><span class="line">                 //记得关闭</span><br><span class="line">                 if (objectOutputStream != null) &#123;</span><br><span class="line">                     try &#123;</span><br><span class="line">                         objectOutputStream.close();</span><br><span class="line">                     &#125; catch (IOException e) &#123;</span><br><span class="line">                         e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清单文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> package=&quot;com.smart.kaifa&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line"> &lt;application</span><br><span class="line">     android:allowBackup=&quot;true&quot;</span><br><span class="line">     android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">     android:label=&quot;@string/app_name&quot;</span><br><span class="line">     android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">     android:supportsRtl=&quot;true&quot;</span><br><span class="line">     android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">     &lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">         &lt;intent-filter&gt;</span><br><span class="line">             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">         &lt;/intent-filter&gt;</span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line">     &lt;activity</span><br><span class="line">         android:name=&quot;.SecondActivity&quot;</span><br><span class="line">         android:label=&quot;@string/title_activity_second&quot;</span><br><span class="line">         android:launchMode=&quot;singleTask&quot;</span><br><span class="line">         android:process=&quot;:remote&quot;</span><br><span class="line">         android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;</span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line">     &gt;</span><br><span class="line"> &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p>
<p>SecondActivity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class SecondActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     View viewById = findViewById(R.id.test);</span><br><span class="line">     viewById.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line">             Intent intent = new Intent();</span><br><span class="line">             intent.setClass(SecondActivity.this, ThirdActivity.class);</span><br><span class="line">             startActivity(intent);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onResume() &#123;</span><br><span class="line">     super.onResume();</span><br><span class="line">     recoverFromFile();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private void recoverFromFile() &#123;</span><br><span class="line">     new Thread(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             User user = null;</span><br><span class="line">             Log.d(&quot;tag&quot;, &quot;=========&quot;);</span><br><span class="line">             File cache = new File(Environment.getExternalStorageDirectory(), &quot;smart&quot;);</span><br><span class="line">             File file = new File(cache, &quot;sss&quot;);</span><br><span class="line">             Log.d(&quot;tag&quot;, &quot;=========&quot;);</span><br><span class="line">             if (file.exists()) &#123;</span><br><span class="line">                 Log.d(&quot;tag&quot;, &quot;=========&quot;);</span><br><span class="line">                 ObjectInputStream inputStream = null;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     Log.d(&quot;tag&quot;, &quot;=========&quot;);</span><br><span class="line">                     inputStream = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">                     user = (User) inputStream.readObject();</span><br><span class="line">                     Log.d(&quot;tag&quot;, user.userName+&quot;=========&quot;);</span><br><span class="line">                     final User finalUser = user;</span><br><span class="line">                     runOnUiThread(new Runnable() &#123;</span><br><span class="line">                         @Override</span><br><span class="line">                         public void run() &#123;</span><br><span class="line">                             Log.d(&quot;tag&quot;, finalUser.userName+&quot;=========&quot;);</span><br><span class="line">                             Toast.makeText(SecondActivity.this, finalUser.userName, Toast.LENGTH_LONG);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125; catch (IOException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                     Log.d(&quot;tag&quot;, e.getMessage()+&quot;=========&quot;);</span><br><span class="line">                 &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                     Log.d(&quot;tag&quot;, e.getMessage()+&quot;=========&quot;);</span><br><span class="line">                 &#125; finally &#123;</span><br><span class="line">                     if (inputStream != null) &#123;</span><br><span class="line">                         try &#123;</span><br><span class="line">                             inputStream.close();</span><br><span class="line">                         &#125; catch (IOException e) &#123;</span><br><span class="line">                             e.printStackTrace();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意一点 SecondActivity是运行在另外的一个进程中的，看日志的时候要切换一下进程。</p>
<p>可以看日志，在SecondActivity中成功的从文件恢复了之前存入对象的数据，这里只所以说内容，是因为反序列化得到对象只是在内容上和序列化之前的对象是一样的，但是他的本质是两个对象</p>
<p>通过文件共享这种方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读写是双方约定的数据格式即可。通过文件共享的方式也是有局限性的，比如并发读写的问题，想上面的那些例子，如果并发读写，那么我们读出的内容就有可能不是最新的，如果是并发写的话就更加严重了，因此我们要尽量避免并发写这种情况的操作或者使用线程同步来限制多个线程的写操作，通过上面的分析，我们可以知道，文件共享方式适合在对数据同步要求不高的进程之间进行通信，并用要妥善处理并发读写的问题。</p>
<p>当然SharedPrefences是个特例，众所周知，SharedPrefences是Android中提供的轻量级存储方案，他通过键值对的方式来存储数据，在底层实现上他采用XML文件来存储价值对，每个应用的SharedPrefences文件都可以在当前包所在的data目录下查看到。一般来说，他的目录位于/data/data/package name/shared_prefs 目录下，其中package name 表示的是当前应用的包名，从本质上来说，SharedPrefences也属于文件的一种，但是由于系统对他的读写有一定的缓存策略，记在内从重会有一份SharedPrefences文件的缓存，因此在多进程模式下，系统对他的读写就变得不可靠，当面对高并发的读写访问，sharedPrefences有很大几率会丢失数据，因此，不建议在进程通信中使用SharePrefences</p>
<h2 id="使用Messager"><a href="#使用Messager" class="headerlink" title="使用Messager"></a>使用Messager</h2><p>Messager可以翻译为心事，顾名思义，通过他可以在不同进程中传递Messager对象，在Message中放入我们需要传递的数据，就可以轻松的实现数据的进程间传递了。Messager是一种轻量级的IPC方法，他的底层实现是AIDL，为什么这么说呢，我们大致看一下Messager这个类的构造方法就明白了。<br>下面Messager的两个构造方法，从构造方法的实现上我们可以明显看出AIDL的痕迹，不管是IMessager还是Stub.asInterface，这种是用方法都表明它的底层是AIDL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Messager(Handler target)&#123;</span><br><span class="line">mTarget=target.getIMessager();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Messager(IBinder target)&#123;</span><br><span class="line">mTarget=IManager.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Messager的使用方法很简单，他对AIDL做了封装，是的我们可以更简单的进行进程间通讯，同时由于它的一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端中不存在并发执行的情景，他实现了一个Messager有如下几个步骤，分为客户端和服务端。</p>
<ol>
<li><p>服务端进程<br>首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过他来创建一个Messager对象，然后在Service的onBind中返回这个Messager对象底层的Binder即可。</p>
</li>
<li><p>客户端进程<br>客户端进程中，首先要绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messager，通过这个Messager就可以像服务端发送消息了，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一样，我们还需要创建一个Handler并创建一个新的Messager并他这个Messager对象通过Message的replyTo参数传递给服务器，服务端通过这个replyTo参数就可以回应客户端，这听起来可能还是有点抽象，下面来看两个例子</p>
</li>
</ol>
<p>清单文件,注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> package=&quot;com.smart.kaifa&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line"> &lt;application</span><br><span class="line">     android:allowBackup=&quot;true&quot;</span><br><span class="line">     android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">     android:label=&quot;@string/app_name&quot;</span><br><span class="line">     android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">     android:supportsRtl=&quot;true&quot;</span><br><span class="line">     android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">     &lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">         &lt;intent-filter&gt;</span><br><span class="line">             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">         &lt;/intent-filter&gt;</span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line">     &lt;activity</span><br><span class="line">         android:name=&quot;.SecondActivity&quot;</span><br><span class="line">         android:label=&quot;@string/title_activity_second&quot;</span><br><span class="line">         android:launchMode=&quot;singleTask&quot;</span><br><span class="line">         android:process=&quot;:remote&quot;</span><br><span class="line">         android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">     &lt;activity android:name=&quot;.MessengerActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">     &lt;service</span><br><span class="line">         android:name=&quot;.MessagerService&quot;</span><br><span class="line">         android:process=&quot;.remote&quot;&gt;&lt;/service&gt;</span><br><span class="line">     &lt;activity</span><br><span class="line">         android:name=&quot;.ThirdActivity&quot;</span><br><span class="line">         android:label=&quot;@string/title_activity_third&quot;</span><br><span class="line">         android:launchMode=&quot;singleTask&quot;</span><br><span class="line">         android:process=&quot;xxx.xxx.xxx.remote&quot;</span><br><span class="line">         android:taskAffinity=&quot;com.xiao.x&quot;</span><br><span class="line">         android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt;</span><br><span class="line"> &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p>
<p>远程服务，在其他进程中，然后在接收到消息之后打印消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MessagerService extends Service &#123;</span><br><span class="line"> private static final String TAG = &quot;MessagerService&quot;;</span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     return mMessenger.getBinder();</span><br><span class="line"> &#125;</span><br><span class="line"> private final Messenger mMessenger = new Messenger(new MessagerHandler());</span><br><span class="line"> private static class MessagerHandler extends Handler &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line"></span><br><span class="line">         switch (msg.what) &#123;</span><br><span class="line">             case 1:</span><br><span class="line">                 Bundle data = msg.getData();</span><br><span class="line">                 String key = data.getString(&quot;key&quot;);</span><br><span class="line">                 Log.i(TAG, &quot;receive msg from Client:&quot; + key);</span><br><span class="line">                 getString(&quot;msg&quot;);</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             default:</span><br><span class="line">                 super.handleMessage(msg);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     private void getString(String msg) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动服务的Activity，这个是客户端的处理，发送一个消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class MessengerActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;MessengerActivity&quot;;</span><br><span class="line"> private Messenger mService;</span><br><span class="line"> private ServiceConnection mConnection=new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">         mService=new Messenger(service);</span><br><span class="line">         Message obtain = Message.obtain(null, 1);</span><br><span class="line">         Bundle bundle=new Bundle();</span><br><span class="line">         //设置key值</span><br><span class="line">         bundle.putString(&quot;key&quot;,&quot;ad钙奶&quot;);</span><br><span class="line">         obtain.setData(bundle);</span><br><span class="line">         try &#123;</span><br><span class="line">             mService.send(obtain);</span><br><span class="line">         &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     TextView tv = findViewById(R.id.test);</span><br><span class="line">     tv.setText(&quot;点击启动服务&quot;);</span><br><span class="line">     tv.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line">             Intent intent = new Intent(MessengerActivity.this, MessagerService.class);</span><br><span class="line"></span><br><span class="line">             bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onDestroy() &#123;</span><br><span class="line">     super.onDestroy();</span><br><span class="line">     //销毁的时候记得解绑，节约资源</span><br><span class="line">     if(mConnection!=null)&#123;</span><br><span class="line">         unbindService(mConnection);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02-05 23:12:36.784 673-673/.remote I/MessagerService: receive msg from Client:ad钙奶</span><br></pre></td></tr></table></figure>
<p>通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，二Messenger和Message都实现了Parcelable接口，因此，可以跨进程传输。简单来说，Message中所支持的数据类型就是Messenger所支持的传输类型，实际上通过Messenger来传递Message，Message中能够使用的载体之后what、arg1、arg2、bundle以及replyTo。Message中的另外一个字段objectt在同一个进程中很实用，但是进程间在通信的时候。在Message中的另一个字段object在同一个进程中很实用的，但是在进程间通信的时候，在Android2.2之前object字段不支持跨进程传输，及时在2.2以后，也仅仅是实现系统提供的Parcelable接口的的对象才能通过他来传输，这就意味着我们自定义的Parcelable对象是无法通过object字段来传输。当然可以使用Bundle</p>
<p>现在在举一个例子，在收到消息之后会回复一条消息</p>
<p>服务端的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MessagerService extends Service &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;MessagerService&quot;;</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     return mMessenger.getBinder();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private final Messenger mMessenger = new Messenger(new MessagerHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private static class MessagerHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line"></span><br><span class="line">         switch (msg.what) &#123;</span><br><span class="line">             case 1:</span><br><span class="line">                 Bundle data = msg.getData();</span><br><span class="line">                 String key = data.getString(&quot;key&quot;);</span><br><span class="line">                 Log.i(TAG, &quot;receive msg from Client:&quot; + key);</span><br><span class="line">                 getString(&quot;msg&quot;);</span><br><span class="line">                 Messenger replyTo = msg.replyTo;</span><br><span class="line">                 Message message = Message.obtain(null, 2);</span><br><span class="line">                 Bundle bundle=new Bundle();</span><br><span class="line">                 bundle.putString(&quot;reply&quot;,&quot;消息已经获取到了&quot;);</span><br><span class="line">                 message.setData(bundle);</span><br><span class="line"></span><br><span class="line">                 try &#123;</span><br><span class="line">                   //通过Messenger发送值</span><br><span class="line">                     replyTo.send(message);</span><br><span class="line">                 &#125; catch (RemoteException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             default:</span><br><span class="line"></span><br><span class="line">                 super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private void getString(String msg) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端的修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class MessengerActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;MessengerActivity&quot;;</span><br><span class="line"> private Messenger mService;</span><br><span class="line"> private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">         mService = new Messenger(service);</span><br><span class="line">         Message obtain = Message.obtain(null, 1);</span><br><span class="line">         Bundle bundle = new Bundle();</span><br><span class="line">         bundle.putString(&quot;key&quot;, &quot;ad钙奶&quot;);</span><br><span class="line">         obtain.setData(bundle);</span><br><span class="line">         //将客户端需要接受的东西放入,绑定handler</span><br><span class="line">         obtain.replyTo=mGetReplyMessenger;</span><br><span class="line">         try &#123;</span><br><span class="line"></span><br><span class="line">             mService.send(obtain);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private Messenger mGetReplyMessenger = new Messenger(new MessagerHandler());</span><br><span class="line"></span><br><span class="line"> private static class MessagerHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line"></span><br><span class="line">         switch (msg.what) &#123;</span><br><span class="line">             case 2:</span><br><span class="line">                 Bundle data = msg.getData();</span><br><span class="line">                 String key = data.getString(&quot;reply&quot;);</span><br><span class="line">                 Log.i(TAG, &quot;receive msg from Service:&quot; + key);</span><br><span class="line">                 break;</span><br><span class="line">             default:</span><br><span class="line">                 super.handleMessage(msg);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private void getString(String msg) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     TextView tv = findViewById(R.id.test);</span><br><span class="line">     tv.setText(&quot;点击启动服务&quot;);</span><br><span class="line">     tv.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line">             Intent intent = new Intent(MessengerActivity.this, MessagerService.class);</span><br><span class="line">             bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @Override</span><br><span class="line"> protected void onDestroy() &#123;</span><br><span class="line">     super.onDestroy();</span><br><span class="line">     if (mConnection != null) &#123;</span><br><span class="line">         unbindService(mConnection);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一张图解，最后发现其实是在handler进行通讯了，都持有一个Handler</p>
<p><img src="图像1517846753.png" alt="Alt text" title="Messager 进程间通信图"></p>
<h2 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h2><p>通过Messager这种方式进行进程间通信的方法，可以发现，Messager是串行的方式处理客户端发来的消息的，如果大量的消息同时发送到服务端，那么使用Messager就不合适了，同时Messager的主要作用是用来传递消息，很多时候我们需要跨进程调用调用服务端的方法，所以Messenger就无法做到了。但是我们可以使用AIDL来实现跨进程的方法调用，AIDL也是Messenger的底层实现，因此Messenger本质上也是AIDL，只不过是系统做了分装而已</p>
<ol>
<li><p>服务端<br>服务端首先要创建一个Service用来监听客户端的请求，然后创建一个AIDL文件，将暴露出来给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可</p>
</li>
<li><p>客户端<br>客户端所需要做的事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功了，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。<br>上面描述的只是一个感性的过程，AIDL的时间过程远不止这么简单，接下来会对其中的细节和难点进行完整的介绍。</p>
</li>
<li><p>AIDL接口的创建<br>首先看AIDL接口的创建</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// IBookManager.aidl</span><br><span class="line">package com.smart.kaifa;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">import com.smart.kaifa.Book;</span><br><span class="line">interface IBookManager &#123;</span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  */</span><br><span class="line"> void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">         double aDouble, String aString);</span><br><span class="line">List&lt;Book&gt; getBookList();</span><br><span class="line">void addBook(in Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AIDL文件中，并不是所有的数据类型都是可以使用的，那么到底AIDL文件支持哪些数据类型呢？如下</p>
<ul>
<li>基本数据类型(int 、long、char、boolean、double)</li>
<li>String和CharSequence</li>
<li>List：只支持ArrayList，并且每个元素都必须能够被AIDL支持</li>
<li>Map：只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value</li>
<li>Parcelable:所有实现了Parcelable接口的对象</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>以上6中数据类型就是AIDL所支持的所有类型，其中自定义的Parcelable对象和AIDL对象必须要显示import进来，不管他们是否和当前的AIDL文件位于同一个包内。比如IBookManager.aidl这个文件，里面用到了Book这个类，这个类实现了Parcelable接口和IBookManager.adil这个文件，但是遵守AIDL的规范，我们任然需要显示的import进来。AIDL中会大量使用Parcelable，至于如果使用Parcelable接口来序列化对象。</p>
<p>另外一个需要注意的地方是如果AIDL文件中使用了自定义的Parcelable对象，那么必须新建一个和他同名的AIDL文件，并且什么它为Parcelable类型，在上面的IBookManager.aidl，这个时候我们必须要创建Book.aidl文件在里面添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Book.aidl</span><br><span class="line">package com.smart.kaifa;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>
<p>我们需要注意。AIDL中每个实现了Parcelable接口的类都需要按照上面那种方式去创建相对应的AIDL文件并什么那个类为Parcelable。初次之外，AIDL中处理基本数据列行，其他类型的参数必须标记上方向；in、out、inout in表示输入类型参数，out表示输出型参数，inout表示输入输出型参数，但是不能都使用inout。这个在底层是有开销的<br>为了方便AIDL开发，一般所有的AIDL相关的文件放在一个文件夹中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BookManagerService extends Service &#123;</span><br><span class="line"></span><br><span class="line"> private  static final String TAG=&quot;BMS&quot;;</span><br><span class="line"></span><br><span class="line"> private CopyOnWriteArrayList&lt;Book&gt; mBookList=new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> private Binder mBinder=new IBookManager.Stub() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public List&lt;Book&gt; getBookList() throws RemoteException &#123;</span><br><span class="line">         return mBookList;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line">         mBookList.add(book);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     return mBinder;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onCreate() &#123;</span><br><span class="line">     super.onCreate();</span><br><span class="line">     mBookList.add(new Book(1,&quot;wahaha&quot;));</span><br><span class="line">     mBookList.add(new Book(2,&quot;xiao&quot;));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个服务端Service的典型实现，首先在onCreate中初始化添加了两本图书的信息，然后创建了一个Binder对象并且在onBind中返回他，这个对象继承自IBookManager.Stub，并实现了他内部的AIDL方法。这个过程在Binder那一节已经介绍过了，这里采用了CopyOnWriteArrayList，是为了防止多个客户端访问的情景，使用CopyOnWriteArrayList实现线程同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;.BookManagerService&quot; android:process=&quot;.remote&quot;&gt;&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>客户端的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BookManagerActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;BookManagerActivity&quot;;</span><br><span class="line"></span><br><span class="line"> private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line"></span><br><span class="line">         IBookManager bookManager = IBookManager.Stub.asInterface(service) ;</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             List&lt;Book&gt; bookList = bookManager.getBookList();</span><br><span class="line">             Log.i(&quot;test&quot;,bookList.toString());</span><br><span class="line">         &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     Intent intent = new Intent(this, BookManagerService.class);</span><br><span class="line">     bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onDestroy() &#123;</span><br><span class="line">     unbindService(mConnection);</span><br><span class="line">     super.onDestroy();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以了，但是注意服务端的方法可能会很久之后才被执行，所以建议在子线程中进行操作，防止ANR</p>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Book&#123;bookId=1, bookName=&apos;wahaha&apos;&#125;, Book&#123;bookId=2, bookName=&apos;xiao&apos;&#125;]</span><br></pre></td></tr></table></figure>
<p>然后在进一步，修改服务端数据，然后在客户端在打印出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class BookManagerActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;BookManagerActivity&quot;;</span><br><span class="line"></span><br><span class="line"> private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line"></span><br><span class="line">         IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             List&lt;Book&gt; bookList = bookManager.getBookList();</span><br><span class="line">             Log.i(&quot;——----------------&quot;, bookList.toString());</span><br><span class="line">             //设置数据</span><br><span class="line">             bookManager.addBook(new Book(100, &quot;礼拜&quot;));</span><br><span class="line">             //在获取</span><br><span class="line">             bookList = bookManager.getBookList();</span><br><span class="line">             Log.i(&quot;||||||||||||&quot;, bookList.toString());</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     Intent intent = new Intent(this, BookManagerService.class);</span><br><span class="line">     bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onDestroy() &#123;</span><br><span class="line">     unbindService(mConnection);</span><br><span class="line">     super.onDestroy();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Book&#123;bookId=1, bookName=&apos;wahaha&apos;&#125;, Book&#123;bookId=2, bookName=&apos;xiao&apos;&#125;, Book&#123;bookId=100, bookName=&apos;礼拜&apos;&#125;]</span><br></pre></td></tr></table></figure>
<p>在进一步<br>这个时候有一个需求就是客户端厌倦了，想让服务端主动告知当前的书籍内容，就是一个观察者模式，这个时候就要在创建一个AIDL接口去实现<br>IOnNewBookArrivedListener 接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// IOnNewBookArrivedListener.aidl</span><br><span class="line">package com.smart.kaifa;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">import com.smart.kaifa.Book;</span><br><span class="line">interface IOnNewBookArrivedListener &#123;</span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  */</span><br><span class="line"> void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">         double aDouble, String aString);</span><br><span class="line"></span><br><span class="line"> void onNewBookArrived(in Book newBook);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新加了之后要在原先的AIDL文件中加上方法来注册Listener<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.smart.kaifa;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">import com.smart.kaifa.Book;</span><br><span class="line">interface IBookManager &#123;</span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  */</span><br><span class="line"> void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">         double aDouble, String aString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> List&lt;Book&gt; getBookList();</span><br><span class="line"> void addBook(in Book book);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> void registerListener(IOnNewBookArrivedListener listener);</span><br><span class="line"> void unregisterListener(IOnNewBookArrivedListener listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器端代码的修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public class BookManagerService extends Service &#123;</span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;BMS&quot;;</span><br><span class="line"> private AtomicBoolean atomicBoolean = new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line"> private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"> private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> private Binder mBinder = new IBookManager.Stub() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public List&lt;Book&gt; getBookList() throws RemoteException &#123;</span><br><span class="line">         return mBookList;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line">         mBookList.add(book);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;</span><br><span class="line">         //获取客户端对象</span><br><span class="line">         if (!mListenerList.contains(listener)) &#123;</span><br><span class="line">             mListenerList.add(listener);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;</span><br><span class="line">         if (mListenerList.contains(listener)) &#123;</span><br><span class="line">             mListenerList.remove(listener);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     return mBinder;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private void onNewBookArrived(Book book) &#123;</span><br><span class="line">     mBookList.add(book);</span><br><span class="line">     for (int i = 0; i &lt; mListenerList.size(); i++) &#123;</span><br><span class="line">         IOnNewBookArrivedListener iOnNewBookArrivedListener = mListenerList.get(i);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             iOnNewBookArrivedListener.onNewBookArrived(book);</span><br><span class="line">         &#125; catch (RemoteException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onCreate() &#123;</span><br><span class="line">     super.onCreate();</span><br><span class="line">     mBookList.add(new Book(1, &quot;wahaha&quot;));</span><br><span class="line">     mBookList.add(new Book(2, &quot;xiao&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     new Thread(new ServiceWorker()).start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private class ServiceWorker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         while (!atomicBoolean.get()) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">             &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             int bookId = mBookList.size() + 1;</span><br><span class="line">             Book newBook = new Book(bookId, &quot;new bool #&quot; + bookId);</span><br><span class="line">             onNewBookArrived(newBook);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BookManagerActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line"> private static final String TAG = &quot;BookManagerActivity&quot;;</span><br><span class="line"> private static final int TAG_ID = 1;</span><br><span class="line"></span><br><span class="line"> private Handler mHandler=new Handler()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line">         switch (msg.what) &#123;</span><br><span class="line">             case  1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 Log.i(TAG,&quot;receove book&quot;+msg.obj);</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             default:</span><br><span class="line">                 super.handleMessage(msg);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line"></span><br><span class="line">         bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             List&lt;Book&gt; bookList = bookManager.getBookList();</span><br><span class="line">             Log.i(&quot;——----------------&quot;, bookList.toString());</span><br><span class="line">             //设置数据</span><br><span class="line">             bookManager.addBook(new Book(100, &quot;礼拜&quot;));</span><br><span class="line">             //在获取</span><br><span class="line">             bookList = bookManager.getBookList();</span><br><span class="line">             Log.i(&quot;||||||||||||&quot;, bookList.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             bookManager.registerListener(onNewBookArrivedListener);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> private IBookManager bookManager;</span><br><span class="line"> private IOnNewBookArrivedListener onNewBookArrivedListener= new IOnNewBookArrivedListener.Stub() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onNewBookArrived(Book newBook) throws RemoteException &#123;</span><br><span class="line">         mHandler.obtainMessage(1,newBook).sendToTarget();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     Intent intent = new Intent(this, BookManagerService.class);</span><br><span class="line">     bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onDestroy() &#123;</span><br><span class="line">     if(bookManager!=null&amp;&amp;bookManager.asBinder().isBinderAlive())&#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             bookManager.unregisterListener(onNewBookArrivedListener);</span><br><span class="line">         &#125; catch (RemoteException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     unbindService(mConnection);</span><br><span class="line">     super.onDestroy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这么理解 客户端连接服务端 这个时候客户端持有一个服务端的Stub，在客户端启动服务端之后，服务端也持有一个客户端的Stub，这样就实现了双方的通信，看客户端将传递过去IOnNewBookArrivedListener.Stub()，然后服务端在绑定服务的时候传递IBookManager.Stub() 这样就互相持有对象的一个stub，这样就可以通信了。</p>
<p>但是这个时候我们关闭的时候发现并没有移除，定时器还在每隔3s传递一次数据。这个是因为虽然在移除的时候和注册的时候传递的是同一个对象，但是在服务端，获取的是不用的对象，可以理解为地址不同但是值相同的对象，所以用这种方式无法解开注册，这个时候系统为我们提供了一个跨进程删除listener的接口，RemoteCallbackList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteCallbackList&lt;E extends IInterface&gt;</span><br></pre></td></tr></table></figure>
<p>所有的AIDL接口都实现了IInterface 接口，他的工作原理很简单，他在内部有一个Map结果专门用来保存所有的AIDL回调，这个Map的key是IBinder类型，value是Callback类型，如下图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;IBander,Callback&gt; mCallbacks=new arrayMap&lt;IBander,Callback&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中Callback中分装了真正远程listener，当客户端注册listener的时候，他会把这个listener的信息存入mCallbacks中，其中key和value分别通过下面的方式获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder key=listener.asBinder();</span><br><span class="line">Callback value=new Callback(listener,cookie)</span><br></pre></td></tr></table></figure>
<p>在这个东西的底层，使用的是一个Map,虽然说多次跨进程传输客户端的同一个客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是他们底层的Binder是同一个，利用这个特性，就可以实现上面我们无法实现的功能，当客户端注册的时候，我们只要遍历服务端所有的listener，罩住那个和解除注册listener具有相同的binder对象的服务端listener并且把它删除就可以了。这个就是remoteCallBackList为我们做的事情。同时remoteCallBackList还有一个很有用的功能，就是当客户端进程终止之后，他会自动移除客户端所注册的listener，另外，remoteCallbackList内部自动实现了线程同步的功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。由此可见这个类还是很有用的。</p>
<p>RemoteCallbackLlist使用起来很简单，我们要对BookManagerService做一些修改，首先要创建一个RemoteCallbackList对象来替代之前的CopyOnWriteArrayList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private RemoteCallbackList&lt;IOnNewBookArrivedLisstener&gt; mListenerList=new remoteCallbackList&lt;IOnNewBookArrivedListener&gt;;</span><br></pre></td></tr></table></figure>
<p>然后，修改registerListener和unregisterListener这两个接口的实现，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">mListenerList.register(listener);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;</span><br><span class="line">   mListenerList.unregister(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来要修改onNewBookArrived方法，当有新书时，我们要通知所有已注册的listener，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void onNewBookArrived(Book book) &#123;</span><br><span class="line">    mBookList.add(book);</span><br><span class="line">    final int N = mListenerList.beginBroadcast();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                listener.onNewBookArrived(book);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mListenerList.finishBroadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookManagerService的修改已经修改完毕了，使用RemoteCallbackList，有一点需要注意，我们无法向操作list一样去操作他，虽然他的名字中也带有一个List，但是他并不是一个List，遍历RemoteCallbackList，必须要按照下面的方式执行，其中 <strong>beginBroadcast</strong> 和 <strong>finishBoradcask</strong> 必须要配对使用，哪怕我们仅仅要获取RemoteCallbackList中的元素个数，这是必须要注意的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int N = mListenerList.beginBroadcast();</span><br><span class="line">for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line"> IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);</span><br><span class="line"> if (listener != null) &#123;</span><br><span class="line">     // TODO</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mListenerList.finishBroadcast();</span><br></pre></td></tr></table></figure>
<p>到这里AIDL的使用方式基本已经介绍完了，但是，有几点还需要再次说明一下。我们知道，客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端的线程会挂起，这个时候如果服务端的方法执行比较耗时，就会导致客户端线程长时间阻塞在这里，而如果这个客户端的线程是UI线程的话，就会导致客户端ANR，这个要求在客户端使用子线程去访问，但是客户端的OnServiceConnected和OnServiceDisconnected方法都运行在UI线程中，所以也不可以在他们里面直接调用服务端的耗时方法，这点要注意。另外由于服务端方法本省运行在服务端的Binder线程池中，所以服务单本身就可以执行大量的耗时操作，这个时候切记不要在服务端的方法中开启线程去执行异步，除非你能明确自己在干什么。否则不建议这么做。</p>
<p>这个时候可以模拟一下服务端的方法是耗时操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public List&lt;Book&gt; getBookList() throws RemoteException &#123;</span><br><span class="line">       SystemClock.sleep(10000);</span><br><span class="line">       return mBookList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就会提示ANR。<br>要避免这样的问题，只要将调用客户端的调用放在子线程中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line"></span><br><span class="line">     bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line"></span><br><span class="line">         new Thread(new Runnable() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void run() &#123;</span><br><span class="line">                 List&lt;Book&gt; bookList = null;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     bookList = bookManager.getBookList();</span><br><span class="line">                     Log.i(&quot;——----------------&quot;, bookList.toString());</span><br><span class="line">                     //设置数据</span><br><span class="line">                     bookManager.addBook(new Book(100, &quot;礼拜&quot;));</span><br><span class="line">                     //在获取</span><br><span class="line">                     bookList = bookManager.getBookList();</span><br><span class="line">                     Log.i(&quot;||||||||||||&quot;, bookList.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                     bookManager.registerListener(onNewBookArrivedListener);</span><br><span class="line">                 &#125; catch (RemoteException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).start();</span><br><span class="line"></span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>同理，当远程服务端需要调用客户端的listener中的方法时，被调用的方法运行在Binder线程池中，只不过是客户端的线程池中，所以同样不可以在服务端中调用客户端的耗时方法，比如onNewBookArrived方法,所以要放在非UI线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void onNewBookArrived(final Book book) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">            final int N = mListenerList.beginBroadcast();</span><br><span class="line">            for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">                IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);</span><br><span class="line">                if (listener != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        listener.onNewBookArrived(book);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mListenerList.finishBroadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，由于客户端的IOnNewBookArrivedListener中的onNewBookArrived方法运行在客户端的Binder线程池中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private IOnNewBookArrivedListener onNewBookArrivedListener= new IOnNewBookArrivedListener.Stub() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onNewBookArrived(Book newBook) throws RemoteException &#123;</span><br><span class="line">     mHandler.obtainMessage(1,newBook).sendToTarget();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因此不能在这个里面执行UI操作。</p>
<p>为了程序的健壮性，我们还需要你做一件事情，Binder是可能意外死亡的，通常是服务端进程意外终止的，所以当我们需要重新连接服务。有两种方法，第一种方法是给Binder设置Deathrecipient监听，当Binder死亡的时候，我们会受到binderDied方法的回调，然后我们在binderDied重新连接远程服务。另外一种方法是在onServiceDisconnected重新连接，可以随便使用一种。区别是onServiceDisconnected在客户端的UI线程中被回调，而binderDIed在客户端的Binder线程池中被回调。也就是说在BinderDied中我们不能访问UI，这个就是区别。</p>
<p>下面就是要进行权限验证功能，防止其他人非法连接。<br>这里有两种方法。<br>第一种方法：我们可以在onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端就无法绑定服务。至于验证方式可以有多重，比如使用permission这种方式验证。不过要在清单文件中加权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission android:name=&quot;xxxx&quot; android:protectionLevel=&quot;normal&quot;&gt;&lt;/permission&gt;</span><br></pre></td></tr></table></figure>
<p>uses-permission和permission 的区别</p>
<ul>
<li><p>uses-permission是申请权限:这个常用，就不介绍了</p>
</li>
<li><p>permission是自己定义权限<br>它可以采用由 Android 定义（如 android.Manifest.permission 中所列）或由其他应用声明的任何权限。或者，它也可以定义自己的权限。新权限用 &lt; permission &gt; 元素来声明。 例如，Activity 可受到如下保护：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission android:description=&quot;string resource&quot;</span><br><span class="line">android:icon=&quot;drawable resource&quot;</span><br><span class="line">android:label=&quot;string resource&quot;</span><br><span class="line">android:name=&quot;string&quot;</span><br><span class="line">android:permissionGroup=&quot;string&quot;</span><br><span class="line">android:protectionLevel=[&quot;normal&quot; | &quot;dangerous&quot; |</span><br><span class="line">&quot;signature&quot; | &quot;signatureOrSystem&quot;] /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>android:description 对权限的描述，一般两句话，第一句描述这个权限所针对的操作，第二句话告诉用户授予APP这个权限带来的后果</p>
</li>
<li>android:icon 图片资源路径</li>
<li>android:label 对权限的一个简短描述</li>
<li>android:name 权限的唯一标识，一般都是使用包名加权限名</li>
<li>android:permissionGroup 权限所属权限组的名称</li>
<li>android:protectionLevel 权限的等级</li>
<li>normal 最低的等级，声明次权限的app，系统默认授予次权限，不会提示用户</li>
<li>dangerous 权限对应的操作有安全风险，系统在安装声明此权限的app时会提示用户</li>
<li>signature 权限声明的操作只针对使用同一个证书签名的app开放</li>
<li>signatureOrSystem 于signature 类似，只是增加了rom中自带的app的声明</li>
<li>注意：android:name属性是必须的，其他的可选，未写的系统会制定默认值</li>
</ul>
<p>简单的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest . . . &gt;</span><br><span class="line"> &lt;permission android:name=&quot;com.example.project.DEBIT_ACCT&quot; . . . /&gt;</span><br><span class="line"> &lt;uses-permission android:name=&quot;com.example.project.DEBIT_ACCT&quot; /&gt;</span><br><span class="line"> . . .</span><br><span class="line"> &lt;application . . .&gt;</span><br><span class="line">  &lt;activity android:name=&quot;com.example.project.FreneticActivity&quot;</span><br><span class="line">               android:permission=&quot;com.example.project.DEBIT_ACCT&quot;</span><br><span class="line">              . . . &gt;</span><br><span class="line">       . . .</span><br><span class="line">     &lt;/activity&gt;</span><br><span class="line"> &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<p>这样就为这个activity这个组件单独加了一个权限</p>
<p>第二种方法是：我们可以在onTransact中进行权限验证，如果验证失败，直接返回false，这样服务端就不用终止执行AIDL中的方法达到保护服务端的目的，具体的验证方式有很多，可以采用permission验证。具体实现方式和第一种是一样的，还可以采用Uid和Pid来做验证，通过getCallingUid和getCallingPid可以拿到客户端所属的Uid和Pid，通过这两个参数我们可以做一些验证工作，比如验证包名。下面就是一个demo 既验证了Permission同时也验证了包名。如果一个应用向远程调用一个服务，要使用自定义权限BOOK_Service，其次要包含包名xiao.smart</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean onTransact(int code ,Parcel data,Parcel reply,int flags) throws RemoteException&#123;</span><br><span class="line">int check=checkCallubgOrSelfPerssion(&quot;BOOK_Service&quot;);</span><br><span class="line">if(check=PackageManager.PERMISSION_DENIED)&#123;</span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br><span class="line">String packageName=null;</span><br><span class="line">String[] packages=getPackageManager().getPackageManagerforUid(getCalling_Uid);</span><br><span class="line">if(packages!=null&amp;&amp;packages.length&gt;0)&#123;</span><br><span class="line"> packageName=package[0];</span><br><span class="line">&#125;</span><br><span class="line">if(!packageName.startWith(&quot;xiao.smart&quot;))&#123;</span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br><span class="line">return super.onTransact(code,data,reply,flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用ContentProvide"><a href="#使用ContentProvide" class="headerlink" title="使用ContentProvide"></a>使用ContentProvide</h2><p>ContentProvide是Android中提供的专门用于不同应用间进行数据共享。从这一点看，他天生就适合进程间通信。和Messenger一样，ContentProvider的底层实现同样也是Binder，由此可见，Binder在Android系统中是多么重要。<br>我们无需关心底层细节即可轻松实现IPC，ContentProvide虽然使用起来简单，但是他的细节有很多，比如防止sql注入，权限控制等等。</p>
<p>这里只是单纯的讲解一下他的跨进程工作机制</p>
<p>系统预制了许多ContentProvide ，比如通讯录信息，日程表信息，要跨进程访问这些信息，只需要通过ContentResolver的query，update，insert和delete方法就可以。这里自定义一个ContentProvide，并演示如何在其他应用中使用contentProvide。下面要实现6个抽象方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BookProvide extends ContentProvider &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public boolean onCreate() &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;onCreate   :&quot;+Thread.currentThread().getName());</span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;query   :&quot;+Thread.currentThread().getName());</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public String getType(@NonNull Uri uri) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;getType   :&quot;+Thread.currentThread().getName());</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;insert   :&quot;+Thread.currentThread().getName());</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;delete   :&quot;+Thread.currentThread().getName());</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;update   :&quot;+Thread.currentThread().getName());</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了oncreate 运行在主线程，其他都运行在Binder线程池（这个后面讲）</p>
<p>ContentProvide主要以表格的形式组织数据，并且可以包含多个表，和数据库有点类似。除了表格形式，ContentProvide还支持文件数据，比如图片，视频等。文件数据和表格数据的结构不同，因此处理这类数据是可以在ContentProvide中返回文件的句柄给外界，让从而让文件来访问COntentProvide中的文件信息，Android提供了MediaStore功能就是文件类型的ContentProvide，详情可以参考MediaStore。另外虽然ContentProvide底层数据看起来想一个Sqlite数据库，但是ContentProvide对底层数据没有任何要求。我们既可以使用Sqlite，也可以使用普通文件。甚至可以采用内存中的一个对象进行数据存储。这一点可以在后面的章节中进行介绍。</p>
<p>在实现了那6个方法之后，我们需要在清单文件中注册，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">  android:authorities=&quot;com.xxx.xxx&quot;// ContentProvide的唯一标识</span><br><span class="line">  android:process=&quot;:provide&quot; //运行在其他进程中</span><br><span class="line">  android:permission=&quot;com.xxx&quot; //自定义权限</span><br><span class="line">  android:name=&quot;.BookProvide&quot; //名称</span><br><span class="line">  &gt;&lt;/provider&gt;</span><br></pre></td></tr></table></figure>
<p><code>android:authorities=&quot;com.xxx.xxx&quot;</code> 这个东西是唯一标识，通过这个标识，外部应用就可以访问我们的BookProvider。因此<code>android:authorities=&quot;com.xxx.xxx&quot;</code>必须是唯一的，所以建议使用包名，然后为了安全起见，给他增加了权限验证。当然还可以加入 <code>android:readPermission=&quot;xxx&quot;</code>和<code>android:writePermission=&quot;xxx&quot;</code></p>
<ul>
<li>readPermission:使用Content Provider的查询功能所必需的权限，即使用ContentProvider里的query()函数的权限；</li>
<li>writePermission：使用ContentProvider的修改功能所必须的权限，即使用ContentProvider的insert()、update()、delete()函数的权限；</li>
<li>permission：客户端读、写 Content Provider 中的数据所必需的权限名称。 本属性为一次性设置读和写权限提供了快捷途径。 不过，readPermission和writePermission属性优先于本设置。 如果同时设置了readPermission属性，则其将控制对 Content Provider 的读取。 如果设置了writePermission属性，则其也将控制对 Content Provider 数据的修改。也就是说如果只设置permission权限，那么拥有这个权限的应用就可以实现对这里的ContentProvider进行读写；如果同时设置了permission和readPermission那么具有readPermission权限的应用才可以读，拥有permission权限的才能写！也就是说只拥有permission权限是不能读的，因为readPermission的优先级要高于permission；如果同时设置了readPermission、writePermission、permission那么permission就无效了。</li>
</ul>
<p>注册了ContentProvide之后就可以在外部应用中访问它了，为了方便，其实是偷懒，就在同一个app中进行，不过开两个进程</p>
<p>加入自定义权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;com.xxx&quot;/&gt;</span><br><span class="line">&lt;permission</span><br><span class="line">  android:name=&quot;com.xxx&quot;</span><br><span class="line">  android:label=&quot;provider pomission&quot;</span><br><span class="line">  android:protectionLevel=&quot;normal&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;</span><br></pre></td></tr></table></figure></p>
<p>//看一下不同的线程信息 是放在Binder线程池中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02-23 23:39:34.130 8865-8865/? I/test: onCreate   :main</span><br><span class="line">02-23 23:39:34.136 8865-8878/? I/test: query   :Binder:8865_2</span><br><span class="line">02-23 23:39:34.138 8865-8877/? I/test: query   :Binder:8865_1</span><br><span class="line">02-23 23:39:34.139 8865-8878/? I/test: query   :Binder:8865_2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ProvideActivity extends Activity &#123;</span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_provide);</span><br><span class="line">     Button query = findViewById(R.id.button);</span><br><span class="line">     Button add = findViewById(R.id.button4);</span><br><span class="line">     Button delete = findViewById(R.id.button2);</span><br><span class="line">     Button update = findViewById(R.id.button3);</span><br><span class="line">     Button start = findViewById(R.id.button5);</span><br><span class="line">     query.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     delete.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     update.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     add.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     start.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onClick(View v) &#123;</span><br><span class="line">           // 请求</span><br><span class="line">             Uri url = Uri.parse(&quot;content://com.xxx.xxx&quot;);</span><br><span class="line"></span><br><span class="line">             getContentResolver().query(url, null, null, null, null);</span><br><span class="line">             getContentResolver().query(url, null, null, null, null);</span><br><span class="line">             getContentResolver().query(url, null, null, null, null);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activity 布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line"> xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line"> xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line"> android:layout_width=&quot;match_parent&quot;</span><br><span class="line"> android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:text=&quot;query&quot;</span><br><span class="line">     tools:layout_editor_absoluteX=&quot;0dp&quot;</span><br><span class="line">     tools:layout_editor_absoluteY=&quot;2dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button2&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginTop=&quot;8dp&quot;</span><br><span class="line">     android:text=&quot;delete&quot;</span><br><span class="line">     app:layout_constraintTop_toBottomOf=&quot;@+id/button&quot;</span><br><span class="line">     tools:layout_editor_absoluteX=&quot;0dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button3&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginTop=&quot;8dp&quot;</span><br><span class="line">     android:text=&quot;update&quot;</span><br><span class="line">     app:layout_constraintTop_toBottomOf=&quot;@+id/button2&quot;</span><br><span class="line">     tools:layout_editor_absoluteX=&quot;0dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button4&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginTop=&quot;8dp&quot;</span><br><span class="line">     android:text=&quot;add&quot;</span><br><span class="line">     app:layout_constraintTop_toBottomOf=&quot;@+id/button3&quot;</span><br><span class="line">     tools:layout_editor_absoluteX=&quot;0dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button5&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginTop=&quot;8dp&quot;</span><br><span class="line">     android:text=&quot;start&quot;</span><br><span class="line">     app:layout_constraintTop_toBottomOf=&quot;@+id/button4&quot;</span><br><span class="line">     tools:layout_editor_absoluteX=&quot;0dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;TextView</span><br><span class="line">     android:id=&quot;@+id/textView&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:text=&quot;Button&quot;</span><br><span class="line">     tools:layout_editor_absoluteX=&quot;335dp&quot;</span><br><span class="line">     tools:layout_editor_absoluteY=&quot;313dp&quot; /&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在这个demo已经跑通了<br>然后进一步完善</p>
<p>首先创建一个数据库的操作类,使用android 提供的SQLiteOpenHelper</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class DbOpenHelper extends SQLiteOpenHelper &#123;</span><br><span class="line"> private static final String DB_NAME = &quot;book_provide.db&quot;;</span><br><span class="line"> public static final String BOOK_NAME = &quot;book&quot;;</span><br><span class="line"> public static final String USER_NAME = &quot;user&quot;;</span><br><span class="line"> private static final int DB_VERSION = 1;</span><br><span class="line"> //创建表的语句</span><br><span class="line"> private String CREATE_BOOK_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot; + BOOK_NAME + &quot; ( _id INTEGER PRIMARY KEY, &quot; + &quot;name TEXT)&quot;;</span><br><span class="line"> private String CREATE_USER_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot; + USER_NAME + &quot; ( _id INTEGER PRIMARY KEY, &quot; + &quot;name TEXT,&quot; + &quot;sex INT)&quot;;</span><br><span class="line"> public DbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123;</span><br><span class="line">     super(context, name, factory, version);</span><br><span class="line"> &#125;</span><br><span class="line"> public DbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) &#123;</span><br><span class="line">     super(context, name, factory, version, errorHandler);</span><br><span class="line"> &#125;</span><br><span class="line"> public DbOpenHelper(Context context) &#123;</span><br><span class="line">     super(context, DB_NAME, null, DB_VERSION);</span><br><span class="line"> &#125;</span><br><span class="line"> @Override</span><br><span class="line"> public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">     db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">     db.execSQL(CREATE_USER_TABLE);</span><br><span class="line"> &#125;</span><br><span class="line"> @Override</span><br><span class="line"> public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在ContentProvide中使用sql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public class BookProvide extends ContentProvider &#123;</span><br><span class="line"> private static final String TAG = &quot;BookProvide&quot;;</span><br><span class="line"> private static final String AUTHORITY = &quot;com.xxx.xxx&quot;;</span><br><span class="line"> private static final Uri BOOK_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book&quot;);</span><br><span class="line"> private static final Uri USER_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/user&quot;);</span><br><span class="line"> public static final int book_uri_code = 0;</span><br><span class="line"> public static final int user_uri_code = 1;</span><br><span class="line"> private static final UriMatcher sUriMathcer = new UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"> static &#123;</span><br><span class="line">     sUriMathcer.addURI(AUTHORITY, &quot;book&quot;, book_uri_code);</span><br><span class="line">     sUriMathcer.addURI(AUTHORITY, &quot;user&quot;, user_uri_code);</span><br><span class="line"> &#125;</span><br><span class="line"> private Context mContext;</span><br><span class="line"> private SQLiteDatabase mDb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 初始化并模拟数据</span><br><span class="line">  */</span><br><span class="line"> private void initProvideDate() &#123;</span><br><span class="line">     mDb = new DbOpenHelper(mContext).getWritableDatabase();</span><br><span class="line">     mDb.execSQL(&quot;delete from &quot; + DbOpenHelper.BOOK_NAME);</span><br><span class="line">     mDb.execSQL(&quot;delete from &quot; + DbOpenHelper.USER_NAME);</span><br><span class="line">     mDb.execSQL(&quot;insert into  book values(3,&apos;Android&apos;);&quot;);</span><br><span class="line">     mDb.execSQL(&quot;insert into  book values(4,&apos;IOS&apos;);&quot;);</span><br><span class="line">     mDb.execSQL(&quot;insert into  book values(5,&apos;HTML5&apos;);&quot;);</span><br><span class="line">     mDb.execSQL(&quot;insert into  user values(1,&apos;jake&apos;,1);&quot;);</span><br><span class="line">     mDb.execSQL(&quot;insert into  user values(2,&apos;jasmine&apos;,0);&quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private String getTableName(Uri uri) &#123;</span><br><span class="line">     String tableName = null;</span><br><span class="line">     switch (sUriMathcer.match(uri)) &#123;</span><br><span class="line">         case book_uri_code:</span><br><span class="line">             tableName = DbOpenHelper.BOOK_NAME;</span><br><span class="line">             break;</span><br><span class="line">         case user_uri_code:</span><br><span class="line">             tableName = DbOpenHelper.USER_NAME;</span><br><span class="line">             break;</span><br><span class="line">         default:</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line">     return tableName;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public boolean onCreate() &#123;</span><br><span class="line">     //这个是放在主线程的 要注意</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;onCreate   :&quot; + Thread.currentThread().getName());</span><br><span class="line">     mContext = getContext();</span><br><span class="line">     initProvideDate();</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;query   :&quot; + Thread.currentThread().getName());</span><br><span class="line">     String table = getTableName(uri);</span><br><span class="line">     if (table == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Unsupported URI :&quot; + uri);</span><br><span class="line">     &#125;</span><br><span class="line">     return mDb.query(table, projection, selection, selectionArgs, null, null, sortOrder, null);</span><br><span class="line"> &#125;</span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public String getType(@NonNull Uri uri) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;getType   :&quot; + Thread.currentThread().getName());</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;insert   :&quot; + Thread.currentThread().getName());</span><br><span class="line">     String table = getTableName(uri);</span><br><span class="line">     if (table == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Unsupported URI :&quot; + uri);</span><br><span class="line">     &#125;</span><br><span class="line">     mDb.insert(table, null, values);</span><br><span class="line">     return uri;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;delete   :&quot; + Thread.currentThread().getName());</span><br><span class="line">     String table = getTableName(uri);</span><br><span class="line">     if (table == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Unsupported URI :&quot; + uri);</span><br><span class="line">     &#125;</span><br><span class="line">     int count = mDb.delete(table, selection, selectionArgs);</span><br><span class="line">     if (count &gt; 0) &#123;</span><br><span class="line">         getContext().getContentResolver().notifyChange(uri, null);</span><br><span class="line">     &#125;</span><br><span class="line">     return count;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">     Log.i(&quot;test&quot;, &quot;update   :&quot; + Thread.currentThread().getName());</span><br><span class="line">     String table = getTableName(uri);</span><br><span class="line">     if (table == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Unsupported URI :&quot; + uri);</span><br><span class="line">     &#125;</span><br><span class="line">     int row = mDb.update(table, values, selection, selectionArgs);</span><br><span class="line">     if (row &gt; 0) &#123;</span><br><span class="line">         getContext().getContentResolver().notifyChange(uri, null);</span><br><span class="line">     &#125;</span><br><span class="line">     return row;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在activity中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ProvideActivity extends Activity &#123;</span><br><span class="line"> private Uri url;</span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_provide);</span><br><span class="line">     url = Uri.parse(&quot;content://com.xxx.xxx/book&quot;);</span><br><span class="line">     ContentValues values = new ContentValues();</span><br><span class="line">     values.put(&quot;_id&quot;, 6);</span><br><span class="line">     values.put(&quot;name&quot;, &quot;程序设计的艺术&quot;);</span><br><span class="line">     getContentResolver().insert(url, values);</span><br><span class="line">     Cursor query1 = getContentResolver().query(url, new String[]&#123;&quot;_id&quot;, &quot;name&quot;&#125;, null, null, null);</span><br><span class="line">     while (query1.moveToNext()) &#123;</span><br><span class="line">         Book book = new Book();</span><br><span class="line">         book.bookId = query1.getInt(0);</span><br><span class="line">         book.bookName = query1.getString(1);</span><br><span class="line">         Log.i(&quot;test&quot;, &quot;query book :&quot; + book.toString());</span><br><span class="line">     &#125;</span><br><span class="line">     query1.close();</span><br><span class="line">     url = Uri.parse(&quot;content://com.xxx.xxx/user&quot;);</span><br><span class="line">     Cursor query = getContentResolver().query(url, new String[]&#123;&quot;_id&quot;, &quot;name&quot;, &quot;sex&quot;&#125;, null, null, null);</span><br><span class="line">     while (query.moveToNext()) &#123;</span><br><span class="line">         User user = new User();</span><br><span class="line">         user.userId = query.getInt(0);</span><br><span class="line">         user.userName = query.getString(1);</span><br><span class="line">         Log.i(&quot;test&quot;, &quot;query user :&quot; + user.toString());</span><br><span class="line">     &#125;</span><br><span class="line">     query.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">02-25 16:13:51.708 29236-29236/com.smart.kaifa I/test: query book :Book&#123;bookId=3, bookName=&apos;Android&apos;&#125;</span><br><span class="line">02-25 16:13:51.708 29236-29236/com.smart.kaifa I/test: query book :Book&#123;bookId=4, bookName=&apos;IOS&apos;&#125;</span><br><span class="line">02-25 16:13:51.708 29236-29236/com.smart.kaifa I/test: query book :Book&#123;bookId=5, bookName=&apos;HTML5&apos;&#125;</span><br><span class="line">02-25 16:13:51.708 29236-29236/com.smart.kaifa I/test: query book :Book&#123;bookId=6, bookName=&apos;程序设计的艺术&apos;&#125;</span><br><span class="line">02-25 16:13:51.728 29236-29236/com.smart.kaifa I/test: query user :User&#123;userId=1, userName=&apos;jake&apos;, isMale=false&#125;</span><br><span class="line">02-25 16:13:51.728 29236-29236/com.smart.kaifa I/test: query user :User&#123;userId=2, userName=&apos;jasmine&apos;, isMale=false&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个注意点，因为ContentProvide的增删改查方法都是放在Binder线程池中的，因此在做的时候要注意线程同步，如果是同一个SqliteDatebase，可以正确应对并发的问题，但是如果是有多个SqliteDatebase这个时候并发就会有问题。</p>
<h2 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h2><p>socket分为两种，TCP和UDP</p>
<ul>
<li>TCP是安全的，应为他在通信的时候有一个三次握手的机制，确定目的地址存在且可以通信的情况下，他才会进行通信</li>
<li>UDP是不安全的，他不管目的地址是否存在，把数据直接发送。<br>这里演示一个聊天室的应用，</li>
</ul>
<p>要使用网络通信，首先要添加网络通信的权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;&gt;&lt;/uses-permission&gt;</span><br></pre></td></tr></table></figure>
<p>其次不能在主线程中访问网络，会抛出如下异常，android.os.NetworkOnMainThreadException<br>这个程序比较简单，首先在一个远程服务创建一个TCP服务，然后在主界面中连接TCP服务，连接上之后就可以给服务端发送消息，为了更好的展示Socket工作机制，在服务端做了处理，可以多个客户端连接。</p>
<p>先看一下服务端的设计</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public class SocketService extends Service &#123;</span><br><span class="line"></span><br><span class="line"> private boolean mIsServiceDestoryed = false;</span><br><span class="line"></span><br><span class="line"> private String[] mDefinedMessages = new String[]&#123;&quot;你好&quot;, &quot;你叫什么名字啊&quot;, &quot;今天天气不错呦&quot;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onCreate() &#123;</span><br><span class="line">     super.onCreate();</span><br><span class="line">     new Thread(new TcpServer()).start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class TcpServer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         ServerSocket serverSocket = null;</span><br><span class="line">         try &#123;</span><br><span class="line">             serverSocket = new ServerSocket(8688);</span><br><span class="line"></span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         while (!mIsServiceDestoryed) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 //接受客户端请求</span><br><span class="line">                 final Socket socket = serverSocket.accept();</span><br><span class="line">                 Log.i(&quot;test&quot;, &quot;accept&quot;);</span><br><span class="line">                 new Thread() &#123;</span><br><span class="line">                     @Override</span><br><span class="line">                     public void run() &#123;</span><br><span class="line">                         try &#123;</span><br><span class="line">                             responseClient(socket);</span><br><span class="line">                         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;.start();</span><br><span class="line"></span><br><span class="line">             &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private void responseClient(Socket client) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">     BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())), true);</span><br><span class="line"></span><br><span class="line">     out.print(&quot;欢迎来到聊天室&quot;);</span><br><span class="line"></span><br><span class="line">     while (!mIsServiceDestoryed) &#123;</span><br><span class="line">         String str = in.readLine();</span><br><span class="line">         Log.i(&quot;client :&quot;, &quot;&quot; + str);</span><br><span class="line">         if (str == null) &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">         int i = new Random().nextInt(mDefinedMessages.length);</span><br><span class="line">         String msg = mDefinedMessages[i];</span><br><span class="line">         out.println(msg);</span><br><span class="line">         Log.i(&quot;send :&quot;, msg);</span><br><span class="line">         out.close();</span><br><span class="line">         in.close();</span><br><span class="line">         client.close();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清单文件配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">     android:name=&quot;.SocketService&quot;</span><br><span class="line">     android:process=&quot;:xxxxx&quot;&gt;&lt;/service&gt;</span><br><span class="line"></span><br><span class="line"> &lt;activity android:name=&quot;.SocketActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &lt;intent-filter&gt;</span><br><span class="line">         &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">         &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">     &lt;/intent-filter&gt;</span><br><span class="line"> &lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>
<p>客户端的UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line"> xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> android:layout_width=&quot;match_parent&quot;</span><br><span class="line"> android:orientation=&quot;vertical&quot;</span><br><span class="line"> android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;EditText</span><br><span class="line">     android:id=&quot;@+id/edit&quot;</span><br><span class="line">     android:hint=&quot;@string/app_name&quot;</span><br><span class="line">     android:layout_width=&quot;match_parent&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;TextView</span><br><span class="line">     android:id=&quot;@+id/text&quot;</span><br><span class="line">     android:background=&quot;#00ffff&quot;</span><br><span class="line">     android:text=&quot; &quot;</span><br><span class="line">     android:layout_width=&quot;match_parent&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/botton&quot;</span><br><span class="line">     android:text=&quot;发送&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>客户端的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">public class SocketActivity extends Activity implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line"> private static final int MESSAGE_RECEIVE_NEW_MSG = 1;</span><br><span class="line"> private static final int MESSAGE_SOCKET_CONNECTED = 2;</span><br><span class="line"> private Button mSendButton;</span><br><span class="line"> private TextView mMessageTextView;</span><br><span class="line"> private EditText mMessageEditText;</span><br><span class="line"></span><br><span class="line"> private PrintWriter mPrintWriter;</span><br><span class="line"></span><br><span class="line"> private Socket mClientSocket;</span><br><span class="line"></span><br><span class="line"> private Handler mHandler = new Handler() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line">         switch (msg.what) &#123;</span><br><span class="line">             case MESSAGE_RECEIVE_NEW_MSG:</span><br><span class="line">                 mMessageTextView.setText(mMessageTextView.getText() + (String) msg.obj);</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             case MESSAGE_SOCKET_CONNECTED:</span><br><span class="line">                 mSendButton.setEnabled(true);</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             default:</span><br><span class="line">                 break;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         super.handleMessage(msg);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">     setContentView(R.layout.activity_socket);</span><br><span class="line"></span><br><span class="line">     mMessageTextView = findViewById(R.id.text);</span><br><span class="line">     mMessageEditText = findViewById(R.id.edit);</span><br><span class="line">     mSendButton = findViewById(R.id.botton);</span><br><span class="line"></span><br><span class="line">     Intent service = new Intent(this, SocketService.class);</span><br><span class="line">     startService(service);</span><br><span class="line"></span><br><span class="line">     new Thread(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">           //连接远程服务器</span><br><span class="line">             connectTcpService();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"></span><br><span class="line">     mSendButton.setOnClickListener(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onDestroy() &#123;</span><br><span class="line"></span><br><span class="line">     if (mClientSocket != null) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             mClientSocket.shutdownInput();</span><br><span class="line">             mClientSocket.close();</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     super.onDestroy();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private void connectTcpService() &#123;</span><br><span class="line"></span><br><span class="line">     Socket socket = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     while (socket == null) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             socket = new Socket(&quot;localhost&quot;, 8688);</span><br><span class="line">             mClientSocket = socket;</span><br><span class="line">             mPrintWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);</span><br><span class="line">             mHandler.sendEmptyMessage(MESSAGE_SOCKET_CONNECTED);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">             //开启一个死循环监听服务端的返回，有消息就通过handler发送</span><br><span class="line">             while (!SocketActivity.this.isFinishing()) &#123;</span><br><span class="line">                 String message = br.readLine();</span><br><span class="line">                 Log.i(&quot;test&quot;, &quot;&quot; + message);</span><br><span class="line">                 if (message != null) &#123;</span><br><span class="line">                     String time = formateDateTime(System.currentTimeMillis());</span><br><span class="line">                     final String showedMsg = &quot;server &quot; + time + &quot; : &quot; + message;</span><br><span class="line">                     mHandler.obtainMessage(MESSAGE_RECEIVE_NEW_MSG, showedMsg).sendToTarget();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             Log.i(&quot;test&quot;, &quot;quit...&quot;);</span><br><span class="line">             mPrintWriter.close();</span><br><span class="line">             br.close();</span><br><span class="line">             socket.close();</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onClick(final View v) &#123;</span><br><span class="line"></span><br><span class="line">     new Thread(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             if (v == mSendButton) &#123;</span><br><span class="line">                 final String msg = mMessageEditText.getText().toString();</span><br><span class="line">                 if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter != null) &#123;</span><br><span class="line">                     mPrintWriter.println(msg);</span><br><span class="line">                     mMessageEditText.setText(&quot;&quot;);</span><br><span class="line">                     String time = formateDateTime(System.currentTimeMillis());</span><br><span class="line">                     final String showMsg = &quot;self  &quot; + time + &quot;:&quot; + msg + &quot;\n&quot;;</span><br><span class="line">                     runOnUiThread(new Runnable() &#123;</span><br><span class="line">                         @Override</span><br><span class="line">                         public void run() &#123;</span><br><span class="line">                             mMessageTextView.setText(mMessageTextView.getText() + showMsg);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 格式化时间</span><br><span class="line"> private String formateDateTime(long time) &#123;</span><br><span class="line"></span><br><span class="line">     return new SimpleDateFormat(&quot;(HH:mm:ss)&quot;).format(new Date(time));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="device-2018-02-25-214156.png" alt="Alt text" title="socket 聊天室截图"></p>
<h1 id="Binder-连接池"><a href="#Binder-连接池" class="headerlink" title="Binder 连接池"></a>Binder 连接池</h1><p>这里有一个点，就是现在有100个业务需要使用AIDL来进行通信，那么我们应该怎么处理呢，创建100个Service吗？所以这里就需要减少Service的使用，将他尽量放在一个Service中进行处理。</p>
<p>在这种模式下，整个工作机制是这样的：每个业务模块创建自己的AIDL接口并实现此接口。这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后像Service端提供自己唯一标识和其对应的Binder对象。对于服务端来讲，只需要一个Service就可以了，服务端提供一个queryBinder接口，这个接口更具业务模块特征来返回相应的Binder给她们。不同的业务模块拿到所需要的Binder对象后就可以远程调用方法了。由此可见Binder连接池的主要作用是将每个业务模块的Binder请求统一转发到远程服务中执行了。从而避免重复重复创建Service的过程。她的工作原理如下</p>
<p><img src="图像1519566752.png" alt="Alt text" title="binder 连接池"></p>
<p>下面来写一个demo来展示一下<br>ISecurityCenter 是一个通用的接口提供加密功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ISecurityCenter &#123;</span><br><span class="line"> String encrypt(String content);</span><br><span class="line"> String decrypt(String password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ISecurityCenter 存根的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class SecurityCenterImpl extends ISecurityCenter.Stub &#123;</span><br><span class="line"> private static final char SECOND_CODE = &apos;^&apos;;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  *</span><br><span class="line">  * @param anInt</span><br><span class="line">  * @param aLong</span><br><span class="line">  * @param aBoolean</span><br><span class="line">  * @param aFloat</span><br><span class="line">  * @param aDouble</span><br><span class="line">  * @param aString</span><br><span class="line">  */</span><br><span class="line"> @Override</span><br><span class="line"> public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public String encrypt(String content) throws RemoteException &#123;</span><br><span class="line">     char[] chars = content.toCharArray();</span><br><span class="line">     Log.i(&quot;test&quot;,&quot;---&quot;);</span><br><span class="line">     for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">         chars[i] ^= SECOND_CODE;</span><br><span class="line">     &#125;</span><br><span class="line">     Log.i(&quot;test&quot;,&quot;---&quot;);</span><br><span class="line">     return new String(chars);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public String decrypt(String password) throws RemoteException &#123;</span><br><span class="line">     Log.i(&quot;test&quot;,&quot;--////////*****&quot;);</span><br><span class="line">     return encrypt(password);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ICompute 接口提供加法功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ICompute &#123;</span><br><span class="line"></span><br><span class="line"> int add(int a,int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ICompute 存根的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ComputeImpl extends ICompute.Stub &#123;</span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  *</span><br><span class="line">  * @param anInt</span><br><span class="line">  * @param aLong</span><br><span class="line">  * @param aBoolean</span><br><span class="line">  * @param aFloat</span><br><span class="line">  * @param aDouble</span><br><span class="line">  * @param aString</span><br><span class="line">  */</span><br><span class="line"> @Override</span><br><span class="line"> public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public int add(int a, int b) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">     return a+b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BinderPool 接口提供 用来实现线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface IBinderPool &#123;</span><br><span class="line"> /**</span><br><span class="line">  * Demonstrates some basic types that you can use as parameters</span><br><span class="line">  * and return values in AIDL.</span><br><span class="line">  */</span><br><span class="line"> void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">         double aDouble, String aString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         IBinder queryBinder(int binderCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BinderPool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">public class BinderPool &#123;</span><br><span class="line"> private static final String TAG = &quot;BinderPool&quot;;</span><br><span class="line"> public static final int BINDER_NONE = -1;</span><br><span class="line"> public static final int BINDER_COMPUTE = 0;</span><br><span class="line"> public static final int BINDER_SECURITY_CENTER = 1;</span><br><span class="line"></span><br><span class="line"> private Context mContext;</span><br><span class="line"> private IBinderPool mBinderPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void binderDied() &#123;</span><br><span class="line"></span><br><span class="line">         mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0);</span><br><span class="line">         mBinderPool = null;</span><br><span class="line">         connectBinderPoolService();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> public static class BinderPoolImpl extends IBinderPool.Stub &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      * Demonstrates some basic types that you can use as parameters</span><br><span class="line">      * and return values in AIDL.</span><br><span class="line">      *</span><br><span class="line">      * @param anInt</span><br><span class="line">      * @param aLong</span><br><span class="line">      * @param aBoolean</span><br><span class="line">      * @param aFloat</span><br><span class="line">      * @param aDouble</span><br><span class="line">      * @param aString</span><br><span class="line">      */</span><br><span class="line">     @Override</span><br><span class="line">     public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     //不同情况返回不同的存根实现</span><br><span class="line">     @Override</span><br><span class="line">     public IBinder queryBinder(int binderCode) throws RemoteException &#123;</span><br><span class="line">         IBinder binder = null;</span><br><span class="line">         switch (binderCode) &#123;</span><br><span class="line">             case BINDER_SECURITY_CENTER:</span><br><span class="line">                 binder = new SecurityCenterImpl();</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             case BINDER_COMPUTE:</span><br><span class="line">                 binder = new ComputeImpl();</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">             default:</span><br><span class="line">                 break;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         return binder;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private static volatile BinderPool sInstance;</span><br><span class="line"></span><br><span class="line"> //这个是java 1.5之后提供的一个多线程控制工具</span><br><span class="line"> private CountDownLatch mConnectBinderPoolCountDownLatch;</span><br><span class="line"> ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">         mBinderPool = IBinderPool.Stub.asInterface(service);</span><br><span class="line">         try &#123;</span><br><span class="line">             mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         mConnectBinderPoolCountDownLatch.countDown();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private BinderPool(Context context) &#123;</span><br><span class="line">     mContext = context.getApplicationContext();</span><br><span class="line">     connectBinderPoolService();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private synchronized void connectBinderPoolService() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     mConnectBinderPoolCountDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">     Intent service = new Intent(mContext, BinderPoolService.class);</span><br><span class="line"></span><br><span class="line">     mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public static BinderPool getsInstance(Context context) &#123;</span><br><span class="line">     if (sInstance == null) &#123;</span><br><span class="line">         //加入线程所 防止死锁或者重复创建</span><br><span class="line">         synchronized (BinderPool.class) &#123;</span><br><span class="line">             if (sInstance == null) &#123;</span><br><span class="line">                 sInstance = new BinderPool(context);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return sInstance;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public IBinder queryBinder(int binderCode) &#123;</span><br><span class="line"></span><br><span class="line">     IBinder binder = null;</span><br><span class="line">     try &#123;</span><br><span class="line">         if (mBinderPool != null) &#123;</span><br><span class="line">             binder = mBinderPool.queryBinder(binderCode);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return binder;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BinderPoolService<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BinderPoolService extends Service &#123;</span><br><span class="line"> private static final String TAG = &quot;BinderPoolService&quot;;</span><br><span class="line"> private Binder mBinderPool = new BinderPool.BinderPoolImpl();</span><br><span class="line"></span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     return mBinderPool;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>activity中启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void doWork() &#123;</span><br><span class="line"> Log.i(&quot;msg&quot;, &quot;点击&quot;);</span><br><span class="line"> BinderPool binderPool = BinderPool.getsInstance(this);</span><br><span class="line"> IBinder sequrityBinder = binderPool.queryBinder(BinderPool.BINDER_SECURITY_CENTER);</span><br><span class="line"> ISecurityCenter iSecurityCenter = SecurityCenterImpl.asInterface(sequrityBinder);</span><br><span class="line"> String msg = &quot;helloword-安卓&quot;;</span><br><span class="line"> Log.i(&quot;msg&quot;, msg);</span><br><span class="line"> try &#123;</span><br><span class="line">     String password = iSecurityCenter.encrypt(msg);</span><br><span class="line">     Log.i(&quot;password  &quot;, password);</span><br><span class="line">     Log.i(&quot;password  &quot;, iSecurityCenter.decrypt(password));</span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line">     Log.e(&quot;test&quot;, e.getMessage());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> IBinder computerBinder = binderPool.queryBinder(BinderPool.BINDER_COMPUTE);</span><br><span class="line"> ICompute iCompute = ComputeImpl.asInterface(computerBinder);</span><br><span class="line"> try &#123;</span><br><span class="line">     int value = iCompute.add(100, 200);</span><br><span class="line">     Log.i(&quot;100+200=   &quot;, value + &quot;&quot;);</span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/msg: helloword-安卓</span><br><span class="line">password: 6;221)1,:s寗匍</span><br><span class="line">password: helloword-安卓</span><br></pre></td></tr></table></figure></p>
<h1 id="选用合适的IPC方式"><a href="#选用合适的IPC方式" class="headerlink" title="选用合适的IPC方式"></a>选用合适的IPC方式</h1><table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td style="text-align:center">简单易用</td>
<td style="text-align:center">只能传输Bundle支持的数据类型</td>
<td style="text-align:center">四大组件间进程通讯</td>
</tr>
<tr>
<td>文件共享</td>
<td style="text-align:center">简单易用</td>
<td style="text-align:center">不适合高并发场景，并且无法做到进程间的即时通讯</td>
<td style="text-align:center">五并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td style="text-align:center">功能强大，支持一对多并发通信，支持实时通信</td>
<td style="text-align:center">使用稍微复杂，需要处理好线程同步</td>
<td style="text-align:center">一对多通信并且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td style="text-align:center">功能一般，支持一对多串行通信，支持实时通信</td>
<td style="text-align:center">不能很好的处理高并发情形，不能支持RPC，数据通过Message进行传输，因此只能传输Bundle支持的数据类型</td>
<td style="text-align:center">低并发的一对多即时通信，五RPC需求，或者无需返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvide</td>
<td style="text-align:center">在数据访问方面功能强大，支持一对多并发数据共享，可通过call方法拓展其他操作</td>
<td style="text-align:center">可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
<td style="text-align:center">一对多的进程间的数据共享</td>
</tr>
<tr>
<td>socket</td>
<td style="text-align:center">功能强大，可以通过=网络传输字节流，支持一对多并发实时通信</td>
<td style="text-align:center">实现细节稍微有点繁琐，不支持直接RPC</td>
<td style="text-align:center">网络数据交换</td>
</tr>
</tbody>
</table>
<h1 id="这里在总结一下IPC"><a href="#这里在总结一下IPC" class="headerlink" title="这里在总结一下IPC"></a>这里在总结一下IPC</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.smart.kaifa;</span><br><span class="line">public interface IBookManager extends android.os.IInterface &#123;</span><br><span class="line"> //系统帮我们生成的IBookManager 里面有一个抽象的Stub  在这个抽象的Stub里面有一个代理类</span><br><span class="line"> //Stub 抽象类继承了com.smart.kaifa.IBookManager  接口 需要在下面的BookManagerService中具体的实现</span><br><span class="line"> public static abstract class Stub extends android.os.Binder implements com.smart.kaifa.IBookManager &#123;</span><br><span class="line"></span><br><span class="line">    public static com.smart.kaifa.IBookManager asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">           这个时候在bind服务的时候会调用，IBookManager.Stub.asInterface(service)  之后就返回代理，所以这是一个存根代理模式，并初始化proxy</span><br><span class="line">           return new com.smart.kaifa.IBookManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      //这个是Stub内部代理类</span><br><span class="line">     private static class Proxy implements com.smart.kaifa.IBookManager &#123;</span><br><span class="line">         //这里研究一个代理内部的方法</span><br><span class="line">         @Override</span><br><span class="line">         public java.util.List&lt;com.smart.kaifa.Book&gt; getBookList() throws android.os.RemoteException &#123;</span><br><span class="line">             // 这个是系统的实现，不用管：就是讲我们调用的方法什么的进行打包,就是存储了客户端的数据信息，包括包名什么的  默认有6个 这个涉及到native层的代码了</span><br><span class="line">             //在Java空间和C++都实现了Parcel，由于它在C/C++中，直接使用了内存来读取数据，因此，它更有效率 具体c的代码就不研究了</span><br><span class="line">             android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">             android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">             java.util.List&lt;com.smart.kaifa.Book&gt; _result;</span><br><span class="line">             try &#123;</span><br><span class="line">                 // 设置标记，可以这么理解 就是告诉其他进程我要调用这个接口里面的东西  DESCRIPTOR   private static final java.lang.String DESCRIPTOR = &quot;com.smart.kaifa.IBookManager&quot;;</span><br><span class="line">                 _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                 // 这个时候会调用 remote 就是stub，然后通过他来区分不同的方法     </span><br><span class="line">                 mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);</span><br><span class="line">                 //解除标记</span><br><span class="line">                 _reply.readException();</span><br><span class="line">                 _result = _reply.createTypedArrayList(com.smart.kaifa.Book.CREATOR);</span><br><span class="line">             return _result;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;    </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookManagerService 用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class BookManagerService extends Service &#123;</span><br><span class="line"> private  static final String TAG=&quot;BMS&quot;;</span><br><span class="line"> private CopyOnWriteArrayList&lt;Book&gt; mBookList=new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"> //实现抽象方法</span><br><span class="line"> private Binder mBinder=new IBookManager.Stub() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line">     &#125;</span><br><span class="line">     @Override</span><br><span class="line">     public List&lt;Book&gt; getBookList() throws RemoteException &#123;</span><br><span class="line">         return mBookList;</span><br><span class="line">     &#125;</span><br><span class="line">     @Override</span><br><span class="line">     public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line">         mBookList.add(book);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public IBinder onBind(Intent intent) &#123;</span><br><span class="line">     // 返回binder</span><br><span class="line">     return mBinder;</span><br><span class="line"> &#125;</span><br><span class="line"> @Override</span><br><span class="line"> public void onCreate() &#123;</span><br><span class="line">     super.onCreate();</span><br><span class="line">     mBookList.add(new Book(1,&quot;wahaha&quot;));</span><br><span class="line">     mBookList.add(new Book(2,&quot;xiao&quot;));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Activity中绑定 BookManagerService 会传出ServiceConnection 连接成功之后返回Binder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">   //通过这个方法拿到代理类，这个时候就可以调用服务端代码了</span><br><span class="line">   IBookManager  bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> @Override</span><br><span class="line"> public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/进阶/" rel="tag"># 进阶</a>
          
            <a href="/tags/Android开发艺术探索/" rel="tag"># Android开发艺术探索</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/android/Android开发艺术探索_第一章 Activity的生命周期和启动模式/" rel="next" title="Android开发艺术探索 第一章 Activity的生命周期和启动模式">
                <i class="fa fa-chevron-left"></i> Android开发艺术探索 第一章 Activity的生命周期和启动模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android/Android开发艺术探索_第三章 View的事件体系/" rel="prev" title="Android开发艺术探索 第三章 View的事件体系">
                Android开发艺术探索 第三章 View的事件体系 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Groot</p>
              <p class="site-description motion-element" itemprop="description">尽信书则不如无书</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-IPC简介"><span class="nav-number">1.</span> <span class="nav-text">Android IPC简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android中的多进程模式"><span class="nav-number">2.</span> <span class="nav-text">Android中的多进程模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开启多进程模式"><span class="nav-number">2.1.</span> <span class="nav-text">开启多进程模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多进程模式的运行机制。"><span class="nav-number">2.2.</span> <span class="nav-text">多进程模式的运行机制。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IPC基础概念介绍"><span class="nav-number">3.</span> <span class="nav-text">IPC基础概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Serializable-接口"><span class="nav-number">3.1.</span> <span class="nav-text">Serializable 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parcelable接口"><span class="nav-number">3.2.</span> <span class="nav-text">Parcelable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binder"><span class="nav-number">3.3.</span> <span class="nav-text">binder</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android中的IPC方式"><span class="nav-number">4.</span> <span class="nav-text">Android中的IPC方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Bundle"><span class="nav-number">4.1.</span> <span class="nav-text">使用Bundle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用文件共享"><span class="nav-number">4.2.</span> <span class="nav-text">使用文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Messager"><span class="nav-number">4.3.</span> <span class="nav-text">使用Messager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用AIDL"><span class="nav-number">4.4.</span> <span class="nav-text">使用AIDL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用ContentProvide"><span class="nav-number">4.5.</span> <span class="nav-text">使用ContentProvide</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Socket"><span class="nav-number">4.6.</span> <span class="nav-text">使用Socket</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binder-连接池"><span class="nav-number">5.</span> <span class="nav-text">Binder 连接池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#选用合适的IPC方式"><span class="nav-number">6.</span> <span class="nav-text">选用合适的IPC方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#这里在总结一下IPC"><span class="nav-number">7.</span> <span class="nav-text">这里在总结一下IPC</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Groot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
