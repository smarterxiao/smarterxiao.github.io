<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="进阶,Android开发艺术探索," />










<meta name="description" content="这一章主要介绍两个方面的内容，一个是View的工作原理，接着介绍自定义View的实现方式。  初识ViewRoot和DecorView 在介绍View之前，这里介绍一下基本概念，这样才能了解View的measure，layout，draw过程。 ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程都是通过ViewRo">
<meta name="keywords" content="进阶,Android开发艺术探索">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索 第四章 View的工作原理">
<meta property="og:url" content="http://yoursite.com/android/Android开发艺术探索_第四章 View的工作原理/index.html">
<meta property="og:site_name" content="个人网站">
<meta property="og:description" content="这一章主要介绍两个方面的内容，一个是View的工作原理，接着介绍自定义View的实现方式。  初识ViewRoot和DecorView 在介绍View之前，这里介绍一下基本概念，这样才能了解View的measure，layout，draw过程。 ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程都是通过ViewRo">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/图像1523889820.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/图像1523974134.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/device-2018-04-30-121159.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/device-2018-04-30-121943.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/device-2018-04-30-121943.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/device-2018-04-30-121943.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/device-2018-04-30-134320.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/device-2018-04-30-153738.png">
<meta property="og:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/滑动分析.gif">
<meta property="og:updated_time" content="2018-07-26T13:02:17.361Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索 第四章 View的工作原理">
<meta name="twitter:description" content="这一章主要介绍两个方面的内容，一个是View的工作原理，接着介绍自定义View的实现方式。  初识ViewRoot和DecorView 在介绍View之前，这里介绍一下基本概念，这样才能了解View的measure，layout，draw过程。 ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程都是通过ViewRo">
<meta name="twitter:image" content="http://yoursite.com/android/Android开发艺术探索_第四章%20View的工作原理/图像1523889820.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/android/Android开发艺术探索_第四章 View的工作原理/"/>





  <title>Android开发艺术探索 第四章 View的工作原理 | 个人网站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人网站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/android/Android开发艺术探索_第四章 View的工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Groot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人网站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索 第四章 View的工作原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T17:08:23+08:00">
                2018-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p> 这一章主要介绍两个方面的内容，一个是View的工作原理，接着介绍自定义View的实现方式。</p>
</blockquote>
<h1 id="初识ViewRoot和DecorView"><a href="#初识ViewRoot和DecorView" class="headerlink" title="初识ViewRoot和DecorView"></a>初识ViewRoot和DecorView</h1><p> 在介绍View之前，这里介绍一下基本概念，这样才能了解View的measure，layout，draw过程。<br> ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程都是通过ViewRoot来完成的。在ActivityThread中，当Activity对象呗创建完成后，会将DecorView添加到window中，同时创建ViewRootImpl对象。并将ViewRootImpl对象和DecorView建立关联，这个过程可以看如下源码。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root=new ViewRootImpl(view.getContext,display);</span><br><span class="line">root.setView(view,wparams,panelParentView)</span><br></pre></td></tr></table></figure></p>
<p>View的绘制流程从ViewRoot的performTraversals方法开始的，他经过measure，layout，draw三个过程才能最终将一个View绘制出来，其中measure用拉力测量View的宽和高，layout用来确定View在父容器当中的位置，而draw负责将View绘制到屏幕上面去。针对performTraversals的大致流程如下</p>
<p><img src="图像1523889820.png" alt="Alt text" title="流程图"></p>
<p>如图所示，performTraversals会一次调用performMeasure，performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure，layout，draw这三大流程。其中performMeasure会调用measure方法，在measure方法中会调用onMeasure方法，在onMeasure方法会对所有子元素进行measure过程，这个时候measure流程就从父容器传递到子容器当中了。这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历，同理performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是performDraw的传递过程是在draw方法加载dispatchDraw来实现的，不过本质并没有什么区别。<br>measure过程决定了View的宽和高，Measure完成后，可以通过getMeasuredWidth和getMeasureHeight方法来获取到View测量后的宽和高。在几乎所有的情况下他都等于View最终的宽和高，但是特殊情况除外，这点在本章后面会进行说明。Layout过程决定了View的四个顶点和View的实际宽和高，完成以后可以通过<code>getTop</code>和<code>getBottom</code>和<code>getRight</code>和<code>getLeft</code>并且通过<code>getWidth</code>和<code>getHeight</code>获取最终的宽和高，draw过程决定了View的显示。只有draw之后才能在屏幕上面显示。</p>
<p><img src="图像1523974134.png" alt="Alt text" title="顶级View：DecorView的结构"><br>如图：DecorView作为最顶级的View，一般情况下他的内部包含一个Linearlayout,分为两个部分：上方标题栏和下方内容栏。在Actvity中通过<code>setContentView</code>的内容是被加入到内容栏中间的，而内容栏的id是content，所以这个方法就叫做<code>setContentView</code>。如何得到这个内容栏呢? 可以通过<code>findViewById(R.id.content)</code>找到内容栏。如何得到我们设置的View呢?可以通过<code>content.getChildAt(0)</code>来获取</p>
<h1 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h1><p>为了更好的理解View的测量流程，我们还需要理解MeasureSpec。从名字上来看 MeasureSpec像是测量规格。 MeasureSpec是干什么的呢？它在很大程度上决定了一个View的尺寸规格，之所以很大程度上是因为这个会受到父控件的影响，因为父控件影响View的MeasureSpec的创建过程。在测量过程中，系统会将View的LayoutParems根据父控件所施加的规则转换成对应的MeasureSpec，然后在更具这个measureSpec来测量View的宽高,上面提到过，这里测量的宽和高并不一定是View的最终宽高。MeasureSpec看起来有点复杂。其实他的实现很简单。</p>
<h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p>这个是一个32位的int值，高两位代表测量模式：specMode，低两位代表某一种模式的测量大小：SpecSize。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">public static class MeasureSpec &#123;</span><br><span class="line">       private static final int MODE_SHIFT = 30;</span><br><span class="line">       private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">       /** @hide */</span><br><span class="line">       @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line">       @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">       public @interface MeasureSpecMode &#123;&#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Measure specification mode: The parent has not imposed any constraint</span><br><span class="line">        * on the child. It can be whatever size it wants.</span><br><span class="line">        */</span><br><span class="line">       public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Measure specification mode: The parent has determined an exact size</span><br><span class="line">        * for the child. The child is going to be given those bounds regardless</span><br><span class="line">        * of how big it wants to be.</span><br><span class="line">        */</span><br><span class="line">       public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Measure specification mode: The child can be as large as it wants up</span><br><span class="line">        * to the specified size.</span><br><span class="line">        */</span><br><span class="line">       public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Creates a measure specification based on the supplied size and mode.</span><br><span class="line">        *</span><br><span class="line">        * The mode must always be one of the following:</span><br><span class="line">        * &lt;ul&gt;</span><br><span class="line">        *  &lt;li&gt;&#123;@link android.view.View.MeasureSpec#UNSPECIFIED&#125;&lt;/li&gt;</span><br><span class="line">        *  &lt;li&gt;&#123;@link android.view.View.MeasureSpec#EXACTLY&#125;&lt;/li&gt;</span><br><span class="line">        *  &lt;li&gt;&#123;@link android.view.View.MeasureSpec#AT_MOST&#125;&lt;/li&gt;</span><br><span class="line">        * &lt;/ul&gt;</span><br><span class="line">        *</span><br><span class="line">        * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; On API level 17 and lower, makeMeasureSpec&apos;s</span><br><span class="line">        * implementation was such that the order of arguments did not matter</span><br><span class="line">        * and overflow in either value could impact the resulting MeasureSpec.</span><br><span class="line">        * &#123;@link android.widget.RelativeLayout&#125; was affected by this bug.</span><br><span class="line">        * Apps targeting API levels greater than 17 will get the fixed, more strict</span><br><span class="line">        * behavior.&lt;/p&gt;</span><br><span class="line">        *</span><br><span class="line">        * @param size the size of the measure specification</span><br><span class="line">        * @param mode the mode of the measure specification</span><br><span class="line">        * @return the measure specification based on size and mode</span><br><span class="line">        */</span><br><span class="line">       public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,</span><br><span class="line">                                         @MeasureSpecMode int mode) &#123;</span><br><span class="line">           if (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">               return size + mode;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Like &#123;@link #makeMeasureSpec(int, int)&#125;, but any spec with a mode of UNSPECIFIED</span><br><span class="line">        * will automatically get a size of 0. Older apps expect this.</span><br><span class="line">        *</span><br><span class="line">        * @hide internal use only for compatibility with system widgets and older apps</span><br><span class="line">        */</span><br><span class="line">       public static int makeSafeMeasureSpec(int size, int mode) &#123;</span><br><span class="line">           if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           return makeMeasureSpec(size, mode);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Extracts the mode from the supplied measure specification.</span><br><span class="line">        *</span><br><span class="line">        * @param measureSpec the measure specification to extract the mode from</span><br><span class="line">        * @return &#123;@link android.view.View.MeasureSpec#UNSPECIFIED&#125;,</span><br><span class="line">        *         &#123;@link android.view.View.MeasureSpec#AT_MOST&#125; or</span><br><span class="line">        *         &#123;@link android.view.View.MeasureSpec#EXACTLY&#125;</span><br><span class="line">        */</span><br><span class="line">       @MeasureSpecMode</span><br><span class="line">       public static int getMode(int measureSpec) &#123;</span><br><span class="line">           //noinspection ResourceType</span><br><span class="line">           return (measureSpec &amp; MODE_MASK);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Extracts the size from the supplied measure specification.</span><br><span class="line">        *</span><br><span class="line">        * @param measureSpec the measure specification to extract the size from</span><br><span class="line">        * @return the size in pixels defined in the supplied measure specification</span><br><span class="line">        */</span><br><span class="line">       public static int getSize(int measureSpec) &#123;</span><br><span class="line">           return (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       static int adjust(int measureSpec, int delta) &#123;</span><br><span class="line">           final int mode = getMode(measureSpec);</span><br><span class="line">           int size = getSize(measureSpec);</span><br><span class="line">           if (mode == UNSPECIFIED) &#123;</span><br><span class="line">               // No need to adjust size for UNSPECIFIED mode.</span><br><span class="line">               return makeMeasureSpec(size, UNSPECIFIED);</span><br><span class="line">           &#125;</span><br><span class="line">           size += delta;</span><br><span class="line">           if (size &lt; 0) &#123;</span><br><span class="line">               Log.e(VIEW_LOG_TAG, &quot;MeasureSpec.adjust: new size would be negative! (&quot; + size +</span><br><span class="line">                       &quot;) spec: &quot; + toString(measureSpec) + &quot; delta: &quot; + delta);</span><br><span class="line">               size = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           return makeMeasureSpec(size, mode);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>MeasureSpec通过将SpecMode和SpecSize打包成为一个int值来避免过多的对象内存分配，为了方便操作。提供了打包和解包的方法。specMode和SpecSIze也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec。而一个MeasureSpec可以通过解包的形式获取SpecMode和SpecSize，需要注意这里的MeasureSpec所代表的是一个int值，不是对象本身。</p>
<p>SpecMode有三类，每一类都代表特殊的含义，如下所示</p>
<ul>
<li>UNSPECIFIED<br>父容器不对View有限制，要多他给多大，一般情况用于系统内部，表示测量状态</li>
<li>EXACTLY<br>父容器已经检测出View所遇到的精确大小，这个时候View的最终大小就是SpecSize指定的值。他对应于LayoutParems中的match_parent和具体数值这两种模式</li>
<li>AT__MOST<br>父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么要看不同View的具体实现，他对于LayoutParams中的wrap_content<h2 id="MeasureSpec和LayoutParams的对应关系"><a href="#MeasureSpec和LayoutParams的对应关系" class="headerlink" title="MeasureSpec和LayoutParams的对应关系"></a>MeasureSpec和LayoutParams的对应关系</h2></li>
</ul>
<p>上面提到，系统内部是通过MeasureSpec来进行测量，但是正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParems。在View测量的时候，系统会将LayoutParams在父容器约束下转换成对应的MeasureSpec，然后在更具这个MeasureSpec来确定测量后的宽和高。需要注意的是，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽和高。另外，对于顶级View（DecorView）和普通View来说，MeasureSpec的转换过程略有不同，对于DecorView，其MeasureSpec有窗口尺寸和其自身的LayoutParams来共同决定；对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以测量View的宽和高了<br>对于DecorView来说，在ViewRootImpl中的MeasureHierarchy方法中有如下一段代码，他展示了DecorView的MeasureSpec的创建过程，其中desiredWindowWidth和desiredWindowHeight是屏幕的尺寸<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">childWidthMeasureSpec=getRootMeasureSpec(desireWindowWidth,lp.width);</span><br><span class="line">childHeightMeasureSpec=getRootMeasureSpec(desiredwindowHeight,lp.height);</span><br><span class="line">performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);</span><br></pre></td></tr></table></figure></p>
<p>接着在看一下<code>getRootMeasureSpec</code>的方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static int getRootMeasureSpec(int windowSize,int rootDimension)&#123;</span><br><span class="line">  int measureSpec;</span><br><span class="line">  switch(rootDimension)&#123;</span><br><span class="line">      // MATCH_PARENT 和MeasureSpec.AT_MOST有关联 ViewGroup.LayoutParams.MATCH_PARENT是-1</span><br><span class="line">    case ViewGroup.LayoutParams.MATCH_PARENT：</span><br><span class="line">    measureSpec=MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACELY);</span><br><span class="line">    break;</span><br><span class="line">    // WRAP_CONTENT 和MeasureSpec.AT_MOST有关联   public static final int WRAP_CONTENT = -2;</span><br><span class="line">    case ViewGroup.LayoutParams.WRAP_CONTENT：</span><br><span class="line">    measureSpec=MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.AT_MOST);</span><br><span class="line">    break;</span><br><span class="line">    // 固定大小</span><br><span class="line">    default:</span><br><span class="line">    measureSpec=MeasureSpec.makeMeasureSpec(rootDimension,MeasureSpec.EXACTLY)</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码，DecorView的MeasureSpec的产生过程就很明确了，终于清楚了</p>
<ul>
<li>LayoutParams.MATCH_PARENT：精确模式，大小就是窗口的大小</li>
<li>LayoutParams.WRAP_CONTENT:最大模式，大小不确定，但是不能超过窗口大小</li>
<li>固定大小（比如100dp）：精确模式，大小为LayoutParams中指定的大小</li>
</ul>
<p>对于普通View来说，这里是指我们布局中的View，View的measure过程由ViewGroup传递而来，先看一下ViewGroup的measureChildWithMargins方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">         int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">         int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">           //获取子控件的布局参数</span><br><span class="line">     final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">            //获取子控件的MeasureSpec 这里需要传入父元素的MeasureSpec和子元素的LayoutParams ，所以和这两个都有关系</span><br><span class="line">     final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">             mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                     + widthUsed, lp.width);</span><br><span class="line">     final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">             mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                     + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">     child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法会对子元素进行measure，在调用子元素的measure方法之前会同时getChildMeasureSpec方法来得到子元素的MeasureSpec。从代码来看，很显然，子元素MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，此外还和View的marigin和padding有关，可以看一下<code>getChildMeasureSpec</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">    // 解析父元素的MeasureSpec</span><br><span class="line">     int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">     int specSize = MeasureSpec.getSize(spec);</span><br><span class="line">     // 获取大小最大值</span><br><span class="line">     int size = Math.max(0, specSize - padding);</span><br><span class="line"></span><br><span class="line">     int resultSize = 0;</span><br><span class="line">     int resultMode = 0;</span><br><span class="line">     // 依据父元素的测量模式进行处理</span><br><span class="line">     switch (specMode) &#123;</span><br><span class="line">     // Parent has imposed an exact size on us</span><br><span class="line">     case MeasureSpec.EXACTLY:// 父元素是精确模式</span><br><span class="line">         if (childDimension &gt;= 0) &#123;// 子控件的LayoutParams大小,如果大于0 就是固定模式，知道大小</span><br><span class="line">             resultSize = childDimension;</span><br><span class="line">             resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">         &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;// 子控件的LayoutParams大小,如果小于0 就是固定模式，不知道大小，设置了 LayoutParams.MATCH_PARENT</span><br><span class="line">             // Child wants to be our size. So be it.</span><br><span class="line">             resultSize = size;</span><br><span class="line">             resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">         &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">             // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">             // bigger than us.</span><br><span class="line">             resultSize = size;</span><br><span class="line">             resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">         &#125;</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">     // Parent has imposed a maximum size on us</span><br><span class="line">     case MeasureSpec.AT_MOST:</span><br><span class="line">         if (childDimension &gt;= 0) &#123;</span><br><span class="line">             // Child wants a specific size... so be it</span><br><span class="line">             resultSize = childDimension;</span><br><span class="line">             resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">         &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">             // Child wants to be our size, but our size is not fixed.</span><br><span class="line">             // Constrain child to not be bigger than us.</span><br><span class="line">             resultSize = size;</span><br><span class="line">             resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">         &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">             // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">             // bigger than us.</span><br><span class="line">             resultSize = size;</span><br><span class="line">             resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">         &#125;</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">     // Parent asked to see how big we want to be</span><br><span class="line">     case MeasureSpec.UNSPECIFIED:</span><br><span class="line">         if (childDimension &gt;= 0) &#123;</span><br><span class="line">             // Child wants a specific size... let him have it</span><br><span class="line">             resultSize = childDimension;</span><br><span class="line">             resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">         &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">             // Child wants to be our size... find out how big it should</span><br><span class="line">             // be</span><br><span class="line">             resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">             resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">         &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">             // Child wants to determine its own size.... find out how</span><br><span class="line">             // big it should be</span><br><span class="line">             resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">             resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">         &#125;</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line">     //noinspection ResourceType</span><br><span class="line">    // 将specMode和SpecSize组合</span><br><span class="line">     return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来主要是依据父容器的MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec。参数中的padding指的是父容器已经占用的大小，所以子元素可用大小为父容器的尺寸减去padding<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int specSize = MeasureSpec.getSize(spec);</span><br><span class="line">// 获取大小最大值</span><br><span class="line">int size = Math.max(0, specSize - padding);</span><br></pre></td></tr></table></figure></p>
<p><code>getChildMeasureSpec</code>清楚的展示了普通View的MeasureSpec的创建规则，为了更加清晰的理解<code>getChildMeasureSpec</code>这里提供一个表针对<code>getChildMeasureSpec</code>的原理进行梳理</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">parentSpecMode</th>
<th style="text-align:center">EXACTLY</th>
<th style="text-align:center">AT_MOST</th>
<th style="text-align:center">UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">childLayoutParams</td>
<td style="text-align:center">dp/px</td>
<td style="text-align:center">EXACTLY/childSize</td>
<td style="text-align:center">AT_MOST/childSize</td>
<td style="text-align:center">UNSPECIFIED/childSize</td>
</tr>
<tr>
<td style="text-align:center">childLayoutParams</td>
<td style="text-align:center">MATCH_PARENT</td>
<td style="text-align:center">EXACTLY/parentSize</td>
<td style="text-align:center">AT_MOST/parentSize</td>
<td style="text-align:center">UNSPECIFIED/0</td>
</tr>
<tr>
<td style="text-align:center">childLayoutParams</td>
<td style="text-align:center">WRAP_CONTENT</td>
<td style="text-align:center">AT_MOST/parentSiz</td>
<td style="text-align:center">AT_MOST/parentSiz</td>
<td style="text-align:center">UNSPECIFIED/0</td>
</tr>
</tbody>
</table>
<p>针对表这里在做一下说明，前面已经提到，对于普通的View，其MeasureSpec由父控件的MeasureSpec和自身的LayoutParams来共同决定，那么针对不同的父容器和View本身不同的LayoutParams，View就可以有多重MeasureSpec。这里说一下当View采用固定狂傲的时候，不管父容器是什么模式，都是精确模式，并且大小遵循子控件的LayoutParams，当View的宽度/高度是match_parent时，如果父控件的模式是精确模式，那么View也是精确模式并且其大小不会超过其父容器的大小，如果父容器是最大模式，那么View也是最大模式，并且其大小不会超过父容器的剩余空间，当View的宽/高是wrap_content时，不管父容器的模式是精确还是最大化，View的模式总是最大化并且不能超过父容器的剩余空间。分析的时候溜掉了UNSPECIFIED模式，这个模式主要用于系统内部多次Measure的情景，一般不用</p>
<h1 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h1><p>View的工作流程主要是指measure、layout和draw这三个过程，即测量，布局和绘制，其中measure确定View的测量宽和高，layout确定View的四个顶点位置，而draw则将View绘制到屏幕上</p>
<h2 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a>measure过程</h2><p>measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历调用所有的子元素的measure方法。各个子元素在递归去执行这个流程。下面针对这两种情况分别讨论。</p>
<ol>
<li>View的measure过程<br>view的measure过程由其measure方法来完成，measure是一个final类型方法，这意味着不能重写此方法，在View的measure方法中会调用View的onMeasure方法，因此，只要看onMeasure方法实现即可，View的onMeasure方法如下所示。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的代码很简单，但是简洁并不代表简单，setMeasuredDimension方法会设置View的宽和高的测量值，因此我们只需要看getDefaultSize这个方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 传入最大值：size</span><br><span class="line">// 如果是UNSPECIFIED 自定义的模式，就使用传入的最大值</span><br><span class="line">// 否则就根据MeasureSpec获取大小</span><br><span class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</span><br><span class="line">       int result = size;</span><br><span class="line">       int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">       int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">       switch (specMode) &#123;</span><br><span class="line">       case MeasureSpec.UNSPECIFIED:</span><br><span class="line">           result = size;</span><br><span class="line">           break;</span><br><span class="line">       case MeasureSpec.AT_MOST:</span><br><span class="line">       case MeasureSpec.EXACTLY:</span><br><span class="line">           result = specSize;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>UNSPECIFIED这种情况是系统内部后者自定义的时候使用，或得到size 这个size是通过下面的方法<code>getSuggestedMinimumWidth()</code>获取的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果控件没有背景 取minwidth 否则 取最小值和背景的最大值</span><br><span class="line">protected int getSuggestedMinimumWidth() &#123;</span><br><span class="line">    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int getSuggestedMinimumHeight() &#123;</span><br><span class="line">    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>的原理是一样的，如果没有设置背景，那么View的宽度为mMinWidth，而mMinWidth对应控件的android:minWidth这个属性所指的值，因此View的宽度就是android:minWidth属性所指定的值，这个属性如果不指定，那么默认值就是0，如果View指定了背景，则View的宽度为<code>max(mMinWidth, mBackground.getMinimumWidth())</code>的最大值，mMinWidth这个我们已经知道含义了，那么<code>mBackground.getMinimumWidth()</code>是什么意思呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int getMinimumHeight() &#123;</span><br><span class="line">    final int intrinsicHeight = getIntrinsicHeight();</span><br><span class="line">    return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getIntrinsicWidth() &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">drawable的子类重写了这个方法 这个是NinePatchDrawable</span><br><span class="line">@Override</span><br><span class="line">public int getIntrinsicWidth() &#123;</span><br><span class="line">    return mBitmapWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到getMinimumHeight返回的是drawable原始的高度。这里举个例子说明一下ShapeDrawable无原始宽和高，而BitmapDrawable有原始宽和高，详细内容会在后面介绍的<br>这里在总结一下<code>getMinimumHeight</code>的逻辑，如果View没有设置背景，那么返回android：minWidth这个属性所属的值。这个值可以为0，如果View设置了背景，则返回android：minWidth和背景最小宽度这两个钟的最大值，这样他的返回值就是View在UNSPECIFIED下的测量宽和高<br>从getDefaultSize方法的实现来看，View的狂傲由specSize决定，我们得出结论：直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content是的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。为什么呢？这个原因需要结合上述代码和之前的表来理解。从上述代码我们知道，如果View在布局中使用wrap_content,那么他的specMode的模式就是AT_MOST，在这种模式下，他的宽和高就是specSize；并且根据上面的表，可以看到这种情况下的specSize是parentSIze，而parentSize就是容器目前可以使用的大小，就是父容器当前剩余的空间大小。很显然，View的宽和高就相当于父控件当前剩余的空间大小，这种效果和在布局中使用match_parent完全一样。如何解决这个问题呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    int widthSpecSize=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    if(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(mWidth.mHeight);</span><br><span class="line">    &#125;else   if(widthSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(mWidth.heightSpecSize);</span><br><span class="line">    &#125;else   if(heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(widthSpecSize.mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们只需要给View指定一个默认的内部宽和高(mWidth和mHeight)并且在wrap_content的时候设置宽和高就可以了。针对非wrap_content情景，我们沿用西永的测量值就可以了。至于这个默认内部宽和高的大小如何指定，这个没有固定依据，更具需要灵活指定即可。查看TextView和ImageView等源码就可以知道，针对wrap_content情形。他们的onMeasure方法都做了特殊处理，读者可以自行查看他们的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">这个是imageView的onMeasure方法</span><br><span class="line">@Override</span><br><span class="line">  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">      resolveUri();</span><br><span class="line">      int w;</span><br><span class="line">      int h;</span><br><span class="line"></span><br><span class="line">      // Desired aspect ratio of the view&apos;s contents (not including padding)</span><br><span class="line">      float desiredAspect = 0.0f;</span><br><span class="line"></span><br><span class="line">      // We are allowed to change the view&apos;s width</span><br><span class="line">      boolean resizeWidth = false;</span><br><span class="line"></span><br><span class="line">      // We are allowed to change the view&apos;s height</span><br><span class="line">      boolean resizeHeight = false;</span><br><span class="line"></span><br><span class="line">      final int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">      final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">      if (mDrawable == null) &#123;</span><br><span class="line">          // If no drawable, its intrinsic size is 0.</span><br><span class="line">          mDrawableWidth = -1;</span><br><span class="line">          mDrawableHeight = -1;</span><br><span class="line">          w = h = 0;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          w = mDrawableWidth;</span><br><span class="line">          h = mDrawableHeight;</span><br><span class="line">          if (w &lt;= 0) w = 1;</span><br><span class="line">          if (h &lt;= 0) h = 1;</span><br><span class="line">          //判断是否开启值测量宽和高</span><br><span class="line">          // We are supposed to adjust view bounds to match the aspect</span><br><span class="line">          // ratio of our drawable. See if that is possible.</span><br><span class="line">          if (mAdjustViewBounds) &#123;</span><br><span class="line">              resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;</span><br><span class="line">              resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">              desiredAspect = (float) w / (float) h;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>textView的onMeasure方法重写后特别长，这里就不列出来了</p>
<ol start="2">
<li>ViewGroup的measure处理过程<br>对于ViewGroup，除了完成自己的measure过程以外，还会遍历调用所有子控件的measure方法，和View不同的是，ViewGroup是一个抽象类，因此他没有重写View的onMeasure方法，但是他提供了一个叫measureChildren的方法，如下所示。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    final int size = mChildrenCount;</span><br><span class="line">    final View[] children = mChildren;</span><br><span class="line">    for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">        final View child = children[i];</span><br><span class="line">        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从源码来看，ViewGroup在measure是会对每一个子元素进行measure,measureChild的方法也很好理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChild(View child, int parentWidthMeasureSpec,</span><br><span class="line">        int parentHeightMeasureSpec) &#123;</span><br><span class="line">    final LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，<code>measureChild</code>的意思其实就是取出子元素的layoutParams，然后通过getChildMeasureSpec获取MeasureSpec，然后将得到的MeasureSpec传递给子控件的measure方法<br>我们知道ViewGroup没有定义测量过程，这个是因为ViewGroup是一个抽象类，其测量过程的OnMeasure需要在每一个子类中实现，比如LinearLayout，RelativeLayout等。为什么不像View一样对其OnMeasure进行统一处理呢，这个是因为每一个ViewGroup子类的布局特性不同，导致细节不同，所以不能统一实现。这里使用LinearLayout的onMeasure进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    if (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单，这里就先分析一下<code>measureVertical</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">       mTotalLength = 0;</span><br><span class="line">       int maxWidth = 0;</span><br><span class="line">       int childState = 0;</span><br><span class="line">       int alternativeMaxWidth = 0;</span><br><span class="line">       int weightedMaxWidth = 0;</span><br><span class="line">       boolean allFillParent = true;</span><br><span class="line">       float totalWeight = 0;</span><br><span class="line"></span><br><span class="line">       final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">       final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">       final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">       boolean matchWidth = false;</span><br><span class="line">       boolean skippedMeasure = false;</span><br><span class="line"></span><br><span class="line">       final int baselineChildIndex = mBaselineAlignedChildIndex;</span><br><span class="line">       final boolean useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">       int largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line">       int consumedExcessSpace = 0;</span><br><span class="line"></span><br><span class="line">       int nonSkippedChildCount = 0;</span><br><span class="line"></span><br><span class="line">       // See how tall everyone is. Also remember max width.</span><br><span class="line">       //这里对子控件进行遍历</span><br><span class="line">       for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">           final View child = getVirtualChildAt(i);</span><br><span class="line">           if (child == null) &#123;</span><br><span class="line">               mTotalLength += measureNullChild(i);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">              i += getChildrenSkipCount(child, i);</span><br><span class="line">              continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           nonSkippedChildCount++;</span><br><span class="line">           if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">               mTotalLength += mDividerHeight;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">           totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">           final boolean useExcessSpace = lp.height == 0 &amp;&amp; lp.weight &gt; 0;</span><br><span class="line">           if (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">               final int totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">               skippedMeasure = true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (useExcessSpace) &#123;</span><br><span class="line"></span><br><span class="line">                   lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int usedHeight = totalWeight == 0 ? mTotalLength : 0;</span><br><span class="line">               // 对子控件执行measureChildBeforeLayout</span><br><span class="line">               measureChildBeforeLayout(child, i, widthMeasureSpec, 0,</span><br><span class="line">                       heightMeasureSpec, usedHeight);</span><br><span class="line"></span><br><span class="line">               final int childHeight = child.getMeasuredHeight();</span><br><span class="line">               if (useExcessSpace) &#123;</span><br><span class="line">                   lp.height = 0;</span><br><span class="line">                   consumedExcessSpace += childHeight;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                      lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">               if (useLargestChild) &#123;</span><br><span class="line">                   largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           /**</span><br><span class="line">            * If applicable, compute the additional offset to the child&apos;s baseline</span><br><span class="line">            * we&apos;ll need later when asked &#123;@link #getBaseline&#125;.</span><br><span class="line">            */</span><br><span class="line">           if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123;</span><br><span class="line">              mBaselineChildTop = mTotalLength;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // if we are trying to use a child index for our baseline, the above</span><br><span class="line">           // book keeping only works if there are no children above it with</span><br><span class="line">           // weight.  fail fast to aid the developer.</span><br><span class="line">           if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">               throw new RuntimeException(&quot;A child of LinearLayout with index &quot;</span><br><span class="line">                       + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span><br><span class="line">                       + &quot;won&apos;t work.  Either remove the weight, or don&apos;t set &quot;</span><br><span class="line">                       + &quot;mBaselineAlignedChildIndex.&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           boolean matchWidthLocally = false;</span><br><span class="line">           if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               // The width of the linear layout will scale, and at least one</span><br><span class="line">               // child said it wanted to match our width. Set a flag</span><br><span class="line">               // indicating that we need to remeasure at least that view when</span><br><span class="line">               // we know our width.</span><br><span class="line">               matchWidth = true;</span><br><span class="line">               matchWidthLocally = true;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final int margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">           final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">           maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">           childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">           allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">           if (lp.weight &gt; 0) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Widths of weighted Views are bogus if we end up</span><br><span class="line">                * remeasuring, so keep them separate.</span><br><span class="line">                */</span><br><span class="line">               weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                       matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                       matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (nonSkippedChildCount &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">           mTotalLength += mDividerHeight;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (useLargestChild &amp;&amp;</span><br><span class="line">               (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">           mTotalLength = 0;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">               final View child = getVirtualChildAt(i);</span><br><span class="line">               if (child == null) &#123;</span><br><span class="line">                   mTotalLength += measureNullChild(i);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (child.getVisibility() == GONE) &#123;</span><br><span class="line">                   i += getChildrenSkipCount(child, i);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                       child.getLayoutParams();</span><br><span class="line">               // Account for negative margins</span><br><span class="line">               final int totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Add in our padding</span><br><span class="line">       mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">       int heightSize = mTotalLength;</span><br><span class="line"></span><br><span class="line">       // Check against our minimum height</span><br><span class="line">       heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">       // Reconcile our calculated size with the heightMeasureSpec</span><br><span class="line">       int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">       heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">       // Either expand children with weight to take up available space or</span><br><span class="line">       // shrink them if they extend beyond our current bounds. If we skipped</span><br><span class="line">       // measurement on any children, we need to measure them now.</span><br><span class="line">       int remainingExcess = heightSize - mTotalLength</span><br><span class="line">               + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);</span><br><span class="line">       if (skippedMeasure || remainingExcess != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123;</span><br><span class="line">           float remainingWeightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">           mTotalLength = 0;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">               final View child = getVirtualChildAt(i);</span><br><span class="line">               if (child == null || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               final float childWeight = lp.weight;</span><br><span class="line">               if (childWeight &gt; 0) &#123;</span><br><span class="line">                   final int share = (int) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                   remainingExcess -= share;</span><br><span class="line">                   remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                   final int childHeight;</span><br><span class="line">                   if (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                       childHeight = largestChildHeight;</span><br><span class="line">                   &#125; else if (lp.height == 0 &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                           || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                       // This child needs to be laid out from scratch using</span><br><span class="line">                       // only its share of excess space.</span><br><span class="line">                       childHeight = share;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // This child had some intrinsic height to which we</span><br><span class="line">                       // need to add its share of excess space.</span><br><span class="line">                       childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           Math.max(0, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                   final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                           mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                           lp.width);</span><br><span class="line">                   child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                   // Child may now not fit in vertical dimension.</span><br><span class="line">                   childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">               final int measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">               maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">               boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                       lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                       matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">               allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">               final int totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Add in our padding</span><br><span class="line">           mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">           // TODO: Should we recompute the heightSpec based on the new total length?</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                          weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           // We have no limit, so make all weighted views as tall as the largest child.</span><br><span class="line">           // Children will have already been measured once.</span><br><span class="line">           if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">               for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                   final View child = getVirtualChildAt(i);</span><br><span class="line">                   if (child == null || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   final LinearLayout.LayoutParams lp =</span><br><span class="line">                           (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                   float childExtra = lp.weight;</span><br><span class="line">                   if (childExtra &gt; 0) &#123;</span><br><span class="line">                       child.measure(</span><br><span class="line">                               MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                       MeasureSpec.EXACTLY),</span><br><span class="line">                               MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                       MeasureSpec.EXACTLY));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">           maxWidth = alternativeMaxWidth;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">       // Check against our minimum width</span><br><span class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">               heightSizeAndState);</span><br><span class="line"></span><br><span class="line">       if (matchWidth) &#123;</span><br><span class="line">           forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到会遍历子控件 在遍历子控件的时候会调用<code>measureChildBeforeLayout</code>方法,具体代码参照下面。<br>在调用<code>measureChildWithMargins</code>方法，这样就可以调用子控件的measure方法，在调用子控件的measure的时候，会调用<code>onMeasure</code>方法，这样遍历调用，也看出遍历子控件是深度优先的遍历<br>使用<code>mTotalLength</code>来存储竖直方向的高度，包括竖直方向上面的margin和子元素的高度等</p>
<p>当子元素测量完毕之后会测量自己的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void measureChildBeforeLayout(View child, int childIndex,</span><br><span class="line">     int widthMeasureSpec, int totalWidth, int heightMeasureSpec,</span><br><span class="line">     int totalHeight) &#123;</span><br><span class="line"> measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class="line">         heightMeasureSpec, totalHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">         int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">         int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">     final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">     final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">             mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                     + widthUsed, lp.width);</span><br><span class="line">     final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">             mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                     + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">     child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>View的Measure是三大流程中最复杂的一个，measure完成之后，通过getMeasureWidth/Height方法就可以正确的获取到View的测量宽和高了，需要注意，在某种极端情况下，需要多次measure才能测量出最终的宽和高，在onMeasure中的宽和高是不稳定的，最好的方式是在onLayout中获取宽和高<br>上面已经对View的measure进行了详细的分析，现在需要考虑到一种情况，如果在Activity已经启动的时候做一个任务，但是这个任务需要获取某一个View的高度，这个时候在onCreate，onResume和onStart中都是无法正确获取宽和高的。因为View的measure方法和Activity的生命周期方法不是同步执行的。所以需要在</p>
<ol>
<li>Activity/View# <code>OnWindowFocusChanged</code><br>这个方法的含义是View已经初始化完毕了，宽和高已经测量完毕了，需要注意当Activity的窗口得到焦点和失去焦点是均会被调用一次<code>OnWindowFocusChanged</code>，如果频繁的onResume和onPause，那么这个方法也会被调用</li>
<li><p>View.post(runnable)<br>通过post可以将一个runnableto投递到消息队列的尾部，然后等待looper调用此runnable的时候，View已经初始化完毕了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void onStart()&#123;</span><br><span class="line">super.OnStart();</span><br><span class="line">View.post(new Runnable(()&#123;</span><br><span class="line">  public void run()&#123;</span><br><span class="line">    int height=view.getMeasureHeight();</span><br><span class="line">    int width=view.getMeasureWidth(();)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ViewTreeObserver<br>使用ViewTreeObserver的众多回调可以完成这个功能，比如使用onGloablLayoutListener这个接口，当View的树结构发生变化或者View树内部可见性发生变化时候，<code>onGlobalLayout</code>方法将会被回调，因此这是获取View的宽和高的一次好机会，需要注意随着View树结构状态的变化，<code>onGlobalLayout</code>会被调用多次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line"></span><br><span class="line">    ViewTreeObserver viewTreeObserver=view.getViewTreeObserver();</span><br><span class="line">    viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onGlobalLayout() &#123;</span><br><span class="line">            int measuredHeight = view.getMeasuredHeight();</span><br><span class="line">            int measuredWidth = view.getMeasuredWidth();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>view.measure(xxx,xxx)<br>通过手动对View进行measure得到。这个情况适合复杂情况的处理</p>
</li>
</ol>
<p>这种情况需要依据LayoutParams来区分<br>MATCH_PARENT<br>直接放弃，无法measure出具体的宽和高，原因很简单，依据之前的表和measure过程，构造这种MeasureSpec需要知道parentSize，即父控件的剩余空间，但是这个时候无法获取parentSize大小，所以理论上不可能测量出View的大小</p>
<p>具体数值<br>比如宽和高都是100dp,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  widthMeasureSpec =measureSpec.makeMeasureSpec(100,MeasureSpec.EXACTLY)</span><br><span class="line">int  heightMeasureSpec =measureSpec.makeMeasureSpec(100,MeasureSpec.EXACTLY)</span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec)</span><br></pre></td></tr></table></figure>
<p>WRAP_CONTENT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  widthMeasureSpec =measureSpec.makeMeasureSpec((1&lt;&lt;30)-1,MeasureSpec.AT_MOST)</span><br><span class="line">int  heightMeasureSpec =measureSpec.makeMeasureSpec((1&lt;&lt;30)-1,MeasureSpec.AT_MOST)</span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec)</span><br></pre></td></tr></table></figure></p>
<p>注意到(1&lt;&lt;30)-1 通过分析MeasureSpec可以知道View的尺寸使用30位二进制表示。也就是最大是30个1 理论上使用最大值构造是合理的<br>这里有两种错误的做法，为什么错误是因为违背了系统内部的实现规范</p>
<p>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int widthMeasureSpec=measureSpec.makeMeasureSpec(-1,NeasureSpec.UNSPECIFIED);</span><br><span class="line">int heightMeasureSpec=measureSpec.makeMeasureSpec(-1,NeasureSpec.UNSPECIFIED);</span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec)</span><br></pre></td></tr></table></figure></p>
<p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.measure(LayoutParams.wrap_content,LayoutParams.Wrap_content)</span><br></pre></td></tr></table></figure>
<h2 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h2><p>layoutde 作用是用来确定子元素的位置，当ViewGroup的位置被确定之后，他在onLayout中会遍历子元素并调用他的layout方法。在layout中onLayout方法又会被调用，layout比measure过程要简单很多，layout方法确定了View本身的位置，而onLayout方法会确定所有子元素的位置。先看View的layout方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">      if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">          onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">          mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int oldL = mLeft;</span><br><span class="line">      int oldT = mTop;</span><br><span class="line">      int oldB = mBottom;</span><br><span class="line">      int oldR = mRight;</span><br><span class="line"></span><br><span class="line">      boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">              setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">      if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">          onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">          if (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">              if(mRoundScrollbarRenderer == null) &#123;</span><br><span class="line">                  mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              mRoundScrollbarRenderer = null;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">          ListenerInfo li = mListenerInfo;</span><br><span class="line">          if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</span><br><span class="line">              ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                      (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">              int numListeners = listenersCopy.size();</span><br><span class="line">              for (int i = 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                  listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">      mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">      if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123;</span><br><span class="line">          mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</span><br><span class="line">          notifyEnterOrExitForAutoFillIfNeeded(true);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  protected boolean setFrame(int left, int top, int right, int bottom) &#123;</span><br><span class="line">        boolean changed = false;</span><br><span class="line"></span><br><span class="line">        if (DBG) &#123;</span><br><span class="line">            Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</span><br><span class="line">                    + right + &quot;,&quot; + bottom + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = true;</span><br><span class="line"></span><br><span class="line">            // Remember our drawn bit</span><br><span class="line">            int drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">            int oldWidth = mRight - mLeft;</span><br><span class="line">            int oldHeight = mBottom - mTop;</span><br><span class="line">            int newWidth = right - left;</span><br><span class="line">            int newHeight = bottom - top;</span><br><span class="line">            boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">            // Invalidate our old position</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">            mLeft = left;</span><br><span class="line">            mTop = top;</span><br><span class="line">            mRight = right;</span><br><span class="line">            mBottom = bottom;</span><br><span class="line">            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">            mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sizeChanged) &#123;</span><br><span class="line">                sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123;</span><br><span class="line">                // If we are visible, force the DRAWN bit to on so that</span><br><span class="line">                // this invalidate will go through (at least to our parent).</span><br><span class="line">                // This is because someone may have invalidated this view</span><br><span class="line">                // before this call to setFrame came in, thereby clearing</span><br><span class="line">                // the DRAWN bit.</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">                invalidate(sizeChanged);</span><br><span class="line">                // parent display list may need to be recreated based on a change in the bounds</span><br><span class="line">                // of any child</span><br><span class="line">                invalidateParentCaches();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Reset drawn bit to original value (invalidate turns it off)</span><br><span class="line">            mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">            mBackgroundSizeChanged = true;</span><br><span class="line">            mDefaultFocusHighlightSizeChanged = true;</span><br><span class="line">            if (mForegroundInfo != null) &#123;</span><br><span class="line">                mForegroundInfo.mBoundsChanged = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">        return changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>layout方法的大致流程如下，首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft，mRight，mTop，mBottom这四个值，View的四个顶点一旦确定，View在父容器中的位置也就确定了；接着会调用onLayout方法，这个用于确定子元素的位置，和onMeasure方法一样，具体的实现和实现类有关，所以View和ViewGroup都没有真正实现onLayout方法。接下来我们可以看一下LinearLayout的onLayout方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">     if (mOrientation == VERTICAL) &#123;</span><br><span class="line">         layoutVertical(l, t, r, b);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         layoutHorizontal(l, t, r, b);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>和onMeasure一样。他分为数值方向和水平方向，这里分析一下layoutVertical的代码逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">void layoutVertical(int left, int top, int right, int bottom) &#123;</span><br><span class="line">     final int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">     int childTop;</span><br><span class="line">     int childLeft;</span><br><span class="line"></span><br><span class="line">     // Where right end of child should go</span><br><span class="line">     final int width = right - left;</span><br><span class="line">     int childRight = width - mPaddingRight;</span><br><span class="line"></span><br><span class="line">     // Space available for child</span><br><span class="line">     int childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line"></span><br><span class="line">     final int count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">     final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">     final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">     switch (majorGravity) &#123;</span><br><span class="line">        case Gravity.BOTTOM:</span><br><span class="line">            // mTotalLength contains the padding already</span><br><span class="line">            childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // mTotalLength contains the padding already</span><br><span class="line">        case Gravity.CENTER_VERTICAL:</span><br><span class="line">            childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case Gravity.TOP:</span><br><span class="line">        default:</span><br><span class="line">            childTop = mPaddingTop;</span><br><span class="line">            break;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">         final View child = getVirtualChildAt(i);</span><br><span class="line">         if (child == null) &#123;</span><br><span class="line">             childTop += measureNullChild(i);</span><br><span class="line">         &#125; else if (child.getVisibility() != GONE) &#123;</span><br><span class="line">             final int childWidth = child.getMeasuredWidth();</span><br><span class="line">             final int childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">             final LinearLayout.LayoutParams lp =</span><br><span class="line">                     (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">             int gravity = lp.gravity;</span><br><span class="line">             if (gravity &lt; 0) &#123;</span><br><span class="line">                 gravity = minorGravity;</span><br><span class="line">             &#125;</span><br><span class="line">             final int layoutDirection = getLayoutDirection();</span><br><span class="line">             final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">             switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                 case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                     childLeft = paddingLeft + ((childSpace - childWidth) / 2)</span><br><span class="line">                             + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                     break;</span><br><span class="line"></span><br><span class="line">                 case Gravity.RIGHT:</span><br><span class="line">                     childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                     break;</span><br><span class="line"></span><br><span class="line">                 case Gravity.LEFT:</span><br><span class="line">                 default:</span><br><span class="line">                     childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                     break;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                 childTop += mDividerHeight;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             childTop += lp.topMargin;</span><br><span class="line">             // 在这里</span><br><span class="line">             setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                     childWidth, childHeight);</span><br><span class="line">             childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">             i += getChildrenSkipCount(child, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>看一下上方的代码。可以看到会遍历所有的子元素并调用getChildFram方法来为子元素指定位置。其中childTop会逐渐增大，这就意味着后面的子元素会被放置在靠下的位置，这刚好符合竖直方向的特性，至于getChildFram，他有调用子元素的layout方法，这样父元素在layout方法中完成了堆自己的定位后，就通过onLayout方法去调用子元素的layout方法，子元素优惠通过layout来确定自己的位置，这样一层一层传递下去，就完成了对View树的遍历过程。setChildFram方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void setChildFrame(View child, int left, int top, int width, int height) &#123;</span><br><span class="line">     child.layout(left, top, left + width, top + height);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>setChildFrame的值是child的width和height。<br>这里来回答一个之前的问题，View的测量宽高和最终宽高的区别：这个问题可以翻译为View的getMeasureWidth和getWidth这两个方法有什么区别<br>看一下getWidth的方法实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getWidth()&#123;</span><br><span class="line">  return mRight-mLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从getWidth的源码和结合mLeft、mRight、mTop、mBottom这四个变量的负值过程来看，getWIdth方法返回的就是View的测量宽度。经过上述分析，可以回答这个问题。在View的默认实现中，View的测量宽和高和最终宽和高是相等的，只不过测量宽和高形成在View的measure过程，而最终宽和高形成与View的layout过程，即两者的赋值时机不同，测量宽和高的赋值时机稍微早一些。但是在一些情况下确实会不一样<br>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">重写了View的layout方法</span><br><span class="line"></span><br><span class="line">public void layout(int l,int t,int r,int b)&#123;</span><br><span class="line">  suber.layout(l,t,r+100,b+100);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会导致View的最终宽和高总是比测量宽和高大100px，这样会导致View显示不正常。还有一种是要多次测量的情况，前几次测量的宽和高可能和最终宽和高不一致</p>
<h2 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h2><p>draw过程就比较简单了，他的作用是将View绘制到屏幕上面，View的绘制过程遵循下面几步：</p>
<ol>
<li>绘制背景</li>
<li>绘制自己</li>
<li>绘制children</li>
<li>绘制装饰</li>
</ol>
<p>这个可以从的draw源码可以很明显的看出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">       final int privateFlags = mPrivateFlags;</span><br><span class="line">       final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">               (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">        * in the appropriate order:</span><br><span class="line">        *</span><br><span class="line">        *      1. Draw the background</span><br><span class="line">        *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class="line">        *      3. Draw view&apos;s content</span><br><span class="line">        *      4. Draw children</span><br><span class="line">        *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">        *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">       // Step 1, draw the background, if needed</span><br><span class="line">       int saveCount;</span><br><span class="line"></span><br><span class="line">       if (!dirtyOpaque) &#123;</span><br><span class="line">           drawBackground(canvas);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">       final int viewFlags = mViewFlags;</span><br><span class="line">       boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">       boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">       if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">           // Step 3, draw the content</span><br><span class="line">           if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">           // Step 4, draw the children</span><br><span class="line">           dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">           drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">           // Overlay is part of the content and draws beneath Foreground</span><br><span class="line">           if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">           onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">           // Step 7, draw the default focus highlight</span><br><span class="line">           drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">           if (debugDraw()) &#123;</span><br><span class="line">               debugDrawFocus(canvas);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // we&apos;re done...</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Here we do the full fledged routine...</span><br><span class="line">        * (this is an uncommon case where speed matters less,</span><br><span class="line">        * this is why we repeat some of the tests that have been</span><br><span class="line">        * done above)</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">       boolean drawTop = false;</span><br><span class="line">       boolean drawBottom = false;</span><br><span class="line">       boolean drawLeft = false;</span><br><span class="line">       boolean drawRight = false;</span><br><span class="line"></span><br><span class="line">       float topFadeStrength = 0.0f;</span><br><span class="line">       float bottomFadeStrength = 0.0f;</span><br><span class="line">       float leftFadeStrength = 0.0f;</span><br><span class="line">       float rightFadeStrength = 0.0f;</span><br><span class="line"></span><br><span class="line">       // Step 2, save the canvas&apos; layers</span><br><span class="line">       int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">       final boolean offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">       if (offsetRequired) &#123;</span><br><span class="line">           paddingLeft += getLeftPaddingOffset();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int left = mScrollX + paddingLeft;</span><br><span class="line">       int right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">       int top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">       int bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">       if (offsetRequired) &#123;</span><br><span class="line">           right += getRightPaddingOffset();</span><br><span class="line">           bottom += getBottomPaddingOffset();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">       final float fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">       int length = (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">       // clip the fade length if top and bottom fades overlap</span><br><span class="line">       // overlapping fades produce odd-looking artifacts</span><br><span class="line">       if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">           length = (bottom - top) / 2;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // also clip horizontal fades if necessary</span><br><span class="line">       if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">           length = (right - left) / 2;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (verticalEdges) &#123;</span><br><span class="line">           topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">           drawTop = topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">           bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">           drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (horizontalEdges) &#123;</span><br><span class="line">           leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">           drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">           rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">           drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">       int solidColor = getSolidColor();</span><br><span class="line">       if (solidColor == 0) &#123;</span><br><span class="line">           final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">           if (drawTop) &#123;</span><br><span class="line">               canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (drawBottom) &#123;</span><br><span class="line">               canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (drawLeft) &#123;</span><br><span class="line">               canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (drawRight) &#123;</span><br><span class="line">               canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Step 3, draw the content</span><br><span class="line">       if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">       // Step 4, draw the children</span><br><span class="line">       dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">       // Step 5, draw the fade effect and restore layers</span><br><span class="line">       final Paint p = scrollabilityCache.paint;</span><br><span class="line">       final Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">       final Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">       if (drawTop) &#123;</span><br><span class="line">           matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">           matrix.postTranslate(left, top);</span><br><span class="line">           fade.setLocalMatrix(matrix);</span><br><span class="line">           p.setShader(fade);</span><br><span class="line">           canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (drawBottom) &#123;</span><br><span class="line">           matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">           matrix.postRotate(180);</span><br><span class="line">           matrix.postTranslate(left, bottom);</span><br><span class="line">           fade.setLocalMatrix(matrix);</span><br><span class="line">           p.setShader(fade);</span><br><span class="line">           canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (drawLeft) &#123;</span><br><span class="line">           matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">           matrix.postRotate(-90);</span><br><span class="line">           matrix.postTranslate(left, top);</span><br><span class="line">           fade.setLocalMatrix(matrix);</span><br><span class="line">           p.setShader(fade);</span><br><span class="line">           canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (drawRight) &#123;</span><br><span class="line">           matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">           matrix.postRotate(90);</span><br><span class="line">           matrix.postTranslate(right, top);</span><br><span class="line">           fade.setLocalMatrix(matrix);</span><br><span class="line">           p.setShader(fade);</span><br><span class="line">           canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">       drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">       // Overlay is part of the content and draws beneath Foreground</span><br><span class="line">       if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">           mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">       onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">       if (debugDraw()) &#123;</span><br><span class="line">           debugDrawFocus(canvas);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先调用<code>drawBackground</code>方法，其次调用<code>dispatchDraw(canvas);</code>来传递绘制过程，看一下ViewGroup的的<code>dispatchDraw(canvas)</code>过程，可以看到会调用<code>drawChild</code>方法，这个时候就会调用child的<code>draw</code>方法，这样就一层层传递下去了，View有一个特殊的方法，serWillNotDraw，先看一下他的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * If this view doesn&apos;t do any drawing on its own, set this flag to</span><br><span class="line"> * allow further optimizations. By default, this flag is not set on</span><br><span class="line"> * View, but could be set on some View subclasses such as ViewGroup.</span><br><span class="line"> *</span><br><span class="line"> * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;</span><br><span class="line"> * you should clear this flag.</span><br><span class="line"> *</span><br><span class="line"> * @param willNotDraw whether or not this View draw on its own</span><br><span class="line"> */</span><br><span class="line">public void setWillNotDraw(boolean willNotDraw) &#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个方法的注释可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true之后，系统会进行优化。默认情况下，View没有启动这个标记位，但是Viewgroup模式启动这个优化标记位，这个标记位对于实际看法的意义是：当我们自定义控件ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位以便系统进行优化。当然明确知道一个ViewGroup需要onDraw来绘制内容是，需要显示关闭这个WILL_NOT_DRAW这个标记位。</p>
<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><p>这一节讲解一下自定义View相关知识，自定义View的作用就不用多说了，下面进入正题。</p>
<h2 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h2><p>自定义View这里，书的作者分为四类</p>
<ol>
<li>重写View的onDraw方法<br>这种方法主要用来实现一些不规则的效果，即这种显示效果不方便使用布局直接叠加或者组合得到，往往需要静态或者动态显示一些不规则图形，比如股票的折线图，圆饼图等等。这个就要求重写onDraw方法，采用这种方式需要自己支持wrap_content，并且padding也需要自己处理</li>
<li>继承ViewGroup派生特殊的Layout<br>这种方式主要实现了自定义布局，即除了LinearLayout、RelativeLayout、FrameLayout这几种系统布局之外，重新定义了一种新布局。当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法，一般要处理ViewGroup的测量和布局这两个过程，并同时处理子元素的测量和布局过程</li>
<li>继承特定的View(比如：TextView)<br>这种方式比较常见，一般是用于拓展某种已有的View的功能，比如TextView，这个方式比较容易，不用自己处理wrap_content和padding</li>
<li>继承特定的ViewGroup(比如：LinearLayout)<br>这种方式也是比较常见的，当某种效果看起来像是几个View组合在一起的时候，可以使用这种方式。采用这种方式不需要自己处理测量和布局这两个过程。</li>
</ol>
<h2 id="自定义View须知"><a href="#自定义View须知" class="headerlink" title="自定义View须知"></a>自定义View须知</h2><p>介绍一下自定义View过程中的一些注意事项，这些问题如果处理不好，会影响View的正常使用，而有些则会导致内存泄漏等。</p>
<ol>
<li>让View支持wrap_content<br>这个是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在不居中使用wrap_content的时候就无法达到预期的效果，具体原因在之前已经介绍过了</li>
<li>如果有必要，让你的View支持padding<br>这个是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的，另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响</li>
<li>尽量不要在View中使用Handler，没必要<br>这个是因为View本身提供了post系列方法，完全可以替代Handler的作用，当然除非你很明确的要使用handler来发送消息</li>
<li>View中如果有动画或者线程，需要及时停止，参考View#OnDetachedFromWindow<br>这一条也很好理解，如果有线程或者动画需要停止，那么OnDetachedFromWindow是一个很好的时机，当包含View的Activity退出当前View或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow。当包含此View的Activity启动时，这个方法就会被调用。当View不可见或者我们需要停止线程或者动画的时候，如果不及时处理，可能导致内存泄漏</li>
<li>View带有滑动嵌套的情景时，需要处理好滑动冲突<br>如果有滑动冲突的话，那么要合适的处理滑动冲突。否则将严重影响View的效果，如何处理之前介绍过</li>
</ol>
<h2 id="自定义View的示例"><a href="#自定义View的示例" class="headerlink" title="自定义View的示例"></a>自定义View的示例</h2><p>这里按照自定义View的分类来进行</p>
<ol>
<li>继承View重写onDraw方法<br>这里看主要用于实现一些特殊的图形，一般需要重写onDraw方法采用这用方式需要自己支持wrap_content，并且padding也需要自己来处理。这里就来一个demo练习一下。<br>为了更好的展示一些平时不容易注意的问题，这里选择实现一个很简单的自定义控件，绘制一个园。为了实现一个规范的自定义控件，需要考虑到wrap_content模式以及padding，同时为了提高便捷性，还要对外提供自定义属性。这里来看一下<br>第一个粗糙版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CircleView extends View &#123;</span><br><span class="line">    private int mColor= Color.RED;</span><br><span class="line">    private Paint mPaint=new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public CircleView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public CircleView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        int width=getWidth();</span><br><span class="line">        int height=getHeight();</span><br><span class="line">        int radius=Math.min(width,height)/2;</span><br><span class="line">        canvas.drawCircle(width/2,height/2,radius,mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mPaint.setColor(mColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>来看一下在不同布局情况下的显示<br>第一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ffffff&quot;</span><br><span class="line">    tools:context=&quot;com.smart.kaifa.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.smart.kaifa.CircleView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="device-2018-04-30-121159.png" alt="Alt text" title="没有设置margin的情况"></p>
<p>第二种情况： 设置margin的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ffffff&quot;</span><br><span class="line">    tools:context=&quot;com.smart.kaifa.MainActivity&quot;&gt;</span><br><span class="line">    &lt;com.smart.kaifa.CircleView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:layout_margin=&quot;20dp&quot;</span><br><span class="line">        android:background=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="device-2018-04-30-121943.png" alt="Alt text" title="设置margin的情况"></p>
<p>第三种情况： 设置margin的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ffffff&quot;</span><br><span class="line">    tools:context=&quot;com.smart.kaifa.MainActivity&quot;&gt;</span><br><span class="line">    &lt;com.smart.kaifa.CircleView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:layout_margin=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;20dp&quot;</span><br><span class="line">        android:background=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p><img src="device-2018-04-30-121943.png" alt="Alt text" title="设置margin和padding的情况"><br>可以看到和之前一样，这个就说明padding需要我们自己来处理<br>第四种情况： 设置wrap_content的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ffffff&quot;</span><br><span class="line">    tools:context=&quot;com.smart.kaifa.MainActivity&quot;&gt;</span><br><span class="line">    &lt;com.smart.kaifa.CircleView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:layout_margin=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;20dp&quot;</span><br><span class="line">        android:background=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="device-2018-04-30-121943.png" alt="Alt text" title="设置wrap_content的情况"><br>可以看到并没有任何变化，不能满足我们的需求，这里的wrap_content和match_parent没有任何区别，可以看一下上面对ViewGroup的<code>getChildMeasureSpec</code>这个方法的分析就明白了</p>
<ul>
<li>首先针对第一种情况wrap_content<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    int widthSpecSize=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    if(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(mWidth.mHeight);</span><br><span class="line">    &#125;else   if(widthSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(mWidth.heightSpecSize);</span><br><span class="line">    &#125;else   if(heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(widthSpecSize.mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以参考之前的处理方式在4.3.1那一段已经做了介绍，这里就不再次说明了。</p>
<ul>
<li>其次，针对padding的问题，只需要在绘制的时候考虑一下padding就可以</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class CircleView extends View &#123;</span><br><span class="line">    private int mColor= Color.RED;</span><br><span class="line">    private Paint mPaint=new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    public CircleView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public CircleView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int widthSpecSize=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        if(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(200,200);</span><br><span class="line">        &#125;else   if(widthSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(200,heightSpecSize);</span><br><span class="line">        &#125;else   if(heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(widthSpecSize,200);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        int paddingBottom = getPaddingBottom();</span><br><span class="line">        int paddingLeft = getPaddingLeft();</span><br><span class="line">        int paddingRight = getPaddingRight();</span><br><span class="line">        int paddingTop = getPaddingTop();</span><br><span class="line">        int width=getWidth()-paddingLeft-paddingRight;</span><br><span class="line">        int height=getHeight()-paddingTop-paddingBottom;</span><br><span class="line">        int radius=Math.min(width,height)/2;</span><br><span class="line">        canvas.drawCircle(paddingLeft+width/2,paddingTop+height/2,radius,mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mPaint.setColor(mColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下修改之后2.0版本的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ffffff&quot;</span><br><span class="line">    tools:context=&quot;com.smart.kaifa.MainActivity&quot;&gt;</span><br><span class="line">    &lt;com.smart.kaifa.CircleView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:layout_margin=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;20dp&quot;</span><br><span class="line">        android:background=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在看一下效果<br><img src="device-2018-04-30-134320.png" alt="Alt text" title="2.0版本效果"></p>
<p>最后为了让这个控件更加容易使用，我们使用自定义属性来强化他<br>如何添加自定义属性呢？<br>第一步是在attrs.xml中或者新建attrs_circle_view.xml这类以attrs开头的文件。在value文件夹中新建一个attres.xml或者attrs_circle_view.xml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name=&quot;CircleView&quot;&gt;</span><br><span class="line">        &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>使用自定义属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CircleView extends View &#123;</span><br><span class="line">    private int mColor= Color.RED;</span><br><span class="line">    private Paint mPaint=new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    public CircleView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public CircleView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs,0);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.CircleView);</span><br><span class="line">        mColor=a.getColor(R.styleable.CircleView_circle_color,Color.RED);</span><br><span class="line">        a.recycle();</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int widthSpecSize=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        if(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(200,200);</span><br><span class="line">        &#125;else   if(widthSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(200,heightSpecSize);</span><br><span class="line">        &#125;else   if(heightSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(widthSpecSize,200);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        int paddingBottom = getPaddingBottom();</span><br><span class="line">        int paddingLeft = getPaddingLeft();</span><br><span class="line">        int paddingRight = getPaddingRight();</span><br><span class="line">        int paddingTop = getPaddingTop();</span><br><span class="line">        int width=getWidth()-paddingLeft-paddingRight;</span><br><span class="line">        int height=getHeight()-paddingTop-paddingBottom;</span><br><span class="line">        int radius=Math.min(width,height)/2;</span><br><span class="line">        canvas.drawCircle(paddingLeft+width/2,paddingTop+height/2,radius,mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mPaint.setColor(mColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ffffff&quot;</span><br><span class="line">    tools:context=&quot;com.smart.kaifa.MainActivity&quot;&gt;</span><br><span class="line">    &lt;com.smart.kaifa.CircleView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:layout_margin=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;20dp&quot;</span><br><span class="line">        app:circle_color=&quot;#00ffff&quot;</span><br><span class="line">        android:background=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p><img src="device-2018-04-30-153738.png" alt="Alt text" title="添加入自定义属性之后的效果"></p>
<ol start="2">
<li>继承ViewGroup派生特殊的Layout<br>这种方式主要用于实现自定义的布局，采用这种方式稍微复杂一些，需要处理ViewGroup的测量和布局这两个过程，并同时处理子元素的测量和布局过程。<br>在第三章中我们分析了滑动冲突的两种情况，并实现两个自定义View：HorizontalScrollViewEx和StickyLayout，其中HorizontalScrollViewEx就是通过继承ViewGroup来实现的自定义View，这里会再次分析一下他的measure和layout过程。<br>需要说明的是，如果要采用这种方式实现一个很规范的自定义View，是有一定代价的，这里通过点击LinearLayout等的源码就可以知道，他们的实现都很复杂，对于这一个控件来说，这里不打算实现他的方方面面，仅仅完成主要的功能，但是会对需要优化的地方做出说明。<br>这里在回顾一下HorizontalScrollViewEx的功能，他主要是一个类似ViewPager的控件，也可以说是一个类似水平方向LinearLayout的控件，他的内部子元素可以进行水平滑动，并且子元素内部可以进行竖直滑动。这显然是存在冲突的，但是HorizontalScrollView内部解决了水平和竖直滑动冲突的问题，如何解决冲突，可以参照一下之前的方法，在父布局处理或者在子布局处理。<br>这里有一个假设：就是所有子元素的宽和高都是一样的。先看一下<code>onMeasure</code>方法和<code>onLayout</code>方法的具体实现。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int measureWidth=0;</span><br><span class="line">        int measureHeight=0;</span><br><span class="line">        final int childCount=getChildCount();</span><br><span class="line">        //测量子控件</span><br><span class="line">        measureChildren(widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">        int widthSpaceSize=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int widthSpeceMode=MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightSpaceSize=MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        int heightSpaceMode=MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        if(childCount==0)&#123;</span><br><span class="line">            //设置宽和高</span><br><span class="line">            setMeasuredDimension(0,0);</span><br><span class="line">        &#125;else if(widthSpeceMode==MeasureSpec.AT_MOST&amp;&amp;heightSpaceMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            final View childView=getChildAt(0);</span><br><span class="line">            measureWidth=childView.getMeasuredWidth()*childCount;</span><br><span class="line">            measureHeight=childView.getMeasuredHeight();</span><br><span class="line">            setMeasuredDimension(measureWidth,measureHeight);</span><br><span class="line">        &#125;else if(widthSpeceMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            final View childView=getChildAt(0);</span><br><span class="line">            measureHeight=childView.getMeasuredHeight();</span><br><span class="line">            setMeasuredDimension(widthSpaceSize,measureHeight);</span><br><span class="line">        &#125;else if(heightSpaceMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            final View childView=getChildAt(0);</span><br><span class="line">            measureWidth=childView.getMeasuredWidth()*childCount;</span><br><span class="line">            setMeasuredDimension(measureWidth,heightSpaceSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里说明一下下上述代码的逻辑，首先会判断是否有子元素，如果没有子元素，就通过<code>setMeasuredDimension</code>设置自身的宽和高为0，然后就是判断宽和高是不是采用了wrap_content，如果宽采用了wrap_content，那么就是所有子元素宽度之和，高度也一样<br>这里不规范的地方相比大家也可以看出来：第一个是没有子元素的时候不应该把宽和高直接设置成0，而是应当根据LayoutParams中的宽和高来做相对应的处理；第二个是在测量HorizontalScrollViewEx的宽和高时，没有考虑到他的padding以及子元素的margin，这样会影响HorizontalScrollViewEx的宽和高。这个很好理解，因为不管是子元素的margin还是自己的padding,都会影响HorizontalScrollViewEx所占用的空间。<br>在看一下onLayout方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">     int childLeft=0;</span><br><span class="line">     final int childCound=getChildCount();</span><br><span class="line">     mChildSize=childCound;</span><br><span class="line">     for (int i = 0; i &lt; childCound; i++) &#123;</span><br><span class="line">         final View childView=getChildAt(i);</span><br><span class="line">         if(childView.getVisibility()!=View.GONE)&#123;</span><br><span class="line">             final int childWidth=childView.getMeasuredWidth();</span><br><span class="line">             mChildWidth=childWidth;</span><br><span class="line">             //不断向右边移动，x不断加大</span><br><span class="line">             childView.layout(childLeft,0,childLeft+childWidth,childView.getMeasuredHeight());</span><br><span class="line">             childLeft+=childWidth;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码逻辑并不是非常复杂，作用是完成对子View的定位。首先会遍历所有的子元素，如果这个子元素不是处于Gone状态，就通过layout方法将其放在合适的位置。从上面代码来看是从左向右的，这个和水平方向的LinearLayout比较相似，然而代码依旧不完善。没有考虑到自身的padding以及子元素的margin，而从一个规范的控件的角度来讲，这些都应该是要考虑的。</p>
<p>这里给出HorizontalScrollViewEx的源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">public class HorizontalScrollViewEx extends FrameLayout &#123;</span><br><span class="line">    private static final String TAG = &quot;HorizontalScrollViewEx&quot;;</span><br><span class="line">    private int mChildrenSize=3;</span><br><span class="line">    private int mCHildWidth=1440;</span><br><span class="line">    private int mChildIndex;</span><br><span class="line">    private int mLastX = 0;</span><br><span class="line">    private int mLastY = 0;</span><br><span class="line">    private int mLastXIntercept = 0;</span><br><span class="line">    private int mLastYIntercept = 0;</span><br><span class="line"></span><br><span class="line">    private Scroller mScroller;</span><br><span class="line">    private VelocityTracker mVelpcityTracker;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mScroller = new Scroller(getContext());</span><br><span class="line">        mVelpcityTracker = VelocityTracker.obtain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HorizontalScrollViewEx(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HorizontalScrollViewEx(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HorizontalScrollViewEx(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        boolean intercepted = false;</span><br><span class="line">        int x = (int) event.getX();</span><br><span class="line">        int y = (int) event.getY();</span><br><span class="line"></span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                intercepted = false;</span><br><span class="line">                if (!mScroller.isFinished()) &#123;</span><br><span class="line">                    //动画没有结束强制结束动画</span><br><span class="line">                    mScroller.abortAnimation();</span><br><span class="line">                    intercepted = true;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                int deltaX = x - mLastXIntercept;</span><br><span class="line">                int deltaY = x - mLastYIntercept;</span><br><span class="line">                if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">                    intercepted = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    intercepted = false;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                intercepted = false;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(&quot;哇哈哈&quot;, &quot;intercepted :&quot; + intercepted);</span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        mLastXIntercept = x;</span><br><span class="line">        mLastYIntercept = y;</span><br><span class="line">        return intercepted;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">        int childLeft = 0;</span><br><span class="line">        final int childCount = getChildCount();</span><br><span class="line">        mChildrenSize = childCount;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            final View childView = getChildAt(i);</span><br><span class="line">            if (childView.getVisibility() != View.GONE) &#123;</span><br><span class="line">                final int childWidth = childView.getMeasuredWidth();</span><br><span class="line">                childView.layout(childLeft, 0, childLeft + childWidth,</span><br><span class="line">                        childView.getMeasuredHeight());</span><br><span class="line">                childLeft += childWidth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        mVelpcityTracker.addMovement(event);</span><br><span class="line">        int x = (int) event.getX();</span><br><span class="line">        int y = (int) event.getY();</span><br><span class="line"></span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                if (!mScroller.isFinished()) &#123;</span><br><span class="line">                    //动画没有结束强制结束动画</span><br><span class="line">                    mScroller.abortAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                int deltaX = x - mLastX;</span><br><span class="line">                int deltaY = x - mLastY;</span><br><span class="line">                scrollBy(-deltaX, 0);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                int scrollX = getScrollX();</span><br><span class="line">                int scrollToChildIndex = scrollX / mCHildWidth;</span><br><span class="line">                mVelpcityTracker.computeCurrentVelocity(1000);</span><br><span class="line">                float xVelocity = mVelpcityTracker.getXVelocity();</span><br><span class="line">                if (Math.abs(xVelocity) &gt;= 50) &#123;</span><br><span class="line">                    mChildIndex = xVelocity &gt; 0 ? mChildIndex - 1 : mChildIndex + 1;</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mChildIndex = (scrollX + mCHildWidth / 2) / mCHildWidth;</span><br><span class="line">                &#125;</span><br><span class="line">                mChildIndex = Math.max(0, Math.min(mChildIndex, mChildrenSize - 1));</span><br><span class="line">                int dx = mChildIndex * mCHildWidth - scrollX;</span><br><span class="line">                smoothScrollBy(dx, 0);</span><br><span class="line">                mVelpcityTracker.clear();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        mLastX = x;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void smoothScrollBy(int dx, int i) &#123;</span><br><span class="line">        mScroller.startScroll(getScrollX(), 0, dx, 0, 500);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void computeScroll() &#123;</span><br><span class="line">        if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        super.computeScroll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承特定的View比如TextView和继承特定ViewGroup这个比较简单，这里就不说了，可以参考android群英传</p>
<p>这里在写一下StickyLayout的源码 <a href="https://github.com/singwhatiwanna/PinnedHeaderExpandableListView/tree/master/PinnedHeaderExpandableListView" target="_blank" rel="noopener">https://github.com/singwhatiwanna/PinnedHeaderExpandableListView/tree/master/PinnedHeaderExpandableListView</a> 这个是作者的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">public class StickyLayout extends LinearLayout &#123;</span><br><span class="line">    private static final String TAG = &quot;StickyLayout&quot;;</span><br><span class="line">    private static final boolean DEBUG = true;</span><br><span class="line"></span><br><span class="line">    public interface OnGiveUpTouchEventListener &#123;</span><br><span class="line">        public boolean giveUpTouchEvent(MotionEvent event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private View mHeader;</span><br><span class="line">    private View mContent;</span><br><span class="line">    private OnGiveUpTouchEventListener mGiveUpTouchEventListener;</span><br><span class="line"></span><br><span class="line">    // header的高度  单位：px</span><br><span class="line">    private int mOriginalHeaderHeight;</span><br><span class="line">    private int mHeaderHeight;</span><br><span class="line"></span><br><span class="line">    private int mStatus = STATUS_EXPANDED;</span><br><span class="line">    public static final int STATUS_EXPANDED = 1;</span><br><span class="line">    public static final int STATUS_COLLAPSED = 2;</span><br><span class="line"></span><br><span class="line">    private int mTouchSlop;</span><br><span class="line"></span><br><span class="line">    // 分别记录上次滑动的坐标</span><br><span class="line">    private int mLastX = 0;</span><br><span class="line">    private int mLastY = 0;</span><br><span class="line"></span><br><span class="line">    // 分别记录上次滑动的坐标(onInterceptTouchEvent)</span><br><span class="line">    private int mLastXIntercept = 0;</span><br><span class="line">    private int mLastYIntercept = 0;</span><br><span class="line"></span><br><span class="line">    // 用来控制滑动角度，仅当角度a满足如下条件才进行滑动：tan a = deltaX / deltaY &gt; 2</span><br><span class="line">    private static final int TAN = 2;</span><br><span class="line"></span><br><span class="line">    private boolean mIsSticky = true;</span><br><span class="line">    private boolean mInitDataSucceed = false;</span><br><span class="line">    private boolean mDisallowInterceptTouchEventOnHeader = true;</span><br><span class="line"></span><br><span class="line">    public StickyLayout(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StickyLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">    public StickyLayout(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">        super(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onWindowFocusChanged(boolean hasWindowFocus) &#123;</span><br><span class="line">        super.onWindowFocusChanged(hasWindowFocus);</span><br><span class="line">        if (hasWindowFocus &amp;&amp; (mHeader == null || mContent == null)) &#123;</span><br><span class="line">            initData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        int headerId= getResources().getIdentifier(&quot;sticky_header&quot;, &quot;id&quot;, getContext().getPackageName());</span><br><span class="line">        int contentId = getResources().getIdentifier(&quot;sticky_content&quot;, &quot;id&quot;, getContext().getPackageName());</span><br><span class="line">        if (headerId != 0 &amp;&amp; contentId != 0) &#123;</span><br><span class="line">            mHeader = findViewById(headerId);</span><br><span class="line">            mContent = findViewById(contentId);</span><br><span class="line">            mOriginalHeaderHeight = mHeader.getMeasuredHeight();</span><br><span class="line">            mHeaderHeight = mOriginalHeaderHeight;</span><br><span class="line">            mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br><span class="line">            if (mHeaderHeight &gt; 0) &#123;</span><br><span class="line">                mInitDataSucceed = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;mTouchSlop = &quot; + mTouchSlop + &quot;mHeaderHeight = &quot; + mHeaderHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new NoSuchElementException(&quot;Did your view with id \&quot;sticky_header\&quot; or \&quot;sticky_content\&quot; exists?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnGiveUpTouchEventListener(OnGiveUpTouchEventListener l) &#123;</span><br><span class="line">        mGiveUpTouchEventListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        int intercepted = 0;</span><br><span class="line">        int x = (int) event.getX();</span><br><span class="line">        int y = (int) event.getY();</span><br><span class="line"></span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            mLastXIntercept = x;</span><br><span class="line">            mLastYIntercept = y;</span><br><span class="line">            mLastX = x;</span><br><span class="line">            mLastY = y;</span><br><span class="line">            intercepted = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            int deltaX = x - mLastXIntercept;</span><br><span class="line">            int deltaY = y - mLastYIntercept;</span><br><span class="line">            if (mDisallowInterceptTouchEventOnHeader &amp;&amp; y &lt;= getHeaderHeight()) &#123;</span><br><span class="line">                intercepted = 0;</span><br><span class="line">            &#125; else if (Math.abs(deltaY) &lt;= Math.abs(deltaX)) &#123;</span><br><span class="line">                intercepted = 0;</span><br><span class="line">            &#125; else if (mStatus == STATUS_EXPANDED &amp;&amp; deltaY &lt;= -mTouchSlop) &#123;</span><br><span class="line">                intercepted = 1;</span><br><span class="line">            &#125; else if (mGiveUpTouchEventListener != null) &#123;</span><br><span class="line">                if (mGiveUpTouchEventListener.giveUpTouchEvent(event) &amp;&amp; deltaY &gt;= mTouchSlop) &#123;</span><br><span class="line">                    intercepted = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            intercepted = 0;</span><br><span class="line">            mLastXIntercept = mLastYIntercept = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;intercepted=&quot; + intercepted);</span><br><span class="line">        &#125;</span><br><span class="line">        return intercepted != 0 &amp;&amp; mIsSticky;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        if (!mIsSticky) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = (int) event.getX();</span><br><span class="line">        int y = (int) event.getY();</span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            int deltaX = x - mLastX;</span><br><span class="line">            int deltaY = y - mLastY;</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;mHeaderHeight=&quot; + mHeaderHeight + &quot;  deltaY=&quot; + deltaY + &quot;  mlastY=&quot; + mLastY);</span><br><span class="line">            &#125;</span><br><span class="line">            mHeaderHeight += deltaY;</span><br><span class="line">            setHeaderHeight(mHeaderHeight);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            // 这里做了下判断，当松开手的时候，会自动向两边滑动，具体向哪边滑，要看当前所处的位置</span><br><span class="line">            int destHeight = 0;</span><br><span class="line">            if (mHeaderHeight &lt;= mOriginalHeaderHeight * 0.5) &#123;</span><br><span class="line">                destHeight = 0;</span><br><span class="line">                mStatus = STATUS_COLLAPSED;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                destHeight = mOriginalHeaderHeight;</span><br><span class="line">                mStatus = STATUS_EXPANDED;</span><br><span class="line">            &#125;</span><br><span class="line">            // 慢慢滑向终点</span><br><span class="line">            this.smoothSetHeaderHeight(mHeaderHeight, destHeight, 500);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void smoothSetHeaderHeight(final int from, final int to, long duration) &#123;</span><br><span class="line">        smoothSetHeaderHeight(from, to, duration, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void smoothSetHeaderHeight(final int from, final int to, long duration, final boolean modifyOriginalHeaderHeight) &#123;</span><br><span class="line">        final int frameCount = (int) (duration / 1000f * 30) + 1;</span><br><span class="line">        final float partation = (to - from) / (float) frameCount;</span><br><span class="line">        new Thread(&quot;Thread#smoothSetHeaderHeight&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; frameCount; i++) &#123;</span><br><span class="line">                    final int height;</span><br><span class="line">                    if (i == frameCount - 1) &#123;</span><br><span class="line">                        height = to;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        height = (int) (from + partation * i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    post(new Runnable() &#123;</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            setHeaderHeight(height);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (modifyOriginalHeaderHeight) &#123;</span><br><span class="line">                    setOriginalHeaderHeight(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOriginalHeaderHeight(int originalHeaderHeight) &#123;</span><br><span class="line">        mOriginalHeaderHeight = originalHeaderHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeaderHeight(int height, boolean modifyOriginalHeaderHeight) &#123;</span><br><span class="line">        if (modifyOriginalHeaderHeight) &#123;</span><br><span class="line">            setOriginalHeaderHeight(height);</span><br><span class="line">        &#125;</span><br><span class="line">        setHeaderHeight(height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeaderHeight(int height) &#123;</span><br><span class="line">        if (!mInitDataSucceed) &#123;</span><br><span class="line">            initData();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;setHeaderHeight height=&quot; + height);</span><br><span class="line">        &#125;</span><br><span class="line">        if (height &lt;= 0) &#123;</span><br><span class="line">            height = 0;</span><br><span class="line">        &#125; else if (height &gt; mOriginalHeaderHeight) &#123;</span><br><span class="line">            height = mOriginalHeaderHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (height == 0) &#123;</span><br><span class="line">            mStatus = STATUS_COLLAPSED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mStatus = STATUS_EXPANDED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mHeader != null &amp;&amp; mHeader.getLayoutParams() != null) &#123;</span><br><span class="line">            mHeader.getLayoutParams().height = height;</span><br><span class="line">            mHeader.requestLayout();</span><br><span class="line">            mHeaderHeight = height;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.e(TAG, &quot;null LayoutParams when setHeaderHeight&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getHeaderHeight() &#123;</span><br><span class="line">        return mHeaderHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSticky(boolean isSticky) &#123;</span><br><span class="line">        mIsSticky = isSticky;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void requestDisallowInterceptTouchEventOnHeader(boolean disallowIntercept) &#123;</span><br><span class="line">        mDisallowInterceptTouchEventOnHeader = disallowIntercept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="滑动分析.gif" alt="Alt text" title="具体效果"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/进阶/" rel="tag"># 进阶</a>
          
            <a href="/tags/Android开发艺术探索/" rel="tag"># Android开发艺术探索</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/android/Android开发艺术探索_第三章 View的事件体系/" rel="next" title="Android开发艺术探索 第三章 View的事件体系">
                <i class="fa fa-chevron-left"></i> Android开发艺术探索 第三章 View的事件体系
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android/Android开发艺术探索_第五章 理解RemoteViews/" rel="prev" title="Android开发艺术探索 第五章 理解RemoteViews">
                Android开发艺术探索 第五章 理解RemoteViews <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Groot</p>
              <p class="site-description motion-element" itemprop="description">尽信书则不如无书</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#初识ViewRoot和DecorView"><span class="nav-number">1.</span> <span class="nav-text">初识ViewRoot和DecorView</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解MeasureSpec"><span class="nav-number">2.</span> <span class="nav-text">理解MeasureSpec</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MeasureSpec"><span class="nav-number">2.1.</span> <span class="nav-text">MeasureSpec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MeasureSpec和LayoutParams的对应关系"><span class="nav-number">2.2.</span> <span class="nav-text">MeasureSpec和LayoutParams的对应关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View的绘制流程"><span class="nav-number">3.</span> <span class="nav-text">View的绘制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#measure过程"><span class="nav-number">3.1.</span> <span class="nav-text">measure过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#layout过程"><span class="nav-number">3.2.</span> <span class="nav-text">layout过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#draw过程"><span class="nav-number">3.3.</span> <span class="nav-text">draw过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义View"><span class="nav-number">4.</span> <span class="nav-text">自定义View</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义View的分类"><span class="nav-number">4.1.</span> <span class="nav-text">自定义View的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义View须知"><span class="nav-number">4.2.</span> <span class="nav-text">自定义View须知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义View的示例"><span class="nav-number">4.3.</span> <span class="nav-text">自定义View的示例</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Groot</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
